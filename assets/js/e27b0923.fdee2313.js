"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8312],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>c,MDXProvider:()=>p,mdx:()=>f,useMDXComponents:()=>u,withMDXComponents:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),d=function(e){return function(t){var n=u(t.components);return a.createElement(e,i({},t,{components:n}))}},u=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(c.Provider,{value:t},e.children)},h="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(n),p=r,h=d["".concat(o,".").concat(p)]||d[p]||m[p]||i;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},596:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const i={},o="Buck Extension Language (BXL)",s={unversionedId:"rfcs/bxl",id:"rfcs/bxl",title:"Buck Extension Language (BXL)",description:"Buck2 will allow more complex introspection and interaction with its graphs via",source:"@site/../docs/rfcs/bxl.md",sourceDirName:"rfcs",slug:"/rfcs/bxl",permalink:"/docs/rfcs/bxl",draft:!1,tags:[],version:"current",frontMatter:{}},l={},c=[{value:"Use Cases",id:"use-cases",level:2},{value:"Cpp LSP",id:"cpp-lsp",level:3},{value:"Android LSP",id:"android-lsp",level:3},{value:"iOS Project",id:"ios-project",level:3},{value:"Rust LSP",id:"rust-lsp",level:3},{value:"Visual Studio Project (vsgo)",id:"visual-studio-project-vsgo",level:3},{value:"Goals",id:"goals",level:2},{value:"API",id:"api",level:2},{value:"Defining a bxl function",id:"defining-a-bxl-function",level:3},{value:"Accessing target nodes",id:"accessing-target-nodes",level:3},{value:"Inspect providers",id:"inspect-providers",level:3},{value:"Actions",id:"actions",level:3},{value:"What is cached?",id:"what-is-cached",level:3},{value:"Inter-bxl caching?",id:"inter-bxl-caching",level:3}],d=(u="FbInternalOnly",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.mdx)("div",e)});var u;const p={toc:c};function h(e){let{components:t,...n}=e;return(0,r.mdx)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("h1",{id:"buck-extension-language-bxl"},"Buck Extension Language (BXL)"),(0,r.mdx)("p",null,"Buck2 will allow more complex introspection and interaction with its graphs via\nthe ",(0,r.mdx)("inlineCode",{parentName:"p"},"bxl")," feature. BXL will be a starlark script that allows integrators to\ninteract with ",(0,r.mdx)("inlineCode",{parentName:"p"},"buck")," commands like build and query within starlark, creating a\nsequence of operations that introspect, build, and extend the build graph."),(0,r.mdx)(d,{mdxType:"FbInternalOnly"},(0,r.mdx)("p",null,(0,r.mdx)("a",{parentName:"p",href:"https://fb.workplace.com/groups/buck2prototyping/permalink/2404233936540759/"},"https://fb.workplace.com/groups/buck2prototyping/permalink/2404233936540759/"),".")),(0,r.mdx)("p",null,'These are essentially custom buck operations, defined in Starlark, that still\nfollow the constraints of Buck2, which will enable the same level of\nincrementality and caching as native buck2 operations. Furthermore, bxl will\nhave subscriptions enabled in the future, where based on the incrementality\ntracking, buck2 can provide "updated" bxl executions when its known that its\ndependencies change, and even when generated sources need to be regenerated.'),(0,r.mdx)("p",null,"The following proposes a basic set of bxl api and building blocks that are\ntargeted at solving key issues for IDE integration."),(0,r.mdx)("h2",{id:"use-cases"},"Use Cases"),(0,r.mdx)("h3",{id:"cpp-lsp"},"Cpp LSP"),(0,r.mdx)(d,{mdxType:"FbInternalOnly"},(0,r.mdx)("p",null,"I\u2019ve previously defined some proposed integrations\n",(0,r.mdx)("a",{parentName:"p",href:"https://docs.google.com/document/d/1jyehtuQ236rtwq2yyLnLmsIgBOctuAm9eoqx95TCO4I/edit"},"here"),".")),(0,r.mdx)("p",null,"Lsp prefers to have a single buck command that given a file, returns the\ncorresponding compilation database. This requires a single command, i.e a bxl,\nthat accepts a file as input, performs ",(0,r.mdx)("inlineCode",{parentName:"p"},"owners")," queries, and uses the owning\ntarget plus the desired file to get the clang flags, and then writes it to disk\nin comp db format. It\u2019s possible to write the same features using buck calls to\ncquery, and build using subtargets to generate compilation database per file.\nHowever, this requires lsp owners to maintain code in several locations and\nlanguages, and parse and reserialize data. It also does not provide the same\nincrementality and subscription update features of the resulting comp db that\nwriting this in bxl would have. Furthermore, we may explore the idea of trimming\nthe compilation command to only dependencies required per the file requested.\nBxl actions provides a straightforward api for adding this when writing the\nactual comp db file."),(0,r.mdx)("h3",{id:"android-lsp"},"Android LSP"),(0,r.mdx)("p",null,"Android project requires traversing the target graph to find and java libraries,\ngrouping and converting them between modules or project libraries depending on\nthe number of references, and restructuring the graph as directory based.\nAndroid LSP is able to take advantage of subscriptions in the future when\navailable, allowing developers to keep their IDE up-to-date automatically\nwithout needing to manually regenerate the project."),(0,r.mdx)("p",null,"With bxl, the graph traversals can be written in starlark, allowing propagation\nof information down the graph, accessing targets\u2019 attributes to analyze\ndependencies, and access providers for artifacts and action information needed\nto output the project file. Project generation also performs directory listings\nthat buck2\u2019s dice already performs and caches (I think, need to confirm). Bxl\nposes the interesting possibility that we can expose a limited set of IO\noperations that are tracked by dice so bxl can access the same cached file\noperations as rest of buck2. Android project generation currently doesn\u2019t write\nproject files to buck-out, which prevents it from using buck2 actions. It will\nhave to rely on an external script to process the graph information printed by\nbuck and write the actual project files. If it moves to ",(0,r.mdx)("inlineCode",{parentName:"p"},"buck-out")," based, then\nit can take advantage of creating actions directly using the graph information\nprocessed, and potentially take advantage of incremental actions api to avoid\nwriting the entire graph on each subsequent update."),(0,r.mdx)("h3",{id:"ios-project"},"iOS Project"),(0,r.mdx)("p",null,"iOS is currently being implemented as a series of queries that are aggregated by\nan external python script, that then invokes builds of subtargets. The same can\nbe achieved in bxl, but with the entire sequence being cacheable and\nsubscribable so that when the graph is updated, or even when generated files\nneed updating, buck2 can automatically push the updates. However, it is\nuncertain whether xcode itself can make use of push updates."),(0,r.mdx)(d,{mdxType:"FbInternalOnly"},(0,r.mdx)("p",null,"In\n",(0,r.mdx)("a",{parentName:"p",href:"https://docs.google.com/document/d/1USZ_ZYxq45DHUFF-BAYo6zS4lAHlpvNk9uM5SBL9e-w/edit?disco=AAAAQv4gLQ0"},"https://docs.google.com/document/d/1USZ_ZYxq45DHUFF-BAYo6zS4lAHlpvNk9uM5SBL9e-w/edit?disco=AAAAQv4gLQ0"),",\nit was also proposed that project generation may need information to flow down\nas part of the generation, which is only possible via bxl defining its own\nactions. (Although, there may have been a workaround per Chatura).")),(0,r.mdx)("h3",{id:"rust-lsp"},"Rust LSP"),(0,r.mdx)("p",null,"(note from dbarsky@: I\u2019m adding this at Bob\u2019s request. Can be removed as\nneeded.)"),(0,r.mdx)("h3",{id:"visual-studio-project-vsgo"},"Visual Studio Project (vsgo)"),(0,r.mdx)("p",null,"Vsgo is a pile of python that converts buck query/buck targets output via a\nvariety of heuristics into inputs to a custom fork gyp which is then invoked to\ngenerate visual studio projects for a given buck target. Having direct access to\nthe internals of buck would allow us to remove the heuristics and possibly even\nmove project generation directly into bxl."),(0,r.mdx)("h2",{id:"goals"},"Goals"),(0,r.mdx)("p",null,"From the above use cases, BXL should offer a simple Starlark API that allows\neasy introspection of the buck2 graph at unconfigured, configured, providers,\nand actions stage, maintaining incremental behaviour of the BXL evaluation\nitself."),(0,r.mdx)("p",null,"Some minimal API should be offered to allow BXL to provide additional behaviour\nsuch as output artifacts, and print results."),(0,r.mdx)("p",null,"Most use cases from LSP desire to also propagate information via the command\nline for these operations, so BXL should support command line arguments as\ninputs."),(0,r.mdx)("h2",{id:"api"},"API"),(0,r.mdx)("h3",{id:"defining-a-bxl-function"},"Defining a bxl function"),(0,r.mdx)("p",null,"There are multiple models possible. We can have each file be its own bxl, or\nhave each file declare multiple bxl like rules."),(0,r.mdx)("p",null,'There are multiple advantages to allowing declaration of multiple bxls, such as\ngrouping similar bxls in the same file, allowing them to "invoke" each other. It\ndoesn\u2019t necessarily add much more complexity for the author, as even with one\nbxl per file, the author still has to have some declaration for the bxls\narguments.'),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'# sample.bxl\nfunc1 = bxl_main(\n   impl = my_func1,\n   args = {\n     "arg1": arg.list(arg.str()),\n   }\n)\n\nfunc2 = bxl_main(\n   ...\n)\n\n')),(0,r.mdx)("p",null,"To invoke buck2 for that bxl, we can have the command line as follows."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-shell"},"buck2 bxl sample.bxl::func1 -- --arg1 foo bar baz\n")),(0,r.mdx)("p",null,"For bxl functions to read the arguments, a similar api to rule attrs is used"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"args = ctx.args.args_for_bxl\n")),(0,r.mdx)("p",null,"Args defined like attrs when declaring the bxl function above"),(0,r.mdx)("h3",{id:"accessing-target-nodes"},"Accessing target nodes"),(0,r.mdx)("p",null,"All standard query functions will be enabled in bxl, allowing users to run query\noperations, storing them in variables and interacting with them. These allow\nintrospection of the unconfigured targets, or the configured targets based on\napi"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'# some.bxl\ntargets = ctx.uquery(\u2018deps("//foo")\u2019)\ntargets = filter(targets, my_filter)\n\n# introspect a target\nfor target in targets:\n  ctx.print(target.attributes) # prints selects\n  # also inspect the target like below\n  ctx.print(target.label)\n\ntarget = ctx.cquery("//foo", "//x86").attributes # cquery has selects resolved\n')),(0,r.mdx)("h3",{id:"inspect-providers"},"Inspect providers"),(0,r.mdx)("p",null,"When we have a configured target, bxl can request for the analysis of the rule"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},"target = <some configured target>\n\nctx.analysis(target).providers # access the providers\n")),(0,r.mdx)("h3",{id:"actions"},"Actions"),(0,r.mdx)("p",null,"For IDEs, to generate compilation databases, or generate project files, writing\nthem in bxl will entail creating actions, and executing them. As such, bxl will\nalso be given the rules api to register actions, including dynamic outputs for\nthe rule in the current bxl invocation to build artifacts as part of a bxl\nfunction."),(0,r.mdx)("p",null,"BXL has the ability to create actions with some constraints:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},"Action is tied to a particular target"),(0,r.mdx)("li",{parentName:"ol"},"It\u2019s output location is determined in the same pattern as regular actions\ndefined via rules")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'targets = ctx.cquery(\u2018deps("//foo:rule")\u2019)\n\nfor t in targets:\n  action_ctx = ctx.analysis(t).actions\n  # the action context here is tied to the configured target `t`\n  # actions registered by bxl will be attached with bxl prefix key\n  action_ctx.registry.write(some_output, "foo")\n\n')),(0,r.mdx)("p",null,"BXL can also interact with the existing actions on an action via the action_ctx,\nsuch as iterating through it, analyzing its outputs, or requesting it to be ran."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'targets = deps("foo:rule")\n\nfor t in targets:\n  action_ctx = ctx.analysis(t).actions\n  for action in action_ctx.iter():\n    if "foo/path" in action.output:\n      ctx.build(action)\n')),(0,r.mdx)("h3",{id:"what-is-cached"},"What is cached?"),(0,r.mdx)("p",null,"All computations requested by a bxl function will be treated as inputs. So if a\nbxl function calls uquery, then uses the result to do a cquery, and then a\nbuild, if buck2 detects that any of the recorded calls to uquery, cquery, and\nbuild changes, the entire bxl will be reran, with no early cutoff. The\ncomputations itself will still be cached via DICE, so no major performance\nissues are expected. However, in the event that a bxl function is\ncomputationally heavy, the recommendation would be to move that to an action, or\nsplit up the bxl and use inter-bxl caching described below."),(0,r.mdx)("h3",{id:"inter-bxl-caching"},"Inter-bxl caching?"),(0,r.mdx)("p",null,'Different bxl can be cacheable between each other if structured as\n"outputs"/artifacts. This is essentially the same behaviour as a bxl requesting\n',(0,r.mdx)("inlineCode",{parentName:"p"},"ctx.build"),", which is cached. Since we have those as hashes on RE, we can track\nproperly and not require storing the values in dice."),(0,r.mdx)("p",null,"i.e."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-python"},'# caching_sample.bxl\nfunc1 = bxl_main(\n   impl = my_func1,\n   args = {\n     "arg1": arg.list(arg.str()),\n   }\n)\n\nmy_func1(ctx):\n  \u2026\n  # do various stuff that might change a lot, but the final result\n  # doesn\u2019t change much\n  ctx.return(some_artifact)\n\nfunc2 = bxl_main(\n  impl = my_func2,\n  ...\n)\n\nmy_func2(ctx):\n  artifact = ctx.bxl(":func1")\n  # now read artifact value\n  # everything below will only be reran if the artifact content changes\n  \u2026\n  # do some expensive stuff\n')))}h.isMDXComponent=!0}}]);