"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[392],{3905:(e,a,t)=>{t.r(a),t.d(a,{MDXContext:()=>s,MDXProvider:()=>u,mdx:()=>f,useMDXComponents:()=>p,withMDXComponents:()=>m});var n=t(67294);function l(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(){return i=Object.assign||function(e){for(var a=1;a<arguments.length;a++){var t=arguments[a];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e},i.apply(this,arguments)}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){l(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function d(e,a){if(null==e)return{};var t,n,l=function(e,a){if(null==e)return{};var t,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(l[t]=e[t]);return l}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=n.createContext({}),m=function(e){return function(a){var t=p(a.components);return n.createElement(e,i({},a,{components:t}))}},p=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):o(o({},a),e)),t},u=function(e){var a=p(e.components);return n.createElement(s.Provider,{value:a},e.children)},c="mdxType",x={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},h=n.forwardRef((function(e,a){var t=e.components,l=e.mdxType,i=e.originalType,r=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),m=p(t),u=l,c=m["".concat(r,".").concat(u)]||m[u]||x[u]||i;return t?n.createElement(c,o(o({ref:a},s),{},{components:t})):n.createElement(c,o({ref:a},s))}));function f(e,a){var t=arguments,l=a&&a.mdxType;if("string"==typeof e||l){var i=t.length,r=new Array(i);r[0]=h;var o={};for(var d in a)hasOwnProperty.call(a,d)&&(o[d]=a[d]);o.originalType=e,o[c]="string"==typeof e?e:l,r[1]=o;for(var s=2;s<i;s++)r[s]=t[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},92235:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var n=t(87462),l=(t(67294),t(3905));const i={id:"globals"},r="globals",o={unversionedId:"api/bxl/globals",id:"api/bxl/globals",title:"globals",description:"Global method for error handling.",source:"@site/../docs/api/bxl/globals.generated.md",sourceDirName:"api/bxl",slug:"/api/bxl/globals",permalink:"/docs/api/bxl/globals",draft:!1,tags:[],version:"current",frontMatter:{id:"globals"},sidebar:"apiSidebar",previous:{title:"target_label type",permalink:"/docs/api/build/target_label"},next:{title:"ActionErrorCtx type",permalink:"/docs/api/bxl/ActionErrorCtx"}},d={},s=[{value:"ActionErrorCtx",id:"actionerrorctx",level:2},{value:"ActionErrorLocation",id:"actionerrorlocation",level:2},{value:"ActionSubError",id:"actionsuberror",level:2},{value:"AnalysisActions",id:"analysisactions",level:2},{value:"AnalysisContext",id:"analysiscontext",level:2},{value:"AnonTarget",id:"anontarget",level:2},{value:"AnonTargets",id:"anontargets",level:2},{value:"Artifact",id:"artifact",level:2},{value:"ArtifactTag",id:"artifacttag",level:2},{value:"ArtifactValue",id:"artifactvalue",level:2},{value:"Attr",id:"attr",level:2},{value:"CellPath",id:"cellpath",level:2},{value:"CellRoot",id:"cellroot",level:2},{value:"CommandExecutorConfig",id:"commandexecutorconfig",level:2},{value:"<code>.type</code> attribute",id:"type-attribute",level:4},{value:"Details",id:"details",level:4},{value:"ConfigurationInfo",id:"configurationinfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-1",level:4},{value:"Details",id:"details-1",level:4},{value:"ConfiguredProvidersLabel",id:"configuredproviderslabel",level:2},{value:"ConfiguredTargetLabel",id:"configuredtargetlabel",level:2},{value:"ConstraintSettingInfo",id:"constraintsettinginfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-2",level:4},{value:"Details",id:"details-2",level:4},{value:"ConstraintValueInfo",id:"constraintvalueinfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-3",level:4},{value:"Details",id:"details-3",level:4},{value:"DefaultInfo",id:"defaultinfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-4",level:4},{value:"Details",id:"details-4",level:4},{value:"Dependency",id:"dependency",level:2},{value:"DynamicActions",id:"dynamicactions",level:2},{value:"DynamicActionsCallable",id:"dynamicactionscallable",level:2},{value:"DynamicValue",id:"dynamicvalue",level:2},{value:"ExecutionPlatformInfo",id:"executionplatforminfo",level:2},{value:"ExecutionPlatformRegistrationInfo",id:"executionplatformregistrationinfo",level:2},{value:"ExternalRunnerTestInfo",id:"externalrunnertestinfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-5",level:4},{value:"Details",id:"details-5",level:4},{value:"InstallInfo",id:"installinfo",level:2},{value:"Label",id:"label",level:2},{value:"LocalResourceInfo",id:"localresourceinfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-6",level:4},{value:"Details",id:"details-6",level:4},{value:"OutputArtifact",id:"outputartifact",level:2},{value:"PlatformInfo",id:"platforminfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-7",level:4},{value:"Details",id:"details-7",level:4},{value:"ProjectRoot",id:"projectroot",level:2},{value:"Promise",id:"promise",level:2},{value:"Provider",id:"provider",level:2},{value:"ProviderCollection",id:"providercollection",level:2},{value:"ProvidersLabel",id:"providerslabel",level:2},{value:"ResolvedDynamicValue",id:"resolveddynamicvalue",level:2},{value:"ResolvedStringWithMacros",id:"resolvedstringwithmacros",level:2},{value:"RunInfo",id:"runinfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-8",level:4},{value:"Details",id:"details-8",level:4},{value:"Select",id:"select",level:2},{value:"TargetLabel",id:"targetlabel",level:2},{value:"TemplatePlaceholderInfo",id:"templateplaceholderinfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-9",level:4},{value:"Details",id:"details-9",level:4},{value:"TransitiveSet",id:"transitiveset",level:2},{value:"TransitiveSetArgsProjection",id:"transitivesetargsprojection",level:2},{value:"TransitiveSetArgsProjectionIterator",id:"transitivesetargsprojectioniterator",level:2},{value:"TransitiveSetDefinition",id:"transitivesetdefinition",level:2},{value:"TransitiveSetIterator",id:"transitivesetiterator",level:2},{value:"TransitiveSetJsonProjection",id:"transitivesetjsonprojection",level:2},{value:"ValidationInfo",id:"validationinfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-10",level:4},{value:"Details",id:"details-10",level:4},{value:"ValidationSpec",id:"validationspec",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-11",level:4},{value:"WorkerInfo",id:"workerinfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-12",level:4},{value:"Details",id:"details-11",level:4},{value:"WorkerRunInfo",id:"workerruninfo",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-13",level:4},{value:"Details",id:"details-12",level:4},{value:"anon_rule",id:"anon_rule",level:2},{value:"attrs",id:"attrs",level:2},{value:"bxl",id:"bxl",level:2},{value:"bxl_main",id:"bxl_main",level:2},{value:"cli_args",id:"cli_args",level:2},{value:"cmd_args",id:"cmd_args",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-14",level:4},{value:"Details",id:"details-13",level:4},{value:"<code>ignore_artifacts</code>",id:"ignore_artifacts",level:2},{value:"<code>hidden</code>",id:"hidden",level:2},{value:"<code>absolute_prefix</code> and <code>absolute_suffix</code>",id:"absolute_prefix-and-absolute_suffix",level:2},{value:"ctarget_set",id:"ctarget_set",level:2},{value:"dedupe",id:"dedupe",level:2},{value:"dynamic_actions",id:"dynamic_actions",level:2},{value:"fail_no_stacktrace",id:"fail_no_stacktrace",level:2},{value:"file_set",id:"file_set",level:2},{value:"get_base_path",id:"get_base_path",level:2},{value:"get_cell_name",id:"get_cell_name",level:2},{value:"get_path_without_materialization",id:"get_path_without_materialization",level:2},{value:"get_paths_without_materialization",id:"get_paths_without_materialization",level:2},{value:"glob",id:"glob",level:2},{value:"host_info",id:"host_info",level:2},{value:"implicit_package_symbol",id:"implicit_package_symbol",level:2},{value:"load_symbols",id:"load_symbols",level:2},{value:"now",id:"now",level:2},{value:"oncall",id:"oncall",level:2},{value:"package",id:"package",level:2},{value:"package_name",id:"package_name",level:2},{value:"plugins",id:"plugins",level:2},{value:"provider",id:"provider-1",level:2},{value:"provider_field",id:"provider_field",level:2},{value:"read_config",id:"read_config",level:2},{value:"read_oncall",id:"read_oncall",level:2},{value:"read_package_value",id:"read_package_value",level:2},{value:"read_parent_package_value",id:"read_parent_package_value",level:2},{value:"read_root_config",id:"read_root_config",level:2},{value:"regex",id:"regex",level:2},{value:"<code>.type</code> attribute",id:"type-attribute-15",level:4},{value:"regex_match",id:"regex_match",level:2},{value:"repository_name",id:"repository_name",level:2},{value:"rule",id:"rule",level:2},{value:"rule_exists",id:"rule_exists",level:2},{value:"select",id:"select-1",level:2},{value:"select_equal_internal",id:"select_equal_internal",level:2},{value:"select_map",id:"select_map",level:2},{value:"select_test",id:"select_test",level:2},{value:"set_cfg_constructor",id:"set_cfg_constructor",level:2},{value:"set_starlark_peak_allocated_byte_limit",id:"set_starlark_peak_allocated_byte_limit",level:2},{value:"sha256",id:"sha256",level:2},{value:"soft_error",id:"soft_error",level:2},{value:"transition",id:"transition",level:2},{value:"transitive_set",id:"transitive_set",level:2},{value:"utarget_set",id:"utarget_set",level:2},{value:"warning",id:"warning",level:2},{value:"write_package_value",id:"write_package_value",level:2}],m={toc:s};function p(e){let{components:a,...t}=e;return(0,l.mdx)("wrapper",(0,n.Z)({},m,t,{components:a,mdxType:"MDXLayout"}),(0,l.mdx)("h1",{id:"globals"},"globals"),(0,l.mdx)("p",null,"Global method for error handling."),(0,l.mdx)("h2",{id:"actionerrorctx"},"ActionErrorCtx"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ActionErrorCtx: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"actionerrorlocation"},"ActionErrorLocation"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ActionErrorLocation: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"actionsuberror"},"ActionSubError"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ActionSubError: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"analysisactions"},"AnalysisActions"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"AnalysisActions: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"analysiscontext"},"AnalysisContext"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"AnalysisContext: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"anontarget"},"AnonTarget"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"AnonTarget: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"anontargets"},"AnonTargets"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"AnonTargets: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"artifact"},"Artifact"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"Artifact: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"artifacttag"},"ArtifactTag"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ArtifactTag: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"artifactvalue"},"ArtifactValue"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ArtifactValue: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"attr"},"Attr"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"Attr: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"cellpath"},"CellPath"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"CellPath: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"cellroot"},"CellRoot"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"CellRoot: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"commandexecutorconfig"},"CommandExecutorConfig"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def CommandExecutorConfig(\n    *,\n    local_enabled: bool,\n    remote_enabled: bool,\n    remote_cache_enabled: None | bool = None,\n    remote_dep_file_cache_enabled: bool = False,\n    remote_execution_properties = None,\n    remote_execution_action_key = None,\n    remote_execution_max_input_files_mebibytes: None | int = None,\n    remote_execution_queue_time_threshold_s: None | int = None,\n    remote_execution_use_case = None,\n    use_limited_hybrid: bool = False,\n    allow_limited_hybrid_fallbacks: bool = False,\n    allow_hybrid_fallbacks_on_failure: bool = False,\n    use_windows_path_separators: bool = False,\n    use_persistent_workers: bool = False,\n    allow_cache_uploads: bool = False,\n    max_cache_upload_mebibytes: None | int = None,\n    experimental_low_pass_filter: bool = False,\n    remote_output_paths: None | str = None,\n    remote_execution_resource_units: None | int = None,\n    remote_execution_dependencies: list[dict[str, str]] = []\n) -> command_executor_config\n")),(0,l.mdx)("p",null,"Contains configurations for how actions should be executed"),(0,l.mdx)("h4",{id:"type-attribute"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"command_executor_config"')),(0,l.mdx)("h4",{id:"details"},"Details"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"local_enabled")," : Whether to use local execution for this execution platform.\nIf both remote_enabled and local_enabled are ",(0,l.mdx)("inlineCode",{parentName:"li"},"True"),", we will use the hybrid executor"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"remote_enabled"),": Whether to use remote execution for this execution platform"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"remote_cache_enabled"),": Whether to query RE caches"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"remote_execution_properties"),": Properties for remote execution for this platform"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"remote_execution_action_key"),": A component to inject into the action key\nThis should typically used to inject variability into the action key so that\nit's different across e.g. build modes (RE uses the action key for things like expected memory utilization)"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"remote_execution_max_input_files_mebibytes"),": The maximum input file size (in bytes) that remote execution can support"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"remote_execution_queue_time_threshold_s"),": The maximum time in seconds we are willing to wait\nin the RE queue for remote execution to start running our action"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"remote_execution_use_case"),": The use case to use when communicating with RE"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"use_limited_hybrid"),": Whether to use the limited hybrid executor"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"allow_limited_hybrid_fallbacks"),": Whether to allow fallbacks"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"allow_hybrid_fallbacks_on_failure"),": Whether to allow fallbacks when the result is failure (i.e. the command failed on the primary, but the infra worked)"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"use_windows_path_separators"),": Whether to use Windows path separators in command line arguments"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"use_persistent workers"),": Whether to use persistent workers for local execution if they are available"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"allow_cache_uploads"),": Whether to upload local actions to the RE cache"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"max_cache_upload_mebibytes"),": Maximum size to upload in cache uploads"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"experimental_low_pass_filter"),": Whether to use the experimental low pass filter"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"remote_output_paths"),": How to express output paths to RE"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"remote_execution_resource_units"),": The resources (eg. GPUs) to use for remote execution"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"remote_execution_dependencies"),": Dependencies for remote execution for this platform")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"configurationinfo"},"ConfigurationInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def ConfigurationInfo(\n    *,\n    constraints: dict[target_label, ConstraintValueInfo],\n    values: dict[str, str]\n) -> ConfigurationInfo\n")),(0,l.mdx)("p",null,"Provider that signals that a rule contains configuration info. This is used both as part of defining configurations (",(0,l.mdx)("inlineCode",{parentName:"p"},"platform()"),", ",(0,l.mdx)("inlineCode",{parentName:"p"},"constraint_value()"),') and defining whether a target "matches" a configuration or not (',(0,l.mdx)("inlineCode",{parentName:"p"},"config_setting()"),", ",(0,l.mdx)("inlineCode",{parentName:"p"},"constraint_value()"),")"),(0,l.mdx)("h4",{id:"type-attribute-1"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"ConfigurationInfo"')),(0,l.mdx)("h4",{id:"details-1"},"Details"),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"constraints: dict[target_label, ConstraintValueInfo]")," - field")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"values: dict[str, str]")," - field"))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"configuredproviderslabel"},"ConfiguredProvidersLabel"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ConfiguredProvidersLabel: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"configuredtargetlabel"},"ConfiguredTargetLabel"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ConfiguredTargetLabel: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"constraintsettinginfo"},"ConstraintSettingInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def ConstraintSettingInfo(*, label: target_label) -> ConstraintSettingInfo\n")),(0,l.mdx)("p",null,"Provider that signals that a target can be used as a constraint key. This is the only provider returned by a ",(0,l.mdx)("inlineCode",{parentName:"p"},"constraint_setting()")," target."),(0,l.mdx)("h4",{id:"type-attribute-2"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"ConstraintSettingInfo"')),(0,l.mdx)("h4",{id:"details-2"},"Details"),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"label: target_label")," - field")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"constraintvalueinfo"},"ConstraintValueInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def ConstraintValueInfo(\n    *,\n    setting: ConstraintSettingInfo,\n    label: target_label\n) -> ConstraintValueInfo\n")),(0,l.mdx)("p",null,"Provider that signals that a target can be used as a constraint key. This is the only provider returned by a ",(0,l.mdx)("inlineCode",{parentName:"p"},"constraint_value()")," target."),(0,l.mdx)("h4",{id:"type-attribute-3"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"ConstraintValueInfo"')),(0,l.mdx)("h4",{id:"details-3"},"Details"),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"setting: ConstraintSettingInfo")," - field")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"label: target_label")," - field"))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"defaultinfo"},"DefaultInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def DefaultInfo(\n    default_output: None | artifact = None,\n    default_outputs: None | list[artifact] = None,\n    other_outputs: list[artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | RunInfo] = _,\n    sub_targets: dict[str, typing.Any] = _\n) -> DefaultInfo\n")),(0,l.mdx)("p",null,"A provider that all rules' implementations must return"),(0,l.mdx)("h4",{id:"type-attribute-4"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"DefaultInfo"')),(0,l.mdx)("h4",{id:"details-4"},"Details"),(0,l.mdx)("p",null,"In many simple cases, this can be inferred for the user."),(0,l.mdx)("p",null,"Example of a rule's implementation function and how these fields are used by the framework:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-starlark"},'# //foo_binary.bzl\ndef impl(ctx):\n    ctx.action.run([ctx.attrs._cc[RunInfo], "-o", ctx.attrs.out.as_output()] + ctx.attrs.srcs)\n    ctx.action.run([\n        ctx.attrs._strip[RunInfo],\n        "--binary",\n        ctx.attrs.out,\n        "--stripped-out",\n        ctx.attrs.stripped.as_output(),\n        "--debug-symbols-out",\n        ctx.attrs.debug_info.as_output(),\n    ])\n    return [\n        DefaultInfo(\n            sub_targets = {\n                "stripped": [\n                    DefaultInfo(default_outputs = [ctx.attrs.stripped, ctx.attrs.debug_info]),\n                ],\n            },\n            default_output = ctx.attrs.out,\n    ]\n\nfoo_binary = rule(\n    impl=impl,\n    attrs={\n        "srcs": attrs.list(attrs.source()),\n        "out": attrs.output(),\n        "stripped": attrs.output(),\n        "debug_info": attrs.output(),\n        "_cc": attrs.dep(default="//tools:cc", providers=[RunInfo]),\n        "_strip_script": attrs.dep(default="//tools:strip", providers=[RunInfo])\n)\n\ndef foo_binary_wrapper(name, srcs):\n    foo_binary(\n        name = name,\n        srcs = src,\n        out = name,\n        stripped = name + ".stripped",\n        debug_info = name + ".debug_info",\n    )\n\n# //subdir/BUCK\nload("//:foo_binary.bzl", "foo_binary_wrapper")\n\ngenrule(name = "gen_stuff", ...., default_outs = ["foo.cpp"])\n\n# ":gen_stuff" pulls the default_outputs for //subdir:gen_stuff\nfoo_binary_wrapper(name = "foo", srcs = glob(["*.cpp"]) + [":gen_stuff"])\n\n# Builds just \'foo\' binary. The strip command is never invoked.\n$ buck build //subdir:foo\n\n# builds the \'foo\' binary, because it is needed by the \'strip\' command. Ensures that\n# both the stripped binary and the debug symbols are built.\n$ buck build //subdir:foo[stripped]\n')),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"sub_targets: dict[str, provider_collection]")," - A mapping of names to ",(0,l.mdx)("inlineCode",{parentName:"p"},"ProviderCollection"),"s. The keys are used when resolving the ",(0,l.mdx)("inlineCode",{parentName:"p"},"ProviderName")," portion of a ",(0,l.mdx)("inlineCode",{parentName:"p"},"ProvidersLabel")," in order to access the providers for a subtarget, such as when doing ",(0,l.mdx)("inlineCode",{parentName:"p"},"buck2 build cell//foo:bar[baz]"),". Just like any ",(0,l.mdx)("inlineCode",{parentName:"p"},"ProviderCollection"),", this collection must include at least a ",(0,l.mdx)("inlineCode",{parentName:"p"},"DefaultInfo")," provider. The subtargets can have their own subtargets as well, which can be accessed by chaining them, e.g.: ",(0,l.mdx)("inlineCode",{parentName:"p"},"buck2 build cell//foo:bar[baz][qux]"),".")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"default_outputs: list[artifact]")," - A list of ",(0,l.mdx)("inlineCode",{parentName:"p"},"Artifact"),"s that are built by default if this rule is requested explicitly (via CLI or ",(0,l.mdx)("inlineCode",{parentName:"p"},"$(location)"),' etc), or depended on as as a "source" (i.e., ',(0,l.mdx)("inlineCode",{parentName:"p"},"attrs.source()"),").")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"other_outputs: list[artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | RunInfo]")," - A list of ",(0,l.mdx)("inlineCode",{parentName:"p"},"ArtifactTraversable"),". The underlying ",(0,l.mdx)("inlineCode",{parentName:"p"},"Artifact"),"s they define will be built by default if this rule is requested (via CLI or ",(0,l.mdx)("inlineCode",{parentName:"p"},"$(location)")," etc), but ",(0,l.mdx)("em",{parentName:"p"},"not"),' when it\'s depended on as as a "source" (i.e., ',(0,l.mdx)("inlineCode",{parentName:"p"},"attrs.source()"),"). ",(0,l.mdx)("inlineCode",{parentName:"p"},"ArtifactTraversable")," can be an ",(0,l.mdx)("inlineCode",{parentName:"p"},"Artifact")," (which yields itself), or ",(0,l.mdx)("inlineCode",{parentName:"p"},"cmd_args"),", which expand to all their inputs."))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"dependency"},"Dependency"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"Dependency: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"dynamicactions"},"DynamicActions"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"DynamicActions: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"dynamicactionscallable"},"DynamicActionsCallable"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"DynamicActionsCallable: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"dynamicvalue"},"DynamicValue"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"DynamicValue: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"executionplatforminfo"},"ExecutionPlatformInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def ExecutionPlatformInfo(\n    *,\n    label: target_label,\n    configuration: ConfigurationInfo,\n    executor_config: command_executor_config\n) -> ExecutionPlatformInfo\n")),(0,l.mdx)("p",null,"Provider that signals that a target represents an execution platform."),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"label: target_label")," - label of the defining rule, used in informative messages")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"configuration: ConfigurationInfo")," - The configuration of the execution platform")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"executor_config: command_executor_config")," - The executor config"))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"executionplatformregistrationinfo"},"ExecutionPlatformRegistrationInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def ExecutionPlatformRegistrationInfo(\n    *,\n    platforms: list[ExecutionPlatformInfo],\n    fallback = None\n) -> ExecutionPlatformRegistrationInfo\n")),(0,l.mdx)("p",null,"Provider that gives the list of all execution platforms available for this build."),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"platforms: list[ExecutionPlatformInfo]")," - field")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"fallback: typing.Any")," - field"))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"externalrunnertestinfo"},"ExternalRunnerTestInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def ExternalRunnerTestInfo(\n    type,\n    command = None,\n    env = None,\n    labels = None,\n    contacts = None,\n    use_project_relative_paths = None,\n    run_from_project_root = None,\n    default_executor = None,\n    executor_overrides = None,\n    local_resources = None,\n    worker = None\n) -> ExternalRunnerTestInfo\n")),(0,l.mdx)("p",null,"Provider that signals that a rule can be tested using an external runner. This is the Buck1-compatible API for tests."),(0,l.mdx)("h4",{id:"type-attribute-5"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"ExternalRunnerTestInfo"')),(0,l.mdx)("h4",{id:"details-5"},"Details"),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"test_type: str")," - A Starlark value representing the type of this test.")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"command: list[typing.Any]")," - A Starlark value representing the command for this test. The external test runner is what gives meaning to this command.")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"env: dict[str, typing.Any]")," - A Starlark value representing the environment for this test. Here again, the external test runner is what will this meaning. This is of type ",(0,l.mdx)("inlineCode",{parentName:"p"},"dict[str, ArgLike]"),".")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"labels: list[str]")," - A starlark value representing the labels for this test.")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"contacts: list[str]")," - A starlark value representing the contacts for this test. This is largely expected to be an oncall, though it's not validated in any way.")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"use_project_relative_paths: bool")," - Whether this test should use relative paths")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"run_from_project_root: bool")," - Whether this test should run from the project root, as opposed to the cell rootDefaults to ",(0,l.mdx)("inlineCode",{parentName:"p"},"True"),".")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"default_executor: command_executor_config")," - Default executor to use to run tests. If none is passed we will default to the execution platform.")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"executor_overrides: dict[str, command_executor_config]")," - Executors that Tpx can use to override the default executor.")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"local_resources: dict[str, None | label]")," - Mapping from a local resource type to a target with a corresponding provider. Required types are passed from test runner. If the value for a corresponding type is omitted it means local resource should be ignored when executing tests even if those are passed as required from test runner.")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"worker: WorkerInfo")," - Configuration needed to spawn a new worker. This worker will be used to run every single command related to test execution, including listing."))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"installinfo"},"InstallInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def InstallInfo(installer: label, files: dict[str, artifact]) -> InstallInfo\n")),(0,l.mdx)("p",null,"A provider that can be constructed and have its fields accessed. Returned by rules."),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"installer: label")," - field")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"files: dict[str, artifact]")," - field"))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"label"},"Label"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"Label: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"localresourceinfo"},"LocalResourceInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def LocalResourceInfo(\n    *,\n    setup: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo,\n    resource_env_vars: dict[str, str],\n    setup_timeout_seconds: None | float | int = None\n) -> LocalResourceInfo\n")),(0,l.mdx)("p",null,"A provider that can be constructed and have its fields accessed. Returned by rules."),(0,l.mdx)("h4",{id:"type-attribute-6"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"LocalResourceInfo"')),(0,l.mdx)("h4",{id:"details-6"},"Details"),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"setup: cmd_args"),' - Command to run to initialize a local resource. Running this command writes a JSON to stdout. This JSON represents a pool of local resources which are ready to be used. Example JSON would be: { "pid": 42, "resources": ','[ {"socket_address": "foo:1"}, {"socket_address": "bar:2"} ]',' } Where \'"pid"',(0,l.mdx)("inlineCode",{parentName:"p"},"maps to a PID of a process which should be sent SIGTERM to release the pool of resources when they are no longer needed."),'"resources"',(0,l.mdx)("inlineCode",{parentName:"p"},"maps to the pool of resources. When a local resource from this particular pool is needed for an execution command, single entity will be reserved from the pool, for example"),'{"socket_address": "bar:2"}',(0,l.mdx)("inlineCode",{parentName:"p"},"and environment variable with name resolved using mapping in"),"resource_env_vars",(0,l.mdx)("inlineCode",{parentName:"p"},"field and"),'"socket_address"` key will be added to execution command.')),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"resource_env_vars: dict[str, str]")," - Mapping from environment variable (appended to an execution command which is dependent on this local resource) to keys in setup command JSON output.")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"setup_timeout_seconds: None | float | int")," - Timeout in seconds for ",(0,l.mdx)("inlineCode",{parentName:"p"},"setup")," command."))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"outputartifact"},"OutputArtifact"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"OutputArtifact: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"platforminfo"},"PlatformInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def PlatformInfo(\n    *,\n    label: str,\n    configuration: ConfigurationInfo\n) -> PlatformInfo\n")),(0,l.mdx)("p",null,"A provider that can be constructed and have its fields accessed. Returned by rules."),(0,l.mdx)("h4",{id:"type-attribute-7"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"PlatformInfo"')),(0,l.mdx)("h4",{id:"details-7"},"Details"),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"label: str")," - field")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"configuration: ConfigurationInfo")," - field"))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"projectroot"},"ProjectRoot"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ProjectRoot: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"promise"},"Promise"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"Promise: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"provider"},"Provider"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"Provider: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"providercollection"},"ProviderCollection"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ProviderCollection: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"providerslabel"},"ProvidersLabel"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ProvidersLabel: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"resolveddynamicvalue"},"ResolvedDynamicValue"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ResolvedDynamicValue: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"resolvedstringwithmacros"},"ResolvedStringWithMacros"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"ResolvedStringWithMacros: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"runinfo"},"RunInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def RunInfo(\n    args: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo = _\n) -> RunInfo\n")),(0,l.mdx)("p",null,"Provider that signals that a rule is runnable"),(0,l.mdx)("h4",{id:"type-attribute-8"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"RunInfo"')),(0,l.mdx)("h4",{id:"details-8"},"Details"),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"args: cmd_args")," - The command to run, stored as CommandLine")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"select"},"Select"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"Select: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"targetlabel"},"TargetLabel"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"TargetLabel: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"templateplaceholderinfo"},"TemplatePlaceholderInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def TemplatePlaceholderInfo(\n    unkeyed_variables = {},\n    keyed_variables = {}\n) -> TemplatePlaceholderInfo\n")),(0,l.mdx)("p",null,"A provider that is used for expansions in string attribute templates"),(0,l.mdx)("h4",{id:"type-attribute-9"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"TemplatePlaceholderInfo"')),(0,l.mdx)("h4",{id:"details-9"},"Details"),(0,l.mdx)("p",null,'String attribute templates allow two types of user-defined placeholders, "unkeyed placeholders"\nlike ',(0,l.mdx)("inlineCode",{parentName:"p"},"$(CXX)")," or ",(0,l.mdx)("inlineCode",{parentName:"p"},"$(aapt)"),' and "keyed placeholders"  that include a target key like\n',(0,l.mdx)("inlineCode",{parentName:"p"},"$(cxxppflags //some:target)"),". The expansion of each of these types is based on the\n",(0,l.mdx)("inlineCode",{parentName:"p"},"TemplatePlaceholderInfo")," providers."),(0,l.mdx)("p",null,'"keyed placeholders" are used for the form ',(0,l.mdx)("inlineCode",{parentName:"p"},"$(<key> <target>)")," or ",(0,l.mdx)("inlineCode",{parentName:"p"},"$(<key> <target> <arg>)"),". In both cases\nthe lookup will expect a ",(0,l.mdx)("inlineCode",{parentName:"p"},"TemplatePlaceholderInfo")," in the providers of ",(0,l.mdx)("inlineCode",{parentName:"p"},"<target>"),". It will then lookup\n",(0,l.mdx)("inlineCode",{parentName:"p"},"<key>")," in the keyed_variables (call this the ",(0,l.mdx)("inlineCode",{parentName:"p"},"value"),"). There are then four valid possibilities:"),(0,l.mdx)("ol",null,(0,l.mdx)("li",{parentName:"ol"},"no-arg placeholder, an arg-like ",(0,l.mdx)("inlineCode",{parentName:"li"},"value"),": resolve to ",(0,l.mdx)("inlineCode",{parentName:"li"},"value")),(0,l.mdx)("li",{parentName:"ol"},"no-arg placeholder, a dictionary ",(0,l.mdx)("inlineCode",{parentName:"li"},"value"),": resolve to ",(0,l.mdx)("inlineCode",{parentName:"li"},'value["DEFAULT"]')),(0,l.mdx)("li",{parentName:"ol"},"arg placeholder, a non-dictionary ",(0,l.mdx)("inlineCode",{parentName:"li"},"value"),": this is an error"),(0,l.mdx)("li",{parentName:"ol"},"arg placeholder, a dictionary ",(0,l.mdx)("inlineCode",{parentName:"li"},"value"),": resolve to ",(0,l.mdx)("inlineCode",{parentName:"li"},"value[<arg>]"))),(0,l.mdx)("p",null,'"unkeyed placeholders" are resolved by matching to any of the deps of the target. ',(0,l.mdx)("inlineCode",{parentName:"p"},"$(CXX)"),' will resolve\nto the "CXX" value in any dep\'s ',(0,l.mdx)("inlineCode",{parentName:"p"},"TemplateProviderInfo.unkeyed_variables")),(0,l.mdx)("p",null,"Fields:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},'unkeyed_variables: A mapping of names to arg-like values. These are used for "unkeyed placeholder" expansion.'),(0,l.mdx)("li",{parentName:"ul"},'keyed_variables: A mapping of names to arg-like values or dictionary of string to\narg-like values. These are used for "keyed placeholder" expansion.')),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"unkeyed_variables: dict[str, typing.Any]")," - field")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"keyed_variables: dict[str, typing.Any]")," - field"))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"transitiveset"},"TransitiveSet"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"TransitiveSet: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"transitivesetargsprojection"},"TransitiveSetArgsProjection"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"TransitiveSetArgsProjection: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"transitivesetargsprojectioniterator"},"TransitiveSetArgsProjectionIterator"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"TransitiveSetArgsProjectionIterator: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"transitivesetdefinition"},"TransitiveSetDefinition"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"TransitiveSetDefinition: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"transitivesetiterator"},"TransitiveSetIterator"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"TransitiveSetIterator: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"transitivesetjsonprojection"},"TransitiveSetJsonProjection"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"TransitiveSetJsonProjection: type\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"validationinfo"},"ValidationInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def ValidationInfo(*, validations: list[ValidationSpec]) -> ValidationInfo\n")),(0,l.mdx)("p",null,"Provider describing how a given target node should be validated. Validations are run when target with ",(0,l.mdx)("inlineCode",{parentName:"p"},"ValidationInfo")," provider is a transitive dependency of a requested target."),(0,l.mdx)("h4",{id:"type-attribute-10"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"ValidationInfo"')),(0,l.mdx)("h4",{id:"details-10"},"Details"),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"validations: list[ValidationSpec]")," - List of ",(0,l.mdx)("inlineCode",{parentName:"li"},"ValidationSpec")," values each representing a single validation.")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"validationspec"},"ValidationSpec"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def ValidationSpec(\n    *,\n    name: str,\n    validation_result: artifact,\n    optional: bool = False\n) -> ValidationSpec\n")),(0,l.mdx)("h4",{id:"type-attribute-11"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"ValidationSpec"')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"workerinfo"},"WorkerInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def WorkerInfo(exe = [], *, concurrency: None | int = None) -> WorkerInfo\n")),(0,l.mdx)("p",null,"Provider that signals that a rule is a worker tool"),(0,l.mdx)("h4",{id:"type-attribute-12"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"WorkerInfo"')),(0,l.mdx)("h4",{id:"details-11"},"Details"),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"exe: cmd_args")," - field")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"concurrency: None | int")," - field"))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"workerruninfo"},"WorkerRunInfo"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def WorkerRunInfo(*, worker: WorkerInfo, exe = []) -> WorkerRunInfo\n")),(0,l.mdx)("p",null,"Provider that signals that a rule can run using a worker"),(0,l.mdx)("h4",{id:"type-attribute-13"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"WorkerRunInfo"')),(0,l.mdx)("h4",{id:"details-12"},"Details"),(0,l.mdx)("p",null,"Provides a number of fields that can be accessed:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"worker: WorkerInfo")," - field")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("p",{parentName:"li"},(0,l.mdx)("inlineCode",{parentName:"p"},"exe: cmd_args")," - field"))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"anon_rule"},"anon","_","rule"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def anon_rule(\n    *,\n    impl: typing.Callable[[typing.Any], list[typing.Any]],\n    attrs: dict[str, attribute],\n    doc: str = "",\n    artifact_promise_mappings: dict[str, typing.Callable[[typing.Any], list[typing.Any]]]\n) -> "function"\n')),(0,l.mdx)("p",null,"Define an anon rule, similar to how a normal rule is defined, except with an extra ",(0,l.mdx)("inlineCode",{parentName:"p"},"artifact_promise_mappings")," field. This is a dict where the keys are the string name of the artifact, and the values are the callable functions that produce the artifact. This is only intended to be used with anon targets."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"attrs"},"attrs"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"attrs: attrs\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl"},"bxl"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'bxl: struct(ActionQueryNode = type, Actions = type, AnalysisResult = type, AqueryContext = type, AuditContext = type, BuildResult = type, CliArgs = type, ConfiguredTargetNode = type, ConfiguredTargetSet = type, Context = type, CqueryContext = type, EnsuredArtifact = type, FileNode = type, Filesystem = type, LazyResolvedAttrs = type, OutputStream = type, TargetUniverse = type, UnconfiguredTargetNode = type, UnconfiguredTargetSet = type, UqueryContext = type, cli_args = struct(bool = "function", enum = "function", float = "function", int = "function", json = "function", list = "function", option = "function", string = "function", sub_target = "function", sub_target_expr = "function", target_expr = "function", target_label = "function"), ctarget_set = "function", fail_no_stacktrace = "function", file_set = "function", get_path_without_materialization = "function", get_paths_without_materialization = "function", now = "function", utarget_set = "function")\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxl_main"},"bxl","_","main"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def bxl_main(\n    *,\n    impl: typing.Callable,\n    cli_args: dict[str, bxl.CliArgs],\n    doc: str = ""\n)\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"cli_args"},"cli","_","args"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'cli_args: struct(bool = "function", enum = "function", float = "function", int = "function", json = "function", list = "function", option = "function", string = "function", sub_target = "function", sub_target_expr = "function", target_expr = "function", target_label = "function")\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"cmd_args"},"cmd","_","args"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def cmd_args(\n    *args: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo,\n    hidden: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo = _,\n    delimiter: str = _,\n    format: str = _,\n    prepend: str = _,\n    quote: str = _,\n    ignore_artifacts: bool = False,\n    absolute_prefix: str = _,\n    absolute_suffix: str = _,\n    parent: int = 0,\n    relative_to: artifact | cell_root | project_root | (artifact | cell_root | project_root, int) = _,\n    replace_regex: list[(buck_regex | str, str)] | (buck_regex | str, str) = _\n) -> cmd_args\n")),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"cmd_args")," type is created by this function and is consumed by ",(0,l.mdx)("inlineCode",{parentName:"p"},"ctx.actions.run"),". The type is a mutable collection of strings and artifact values. In general, command lines, artifacts, strings, ",(0,l.mdx)("inlineCode",{parentName:"p"},"RunInfo")," and lists thereof can be added to or used to construct a ",(0,l.mdx)("inlineCode",{parentName:"p"},"cmd_args")," value."),(0,l.mdx)("h4",{id:"type-attribute-14"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"cmd_args"')),(0,l.mdx)("h4",{id:"details-13"},"Details"),(0,l.mdx)("p",null,"The arguments are:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"*args")," - a list of things to add to the command line, each of which must be coercible to a command line. Further items can be added with ",(0,l.mdx)("inlineCode",{parentName:"li"},"cmd.add"),"."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"format")," - a string that provides a format to apply to the argument. for example, ",(0,l.mdx)("inlineCode",{parentName:"li"},'cmd_args(x, format="--args={}")')," would prepend ",(0,l.mdx)("inlineCode",{parentName:"li"},"--args=")," before ",(0,l.mdx)("inlineCode",{parentName:"li"},"x"),", or if ",(0,l.mdx)("inlineCode",{parentName:"li"},"x")," was a list, before each element in ",(0,l.mdx)("inlineCode",{parentName:"li"},"x"),"."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"delimiter")," - added between arguments to join them together. For example, ",(0,l.mdx)("inlineCode",{parentName:"li"},'cmd_args(["--args=",x], delimiter="")')," would produce a single argument to the underlying tool."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"prepend")," - added as a separate argument before each argument."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"quote")," - indicates whether quoting is to be applied to each argument. The only current valid value is ",(0,l.mdx)("inlineCode",{parentName:"li"},'"shell"'),"."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"ignore_artifacts")," - if ",(0,l.mdx)("inlineCode",{parentName:"li"},"True"),", artifacts paths are used, but artifacts are not pulled."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"hidden")," - artifacts not present on the command line, but added as dependencies."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"absolute_prefix")," and ",(0,l.mdx)("inlineCode",{parentName:"li"},"absolute_suffix")," - added to the start and end of each artifact."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"parent")," - for all the artifacts use their ",(0,l.mdx)("inlineCode",{parentName:"li"},"parent"),"th directory (e.g. ",(0,l.mdx)("inlineCode",{parentName:"li"},"parent = 1")," for the directory the artifact is located, ",(0,l.mdx)("inlineCode",{parentName:"li"},"parent = 2")," for that directory's parent, etc.)."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"relative_to")," - make all artifact paths relative to a given location."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"replace_regex")," - replaces arguments with a regular expression.")),(0,l.mdx)("h2",{id:"ignore_artifacts"},(0,l.mdx)("inlineCode",{parentName:"h2"},"ignore_artifacts")),(0,l.mdx)("p",null,(0,l.mdx)("inlineCode",{parentName:"p"},"ignore_artifacts=True")," makes ",(0,l.mdx)("inlineCode",{parentName:"p"},"cmd_args")," to have no declared dependencies.\nAllows you to reference the path of an artifact ",(0,l.mdx)("em",{parentName:"p"},"without")," introducing dependencies on it."),(0,l.mdx)("p",null,"As an example where this can be useful, consider passing a dependency that is only accessed at runtime, but whose path\nmust be baked into the binary. As an example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'resources = cmd_args(resource_file, format = "-DFOO={}").ignore_artifacts()\nctx.actions.run(cmd_args("gcc", "-c", source_file, resources))\n')),(0,l.mdx)("p",null,"Note that ",(0,l.mdx)("inlineCode",{parentName:"p"},"ignore_artifacts")," sets all artifacts referenced by this ",(0,l.mdx)("inlineCode",{parentName:"p"},"cmd_args")," to be ignored, including those added afterwards,\nso generally create a special ",(0,l.mdx)("inlineCode",{parentName:"p"},"cmd_args")," and scope it quite tightly."),(0,l.mdx)("p",null,"If you actually do use the inputs referenced by this command,\nyou will either error out due to missing dependencies (if running actions remotely)\nor have untracked dependencies that will fail to rebuild when it should."),(0,l.mdx)("h2",{id:"hidden"},(0,l.mdx)("inlineCode",{parentName:"h2"},"hidden")),(0,l.mdx)("p",null,"Things to add to the command line which do not show up but are added as dependencies.\nThe values can be anything normally permissible to pass to ",(0,l.mdx)("inlineCode",{parentName:"p"},"add"),"."),(0,l.mdx)("p",null,"Typically used if the command you are running implicitly depends on files that are not\npassed on the command line, e.g. headers in the case of a C compilation."),(0,l.mdx)("h2",{id:"absolute_prefix-and-absolute_suffix"},(0,l.mdx)("inlineCode",{parentName:"h2"},"absolute_prefix")," and ",(0,l.mdx)("inlineCode",{parentName:"h2"},"absolute_suffix")),(0,l.mdx)("p",null,"Adds a prefix to the start or end of every artifact."),(0,l.mdx)("p",null,"Prefix is often used if you have a ",(0,l.mdx)("inlineCode",{parentName:"p"},"$ROOT")," variable\nin a shell script and want to use it to make files absolute."),(0,l.mdx)("p",null,"Suffix is often used in conjunction with ",(0,l.mdx)("inlineCode",{parentName:"p"},"absolute_prefix"),"\nto wrap artifacts in function calls."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'cmd_args(script, absolute_prefix = "$ROOT/")\ncmd_args(script, absolute_prefix = "call", absolute_suffix = ")")\n')),(0,l.mdx)("h1",{id:"parent"},"`parent"),(0,l.mdx)("p",null,"`\nFor all the artifacts use their parent directory."),(0,l.mdx)("p",null,"Typically used when the file name is passed one way, and the directory another,\ne.g. ",(0,l.mdx)("inlineCode",{parentName:"p"},'cmd_args(artifact, format="-L{}", parent=1)'),"."),(0,l.mdx)("h1",{id:"relative_todir-or-relative_todir-parent"},(0,l.mdx)("inlineCode",{parentName:"h1"},"relative_to=dir")," or ",(0,l.mdx)("inlineCode",{parentName:"h1"},"relative_to=(dir, parent)")),(0,l.mdx)("p",null,"Make all artifact paths relative to a given location. Typically used when the command\nyou are running changes directory."),(0,l.mdx)("p",null,"By default, the paths are relative to the artifacts themselves (equivalent to\nparent equals to ",(0,l.mdx)("inlineCode",{parentName:"p"},"0"),"). Use ",(0,l.mdx)("inlineCode",{parentName:"p"},"parent")," to make the paths relative to an ancestor directory.\nFor example parent equals to ",(0,l.mdx)("inlineCode",{parentName:"p"},"1")," would make all paths relative to the containing dirs\nof any artifacts in the ",(0,l.mdx)("inlineCode",{parentName:"p"},"cmd_args"),"."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'dir = symlinked_dir(...)\nscript = [\n    cmd_args(dir, format = "cd {}", relative_to=dir),\n]\n')),(0,l.mdx)("h1",{id:"replace_regex"},(0,l.mdx)("inlineCode",{parentName:"h1"},"replace_regex")),(0,l.mdx)("p",null,"Replaces all parts matching pattern regular expression (or regular expressions)\nin each argument with replacement strings."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"ctarget_set"},"ctarget","_","set"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def ctarget_set(nodes: list[bxl.ConfiguredTargetNode] = _) -> target_set\n")),(0,l.mdx)("p",null,"Creates a target set from a list of configured nodes."),(0,l.mdx)("p",null,"Sample usage:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-text"},"def _impl_ctarget_set(ctx):\n    targets = bxl.ctarget_set([cnode_a, cnode_b])\n    ctx.output.print(type(targets))\n    ctx.output.print(len(targets))\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"dedupe"},"dedupe"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def dedupe(val, /)\n")),(0,l.mdx)("p",null,"Remove duplicates in a list. Uses identity of value (pointer), rather than by equality. In many cases you should use a transitive set instead."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"dynamic_actions"},"dynamic","_","actions"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def dynamic_actions(\n    *,\n    impl: typing.Callable["actions: actions, artifacts: dict[artifact, artifact_value], dynamic_values: dict[typing.Any, typing.Any], outputs: dict[artifact, artifact], arg: typing.Any", list[typing.Any]]\n) -> DynamicActionCallable\n')),(0,l.mdx)("p",null,"Create new dynamic action callable. Returned object will be callable, and the result of calling it can be passed to ",(0,l.mdx)("inlineCode",{parentName:"p"},"ctx.actions.dynamic_output_new"),"."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"fail_no_stacktrace"},"fail","_","no","_","stacktrace"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def fail_no_stacktrace(*args) -> None\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"file_set"},"file","_","set"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def file_set() -> file_set\n")),(0,l.mdx)("p",null,"Creates an empty file set for configured nodes."),(0,l.mdx)("p",null,"Sample usage:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-text"},"def _impl_file_set(ctx):\n    files = file_set()\n    ctx.output.print(type(files))\n    ctx.output.print(len(files))\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"get_base_path"},"get","_","base","_","path"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def get_base_path() -> str\n")),(0,l.mdx)("p",null,(0,l.mdx)("inlineCode",{parentName:"p"},"get_base_path()")," can only be called in buildfiles (e.g. BUCK files) or PACKAGE files, and returns the name of the package. E.g. inside ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo//bar/baz/BUCK")," the output will be ",(0,l.mdx)("inlineCode",{parentName:"p"},"bar/baz"),". E.g. inside ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo//bar/PACKAGE")," the output will be ",(0,l.mdx)("inlineCode",{parentName:"p"},"bar"),"."),(0,l.mdx)("p",null,"This function is identical to ",(0,l.mdx)("inlineCode",{parentName:"p"},"package_name"),"."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"get_cell_name"},"get","_","cell","_","name"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def get_cell_name() -> str\n")),(0,l.mdx)("p",null,(0,l.mdx)("inlineCode",{parentName:"p"},"get_cell_name()")," can be called from either a ",(0,l.mdx)("inlineCode",{parentName:"p"},"BUCK")," file or a ",(0,l.mdx)("inlineCode",{parentName:"p"},".bzl")," file, and returns the name of the cell where the ",(0,l.mdx)("inlineCode",{parentName:"p"},"BUCK")," file that started the call lives."),(0,l.mdx)("p",null,"For example, inside ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo//bar/baz/BUCK")," the output will be ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo"),".\nIf that ",(0,l.mdx)("inlineCode",{parentName:"p"},"BUCK")," file does a ",(0,l.mdx)("inlineCode",{parentName:"p"},'load("hello//world.bzl", "something")')," then\nthe result in that ",(0,l.mdx)("inlineCode",{parentName:"p"},".bzl")," file will also be ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo"),"."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"get_path_without_materialization"},"get","_","path","_","without","_","materialization"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def get_path_without_materialization(\n    this: artifact,\n    ctx: bxl.Context,\n    /,\n    *,\n    abs: bool = False\n) -> str\n")),(0,l.mdx)("p",null,"The output path of an artifact-like (source, build, declared). Takes an optional boolean to print the absolute or relative path. Note that this method returns an artifact path without asking for the artifact to be materialized (i.e. it may not actually exist on the disk yet)."),(0,l.mdx)("p",null,"This is a risky function to call because you may accidentally pass this path to further BXL actions\nthat expect the artifact to be materialized. If this happens, the BXL script will error out.\nIf you want the path without materialization for other uses that don\u2019t involve passing them into\nfurther actions, then it\u2019s safe."),(0,l.mdx)("p",null,"Sample usage:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-text"},'def _impl_get_path_without_materialization(ctx):\n    owner = ctx.cquery().owner("cell//path/to/file")[0]\n    artifact = owner.get_source("cell//path/to/file", ctx)\n    source_artifact_project_rel_path = get_path_without_materialization(artifact, ctx)\n    ctx.output.print(source_artifact_project_rel_path) # Note this artifact is NOT ensured or materialized\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"get_paths_without_materialization"},"get","_","paths","_","without","_","materialization"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def get_paths_without_materialization(\n    cmd_line: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | RunInfo,\n    ctx: bxl.Context,\n    /,\n    *,\n    abs: bool = False\n)\n")),(0,l.mdx)("p",null,"The output paths of a ",(0,l.mdx)("inlineCode",{parentName:"p"},"cmd_args()")," inputs. The output paths will be returned as a list. Takes an optional boolean to print the absolute or relative path. Note that this method returns an artifact path without asking for the artifact to be materialized, (i.e. it may not actually exist on the disk yet)."),(0,l.mdx)("p",null,"This is a risky function to call because you may accidentally pass this path to further BXL actions\nthat expect the artifact to be materialized. If this happens, the BXL script will error out.\nIf you want the path without materialization for other uses that don\u2019t involve passing them into\nfurther actions, then it\u2019s safe."),(0,l.mdx)("p",null,"Sample usage:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-text"},'def _impl_get_paths_without_materialization(ctx):\n    node = ctx.configured_targets("root//bin:the_binary")\n    providers = ctx.analysis(node).providers()\n    path = get_paths_without_materialization(providers[RunInfo], abs=True) # Note this artifact is NOT ensured or materialized\n    ctx.output.print(path)\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"glob"},"glob"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def glob(\n    include: list[str] | tuple[str, ...],\n    *,\n    exclude: list[str] | tuple[str, ...] = []\n) -> list[str]\n")),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"glob()")," function specifies a set of files using patterns. Only available from ",(0,l.mdx)("inlineCode",{parentName:"p"},"BUCK")," files."),(0,l.mdx)("p",null,"A typical ",(0,l.mdx)("inlineCode",{parentName:"p"},"glob")," call looks like:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'glob(["foo/**/*.h"])\n')),(0,l.mdx)("p",null,"This call will match all header files in the ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo")," directory, recursively."),(0,l.mdx)("p",null,"You can also pass a named ",(0,l.mdx)("inlineCode",{parentName:"p"},"exclude")," parameter to remove files matching a pattern:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'glob(["foo/**/*.h"], exclude = ["**/config.h"])\n')),(0,l.mdx)("p",null,"This call will remove all ",(0,l.mdx)("inlineCode",{parentName:"p"},"config.h")," files from the initial match."),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"glob()")," call is evaluated against the list of files owned by this ",(0,l.mdx)("inlineCode",{parentName:"p"},"BUCK")," file.\nA file is owned by whichever ",(0,l.mdx)("inlineCode",{parentName:"p"},"BUCK")," file is closest above it - so given ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo/BUCK")," and\n",(0,l.mdx)("inlineCode",{parentName:"p"},"foo/bar/BUCK")," the file ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo/file.txt")," would be owned by ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo/BUCK")," (and available from\nits ",(0,l.mdx)("inlineCode",{parentName:"p"},"glob")," results) but the file ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo/bar/file.txt")," would be owned by ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo/bar/BUCk"),"\nand ",(0,l.mdx)("em",{parentName:"p"},"not")," appear in the glob result of ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo/BUCK"),", even if you write ",(0,l.mdx)("inlineCode",{parentName:"p"},'glob(["bar/file.txt"])'),".\nAs a consequence of this rule, ",(0,l.mdx)("inlineCode",{parentName:"p"},'glob(["../foo.txt"])')," will always return an empty list of files."),(0,l.mdx)("p",null,"Currently ",(0,l.mdx)("inlineCode",{parentName:"p"},"glob")," is evaluated case-insensitively on all file systems, but we expect\nthat to change to case sensitive in the near future."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"host_info"},"host","_","info"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def host_info() -> struct(..)\n")),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"host_info()")," function is used to get the current OS and processor architecture on the host. The structure returned is laid out thusly:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"struct(\n    os=struct(\n        is_linux=True|False,\n        is_macos=True|False,\n        is_windows=True|False,\n        is_freebsd=True|False,\n        is_unknown=True|False,\n    ),\n    arch=struct(\n        is_aarch64=True|False,\n        is_arm=True|False,\n        is_armeb=True|False,\n        is_i386=True|False,\n        is_mips=True|False,\n        is_mips64=True|False,\n        is_mipsel=True|False,\n        is_mipsel64=True|False,\n        is_powerpc=True|False,\n        is_ppc64=True|False,\n        is_x86_64=True|False,\n        is_unknown=True|False,\n    ),\n)\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"implicit_package_symbol"},"implicit","_","package","_","symbol"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def implicit_package_symbol(name: str, default = _)\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"load_symbols"},"load","_","symbols"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def load_symbols(symbols: dict[str, typing.Any]) -> None\n")),(0,l.mdx)("p",null,"Used in a ",(0,l.mdx)("inlineCode",{parentName:"p"},".bzl")," file to set exported symbols. In most cases just defining the symbol as a top-level binding is sufficient, but sometimes the names might be programatically generated."),(0,l.mdx)("p",null,"It is undefined behaviour if you try and use any of the symbols exported\nhere later in the same module, or if they overlap with existing definitions.\nThis function should be used rarely."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"now"},"now"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def now() -> instant\n")),(0,l.mdx)("p",null,"Creates an Instant at the current time."),(0,l.mdx)("p",null,"Sample usage:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-text"},"def _impl_elapsed_millis(ctx):\n    instant = now()\n    time_a = instant.elapsed_millis()\n    # do something that takes a long time\n    time_b = instant.elapsed_millis()\n\n    ctx.output.print(time_a)\n    ctx.output.print(time_b)\n")),(0,l.mdx)("p",null,"This function is only accessible through Bxl."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"oncall"},"oncall"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def oncall(name: str, /) -> None\n")),(0,l.mdx)("p",null,"Called in a ",(0,l.mdx)("inlineCode",{parentName:"p"},"BUCK")," file to declare the oncall contact details for all the targets defined. Must be called at most once, before any targets have been declared. Errors if called from a ",(0,l.mdx)("inlineCode",{parentName:"p"},".bzl")," file."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"package"},"package"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def package(\n    *,\n    inherit: bool = False,\n    visibility: list[str] | tuple[str, ...] = [],\n    within_view: list[str] | tuple[str, ...] = []\n) -> None\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"package_name"},"package","_","name"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def package_name() -> str\n")),(0,l.mdx)("p",null,(0,l.mdx)("inlineCode",{parentName:"p"},"package_name()")," can only be called in buildfiles (e.g. BUCK files) or PACKAGE files, and returns the name of the package. E.g. inside ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo//bar/baz/BUCK")," the output will be ",(0,l.mdx)("inlineCode",{parentName:"p"},"bar/baz"),". E.g. inside ",(0,l.mdx)("inlineCode",{parentName:"p"},"foo//bar/PACKAGE")," the output will be ",(0,l.mdx)("inlineCode",{parentName:"p"},"bar"),"."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"plugins"},"plugins"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"plugins: plugins\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"provider-1"},"provider"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def provider(\n    *,\n    doc: str = "",\n    fields: list[str] | tuple[str, ...] | dict[str, typing.Any]\n) -> provider_callable\n')),(0,l.mdx)("p",null,"Create a ",(0,l.mdx)("inlineCode",{parentName:"p"},'"provider"')," type that can be returned from ",(0,l.mdx)("inlineCode",{parentName:"p"},"rule")," implementations. Used to pass information from a rule to the things that depend on it. Typically named with an ",(0,l.mdx)("inlineCode",{parentName:"p"},"Info")," suffix."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'GroovyLibraryInfo(fields = [\n    "objects",  # a list of artifacts\n    "options",  # a string containing compiler options\n])\n')),(0,l.mdx)("p",null,"Given a dependency you can obtain the provider with ",(0,l.mdx)("inlineCode",{parentName:"p"},"my_dep[GroovyLibraryInfo]"),"\nwhich returns either ",(0,l.mdx)("inlineCode",{parentName:"p"},"None")," or a value of type ",(0,l.mdx)("inlineCode",{parentName:"p"},"GroovyLibraryInfo"),"."),(0,l.mdx)("p",null,"For providers that accumulate upwards a transitive set is often a good choice."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"provider_field"},"provider","_","field"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def provider_field(\n    ty,\n    /,\n    *,\n    default = _\n) -> ProviderField\n")),(0,l.mdx)("p",null,"Create a field definition object which can be passed to ",(0,l.mdx)("inlineCode",{parentName:"p"},"provider")," type constructor."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"read_config"},"read","_","config"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def read_config(section: str, key: str, default = _)\n")),(0,l.mdx)("p",null,"Read a configuration from the nearest enclosing ",(0,l.mdx)("inlineCode",{parentName:"p"},".buckconfig")," of the ",(0,l.mdx)("inlineCode",{parentName:"p"},"BUCK")," file that started evaluation of this code."),(0,l.mdx)("p",null,"As an example, if you have a ",(0,l.mdx)("inlineCode",{parentName:"p"},".buckconfig")," of:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-toml"},"[package_options]\ncompile = super_fast\n")),(0,l.mdx)("p",null,"Then you would get the following results:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'read_config("package_options", "compile") == "super_fast"\nread_config("package_options", "linker") == None\nread_config("package_options", "linker", "a_default") == "a_default"\n')),(0,l.mdx)("p",null,"In general the use of ",(0,l.mdx)("inlineCode",{parentName:"p"},".buckconfig")," is discouraged in favour of ",(0,l.mdx)("inlineCode",{parentName:"p"},"select"),",\nbut it can still be useful."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"read_oncall"},"read","_","oncall"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def read_oncall() -> None | str\n")),(0,l.mdx)("p",null,"Called in a ",(0,l.mdx)("inlineCode",{parentName:"p"},"BUCK")," file to retrieve the previously set ",(0,l.mdx)("inlineCode",{parentName:"p"},"oncall"),", or ",(0,l.mdx)("inlineCode",{parentName:"p"},"None")," if none has been set. It is an error to call ",(0,l.mdx)("inlineCode",{parentName:"p"},"oncall")," after calling this function."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"read_package_value"},"read","_","package","_","value"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def read_package_value(key: str, /)\n")),(0,l.mdx)("p",null,"Read value specified in the ",(0,l.mdx)("inlineCode",{parentName:"p"},"PACKAGE")," file."),(0,l.mdx)("p",null,"Returns ",(0,l.mdx)("inlineCode",{parentName:"p"},"None")," if value is not set."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"read_parent_package_value"},"read","_","parent","_","package","_","value"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def read_parent_package_value(key: str, /)\n")),(0,l.mdx)("p",null,"Read a package value defined in a parent ",(0,l.mdx)("inlineCode",{parentName:"p"},"PACKAGE")," file."),(0,l.mdx)("p",null,"This function can only be called in a Package context."),(0,l.mdx)("p",null,"Returns ",(0,l.mdx)("inlineCode",{parentName:"p"},"None")," if value is not set."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"read_root_config"},"read","_","root","_","config"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def read_root_config(\n    section: str,\n    key: str,\n    default: None | str = None,\n    /\n) -> None | str\n")),(0,l.mdx)("p",null,"Like ",(0,l.mdx)("inlineCode",{parentName:"p"},"read_config")," but the project root ",(0,l.mdx)("inlineCode",{parentName:"p"},".buckconfig")," is always consulted, regardless of the cell of the originating ",(0,l.mdx)("inlineCode",{parentName:"p"},"BUCK")," file."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"regex"},"regex"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def regex(\n    regex: str,\n    /,\n    *,\n    fancy: bool = False\n) -> buck_regex\n")),(0,l.mdx)("h4",{id:"type-attribute-15"},(0,l.mdx)("inlineCode",{parentName:"h4"},".type")," attribute"),(0,l.mdx)("p",null,"Produces ",(0,l.mdx)("inlineCode",{parentName:"p"},'"buck_regex"')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"regex_match"},"regex","_","match"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def regex_match(regex: str, str: str, /) -> bool\n")),(0,l.mdx)("p",null,"Test if a regular expression matches a string. Fails if the regular expression is malformed."),(0,l.mdx)("p",null,"As an example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'regex_match("^[a-z]*$", "hello") == True\nregex_match("^[a-z]*$", "1234") == False\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"repository_name"},"repository","_","name"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def repository_name() -> str\n")),(0,l.mdx)("p",null,"Like ",(0,l.mdx)("inlineCode",{parentName:"p"},"get_cell_name()")," but prepends a leading ",(0,l.mdx)("inlineCode",{parentName:"p"},"@")," for compatibility with Buck1. You should call ",(0,l.mdx)("inlineCode",{parentName:"p"},"get_cell_name()")," instead, and if you really want the ",(0,l.mdx)("inlineCode",{parentName:"p"},"@"),", prepend it yourself."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"rule"},"rule"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def rule(\n    *,\n    impl: typing.Callable[[typing.Any], list[typing.Any]],\n    attrs: dict[str, attribute],\n    cfg = _,\n    doc: str = "",\n    is_configuration_rule: bool = False,\n    is_toolchain_rule: bool = False,\n    uses_plugins: list[typing.Any] | tuple = []\n) -> "function"\n')),(0,l.mdx)("p",null,"Define a rule. As a simple example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def _my_rule(ctx: AnalysisContext) -> list[Provider]:\n    output = ctx.actions.write("hello.txt", ctx.attrs.contents, executable = ctx.attrs.exe)\n    return [DefaultInfo(outputs = [output])]\n\nMyRule = rule(impl = _my_rule, attrs = {\n    "contents": attrs.string(),\n    "exe": attrs.option(attrs.bool(), default = False),\n})\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"rule_exists"},"rule","_","exists"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def rule_exists(name: str) -> bool\n")),(0,l.mdx)("p",null,"Check if the target with ",(0,l.mdx)("inlineCode",{parentName:"p"},"name")," has already been defined, returns ",(0,l.mdx)("inlineCode",{parentName:"p"},"True")," if it has."),(0,l.mdx)("p",null,"Note that this function checks for the existence of a ",(0,l.mdx)("em",{parentName:"p"},"target")," rather than a ",(0,l.mdx)("em",{parentName:"p"},"rule"),".\nIn general use of this function is discouraged, as it makes definitions of rules not compose."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"select-1"},"select"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def select(d, /) -> selector\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"select_equal_internal"},"select","_","equal","_","internal"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def select_equal_internal(left, right, /) -> bool\n")),(0,l.mdx)("p",null,"Tests that two selects are equal to each other. For testing use only. We simply compare their string representations."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"select_map"},"select","_","map"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def select_map(d, func, /)\n")),(0,l.mdx)("p",null,"Maps a selector."),(0,l.mdx)("p",null,"Each value within a selector map and on each side of an addition will be passed to the\nmapping function. The returned selector will have the same structure as this one."),(0,l.mdx)("p",null,"Ex:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-starlark"},'def increment_items(a):\n    return [v + 1 for v in a]\n\nselect_map([1, 2] + select({"c": [2]}), increment_items) == [2, 3] + select({"c": [3]})\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"select_test"},"select","_","test"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def select_test(d, func, /) -> bool\n")),(0,l.mdx)("p",null,"Test values in the select expression using the given function."),(0,l.mdx)("p",null,"Returns True, if any value in the select passes, else False."),(0,l.mdx)("p",null,"Ex:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-starlark"},'select_test([1] + select({"c": [1]}), lambda a: len(a) > 1) == False\nselect_test([1, 2] + select({"c": [1]}), lambda a: len(a) > 1) == True\nselect_test([1] + select({"c": [1, 2]}), lambda a: len(a) > 1) == True\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"set_cfg_constructor"},"set","_","cfg","_","constructor"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def set_cfg_constructor(\n    *,\n    stage0,\n    stage1,\n    key: str,\n    aliases = None,\n    extra_data = None\n) -> None\n")),(0,l.mdx)("p",null,"Register global cfg constructor."),(0,l.mdx)("p",null,"This function can only be called from the repository root ",(0,l.mdx)("inlineCode",{parentName:"p"},"PACKAGE")," file."),(0,l.mdx)("p",null,"Parameters:\nstage0: The first cfg constructor that will be invoked before configuration rules are analyzed.\nstage1: The second cfg constructor that will be invoked after configuration rules are analyzed.\nkey: The key for cfg modifiers on PACKAGE values and metadata.\naliases: The aliases map to use for input modifiers.\nextra_data: Some extra data that may be used by ",(0,l.mdx)("inlineCode",{parentName:"p"},"set_cfg_constructor")," implementation that is\ncustom to our implementation and may not be used in other context like open-source."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"set_starlark_peak_allocated_byte_limit"},"set","_","starlark","_","peak","_","allocated","_","byte","_","limit"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def set_starlark_peak_allocated_byte_limit(value: int, /) -> None\n")),(0,l.mdx)("p",null,"Set the peak allocated bytes during evaluation of build ctx. Err if it has already been set"),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"sha256"},"sha256"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def sha256(val: str, /) -> str\n")),(0,l.mdx)("p",null,"Computes a sha256 digest for a string. Returns the hex representation of the digest."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'sha256("Buck2 is the best build system") == "bb99a3f19ecba6c4d2c7cd321b63b669684c713881baae21a6b1d759b3ec6ac9"\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"soft_error"},"soft","_","error"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def soft_error(\n    category: str,\n    message: str,\n    /,\n    *,\n    quiet: bool = _,\n    stack: bool = _\n) -> None\n")),(0,l.mdx)("p",null,"Produce an error that will become a hard error at some point in the future, but for now is a warning which is logged to the server. In the open source version of Buck2 this function always results in an error."),(0,l.mdx)("p",null,"Called passing a stable key (must be ",(0,l.mdx)("inlineCode",{parentName:"p"},"snake_case")," and start with ",(0,l.mdx)("inlineCode",{parentName:"p"},"starlark_"),",\nused for consistent reporting) and an arbitrary message (used for debugging)."),(0,l.mdx)("p",null,"As an example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'soft_error(\n    "starlark_rule_is_too_long",\n    "Length of property exceeds 100 characters in " + repr(ctx.label),\n)\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"transition"},"transition"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def transition(\n    *,\n    impl: typing.Callable,\n    refs: dict[str, str],\n    attrs: list[str] | tuple[str, ...] = _,\n    split: bool = False\n) -> transition\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"transitive_set"},"transitive","_","set"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def transitive_set(\n    *,\n    args_projections: dict[str, typing.Any] = _,\n    json_projections: dict[str, typing.Any] = _,\n    reductions: dict[str, typing.Any] = _\n) -> transitive_set_definition\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"utarget_set"},"utarget","_","set"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def utarget_set(nodes: list[bxl.UnconfiguredTargetNode] = _) -> target_set\n")),(0,l.mdx)("p",null,"Creates a target set from a list of unconfigured nodes."),(0,l.mdx)("p",null,"Sample usage:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-text"},"def _impl_utarget_set(ctx):\n    targets = bxl.utarget_set([unode_a, unode_b])\n    ctx.output.print(type(targets))\n    ctx.output.print(len(targets))\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"warning"},"warning"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def warning(x: str, /) -> None\n")),(0,l.mdx)("p",null,"Print a warning. The line will be decorated with the timestamp and other details, including the word ",(0,l.mdx)("inlineCode",{parentName:"p"},"WARN")," (colored, if the console supports it)."),(0,l.mdx)("p",null,"If you are not writing a warning, use ",(0,l.mdx)("inlineCode",{parentName:"p"},"print")," instead. Be aware that printing\nlots of output (warnings or not) can be cause all information to be ignored by the user."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"write_package_value"},"write","_","package","_","value"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def write_package_value(\n    key: str,\n    value,\n    /,\n    *,\n    overwrite: bool = False\n) -> None\n")),(0,l.mdx)("p",null,"Set the value to be accessible in the nested ",(0,l.mdx)("inlineCode",{parentName:"p"},"PACKAGE")," files."),(0,l.mdx)("p",null,"If any parent ",(0,l.mdx)("inlineCode",{parentName:"p"},"PACKAGE")," value has already set the same ",(0,l.mdx)("inlineCode",{parentName:"p"},"key"),",\nit will raise an error unless you pass ",(0,l.mdx)("inlineCode",{parentName:"p"},"overwrite = True"),",\nin which case it will replace the parent value."))}p.isMDXComponent=!0}}]);