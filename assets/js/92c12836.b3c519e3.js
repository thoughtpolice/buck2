"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6797],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>s,MDXProvider:()=>x,mdx:()=>b,useMDXComponents:()=>u,withMDXComponents:()=>p});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),p=function(e){return function(t){var n=u(t.components);return a.createElement(e,r({},t,{components:n}))}},u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},x=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,o=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),p=u(n),x=l,m=p["".concat(o,".").concat(x)]||p[x]||c[x]||r;return n?a.createElement(m,i(i({ref:t},s),{},{components:n})):a.createElement(m,i({ref:t},s))}));function b(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,o=new Array(r);o[0]=g;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i[m]="string"==typeof e?e:l,o[1]=i;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},82524:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>s});var a=n(87462),l=(n(67294),n(3905));const r={id:"bxl.Context"},o="bxl.Context type",i={unversionedId:"api/bxl/bxl.Context",id:"api/bxl/bxl.Context",title:"bxl.Context type",description:"The bxl context that the top level bxl implementation receives as parameter. This context contains all the core bxl functions to query, build, create actions, etc.",source:"@site/../docs/api/bxl/bxl.Context.generated.md",sourceDirName:"api/bxl",slug:"/api/bxl/bxl.Context",permalink:"/docs/api/bxl/bxl.Context",draft:!1,tags:[],version:"current",frontMatter:{id:"bxl.Context"},sidebar:"apiSidebar",previous:{title:"bxl.ConfiguredTargetNode type",permalink:"/docs/api/bxl/bxl.ConfiguredTargetNode"},next:{title:"bxl.CqueryContext type",permalink:"/docs/api/bxl/bxl.CqueryContext"}},d={},s=[{value:"bxl.Context.analysis",id:"bxlcontextanalysis",level:2},{value:"bxl.Context.aquery",id:"bxlcontextaquery",level:2},{value:"bxl.Context.audit",id:"bxlcontextaudit",level:2},{value:"bxl.Context.build",id:"bxlcontextbuild",level:2},{value:"bxl.Context.bxl_actions",id:"bxlcontextbxl_actions",level:2},{value:"bxl.Context.cell_root",id:"bxlcontextcell_root",level:2},{value:"bxl.Context.cli_args",id:"bxlcontextcli_args",level:2},{value:"bxl.Context.configured_targets",id:"bxlcontextconfigured_targets",level:2},{value:"bxl.Context.cquery",id:"bxlcontextcquery",level:2},{value:"bxl.Context.fs",id:"bxlcontextfs",level:2},{value:"bxl.Context.instant_event",id:"bxlcontextinstant_event",level:2},{value:"bxl.Context.output",id:"bxlcontextoutput",level:2},{value:"bxl.Context.resolve",id:"bxlcontextresolve",level:2},{value:"bxl.Context.root",id:"bxlcontextroot",level:2},{value:"bxl.Context.target_exists",id:"bxlcontexttarget_exists",level:2},{value:"bxl.Context.target_universe",id:"bxlcontexttarget_universe",level:2},{value:"bxl.Context.unconfigured_sub_targets",id:"bxlcontextunconfigured_sub_targets",level:2},{value:"bxl.Context.unconfigured_targets",id:"bxlcontextunconfigured_targets",level:2},{value:"bxl.Context.uquery",id:"bxlcontextuquery",level:2}],p={toc:s};function u(e){let{components:t,...n}=e;return(0,l.mdx)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.mdx)("h1",{id:"bxlcontext-type"},(0,l.mdx)("inlineCode",{parentName:"h1"},"bxl.Context")," type"),(0,l.mdx)("p",null,"The bxl context that the top level bxl implementation receives as parameter. This context contains all the core bxl functions to query, build, create actions, etc."),(0,l.mdx)("h2",{id:"bxlcontextanalysis"},"bxl.Context.analysis"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.analysis(\n    labels: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label],\n    target_platform: None | str | target_label = _,\n    *,\n    skip_incompatible: bool = True\n) -> None | bxl.AnalysisResult | dict[label, bxl.AnalysisResult]\n")),(0,l.mdx)("p",null,"Runs analysis on the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),", accepting an optional ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," which is the target platform configuration used to resolve configurations of any unconfigured target nodes, and an optional ",(0,l.mdx)("inlineCode",{parentName:"p"},"skip_incompatible")," boolean that indicates whether to skip analysis of nodes that are incompatible with the target platform. The ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," is either a string that can be parsed as a target label, or a target label."),(0,l.mdx)("p",null,"The given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is a providers expression, which is either:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"- a single string that is a `target pattern`.\n- a single target node or label, configured or unconfigured\n- a single sub target label, configured or unconfigured\n- a list of the two options above.\n")),(0,l.mdx)("p",null,"This returns either a single ",(0,l.mdx)("inlineCode",{parentName:"p"},"analysis_result")," if the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),' argument is "singular",\nor a dict keyed by sub target labels of ',(0,l.mdx)("inlineCode",{parentName:"p"},"analysis")," if the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," argument\nis list-like"),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextaquery"},"bxl.Context.aquery"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.aquery(\n    target_platform: None | str | target_label = _\n) -> bxl.AqueryContext\n")),(0,l.mdx)("p",null,"Returns the ",(0,l.mdx)("inlineCode",{parentName:"p"},"aqueryctx")," that holds all the aquery functions. This function takes an optional parameter ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform"),", which is the target platform configuration used to configured any unconfigured target nodes."),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," is a target label, or a string that is a target label."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextaudit"},"bxl.Context.audit"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.audit() -> bxl.AuditContext\n")),(0,l.mdx)("p",null,"Returns the ",(0,l.mdx)("inlineCode",{parentName:"p"},"audit_ctx")," that holds all the audit functions."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextbuild"},"bxl.Context.build"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def bxl.Context.build(\n    labels: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label],\n    target_platform: None | str | target_label = _,\n    *,\n    materializations: str = "default"\n) -> dict[label, bxl.BuildResult]\n')),(0,l.mdx)("p",null,"Runs a build on the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),", accepting an optional ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," which is the target platform configuration used to resolve configurations. Note that when ",(0,l.mdx)("inlineCode",{parentName:"p"},"build()")," is called, the artifacts are materialized without needing to additionally call ",(0,l.mdx)("inlineCode",{parentName:"p"},"ensure()")," on them."),(0,l.mdx)("p",null,"The given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is a providers expression, which is either:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"- a single string that is a `target pattern`.\n- a single target node or label, configured or unconfigured\n- a single provider label, configured or unconfigured\n- a list of the two options above.\n")),(0,l.mdx)("p",null,"This returns a dict keyed by sub target labels mapped to ",(0,l.mdx)("inlineCode",{parentName:"p"},"bxl_build_result"),"s if the\ngiven ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," argument is list-like."),(0,l.mdx)("p",null,"This function is not available on the ",(0,l.mdx)("inlineCode",{parentName:"p"},"bxl_ctx")," when called from ",(0,l.mdx)("inlineCode",{parentName:"p"},"dynamic_output"),"."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextbxl_actions"},"bxl.Context.bxl","_","actions"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.bxl_actions(\n    *,\n    exec_deps: None | bxl.UnconfiguredTargetNode | providers_label | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | providers_label | str | target_label] = None,\n    toolchains: None | bxl.UnconfiguredTargetNode | providers_label | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | providers_label | str | target_label] = None,\n    target_platform: None | str | target_label = _,\n    exec_compatible_with: None | bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] = None\n) -> bxl.Actions\n")),(0,l.mdx)("p",null,"Returns the bxl actions to create and register actions for this bxl function. This will have the execution platform resolved according to the execution deps and toolchains you pass into this function. You'll be able to access the analysis action factory of the correct execution platform, toolchains, and execution deps of the corresponding configuration via this context."),(0,l.mdx)("p",null,"Actions created by bxl will not be built by default. Instead, they are marked to be built\nby ",(0,l.mdx)("inlineCode",{parentName:"p"},"ctx.output.ensure(artifact)")," on the output module of the ",(0,l.mdx)("inlineCode",{parentName:"p"},"bxl_ctx"),". Only artifacts\nmarked by ensure will be built."),(0,l.mdx)("p",null,"Sample usage:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def _impl_write_action(ctx):\n    bxl_actions = ctx.bxl_actions()\n    output = bxl_actions.actions.write("my_output", "my_content")\n    ensured = ctx.output.ensure(output)\n    ctx.output.print(ensured)\n')),(0,l.mdx)("p",null,"There are several optional named parameters:"),(0,l.mdx)("p",null,(0,l.mdx)("inlineCode",{parentName:"p"},"exec_deps")," - These are dependencies you wish to access as executables for creating the action.\nThis is usually the same set of targets one would pass to rule's ",(0,l.mdx)("inlineCode",{parentName:"p"},"attr.exec_dep"),".\n",(0,l.mdx)("inlineCode",{parentName:"p"},"toolchains")," - The set of toolchains needed for the actions you intend to create.\n",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," - The intended target platform for your toolchains\n",(0,l.mdx)("inlineCode",{parentName:"p"},"exec_compatible_with")," - Explicit list of configuration nodes (like platforms or constraints)\nthat these actions are compatible with. This is the 'exec_compatible_with' attribute of a target."),(0,l.mdx)("p",null,"If you passed in ",(0,l.mdx)("inlineCode",{parentName:"p"},"exec_deps")," or ",(0,l.mdx)("inlineCode",{parentName:"p"},"toolchains"),", you can access the resolved dependencies using the ",(0,l.mdx)("inlineCode",{parentName:"p"},"exec_deps"),"\nand ",(0,l.mdx)("inlineCode",{parentName:"p"},"toolchains")," attributes on the ",(0,l.mdx)("inlineCode",{parentName:"p"},"bxl_actions"),", which both return a ",(0,l.mdx)("inlineCode",{parentName:"p"},"dict")," of unconfigured subtarget labels\nand their configured/resolved ",(0,l.mdx)("inlineCode",{parentName:"p"},"dependency")," objects."),(0,l.mdx)("p",null,"Note that the keys of ",(0,l.mdx)("inlineCode",{parentName:"p"},"exec_deps")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"toolchains")," must be unconfigured subtarget labels (",(0,l.mdx)("inlineCode",{parentName:"p"},"providers_label"),"s),\nand not unconfigured target labels. You can use ",(0,l.mdx)("inlineCode",{parentName:"p"},"ctx.unconfigured_sub_targets(...)")," or ",(0,l.mdx)("inlineCode",{parentName:"p"},"with_sub_target()")," on\n",(0,l.mdx)("inlineCode",{parentName:"p"},"target_label")," to create the label."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'def _impl_run_action(ctx):\n   my_exec_dep = ctx.unconfigured_sub_targets("foo//bar:baz") # has some provider that you would use in the action\n   bxl_actions = ctx.bxl_actions(exec_deps = [my_exec_dep]) # call once, reuse wherever needed\n   output = bxl_actions.actions.run(\n       [\n           "python3",\n           bxl_actions.exec_deps[my_exec_dep][RunInfo], # access resolved exec_deps on the `bxl_actions`\n           out.as_output(),\n       ],\n       category = "command",\n       local_only = True,\n   )\n   ctx.output.ensure(output)\n')),(0,l.mdx)("p",null,"When called from a ",(0,l.mdx)("inlineCode",{parentName:"p"},"dynamic_output"),", ",(0,l.mdx)("inlineCode",{parentName:"p"},"bxl_actions()")," cannot be configured with a different execution\nplatform resolution from the parent BXL."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextcell_root"},"bxl.Context.cell","_","root"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.cell_root() -> str\n")),(0,l.mdx)("p",null,"Returns the absolute path to the cell of the repository"),(0,l.mdx)("p",null,"This function is not available on the ",(0,l.mdx)("inlineCode",{parentName:"p"},"bxl_ctx")," when called from ",(0,l.mdx)("inlineCode",{parentName:"p"},"dynamic_output"),"."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextcli_args"},"bxl.Context.cli","_","args"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"bxl.Context.cli_args: struct(..)\n")),(0,l.mdx)("p",null,"A struct of the command line args as declared using the ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"cli_args"),"]"," module. These command lines are resolved per the users input on the cli when invoking the bxl script."),(0,l.mdx)("p",null,"If you wish to pass in a kebab-cased arg, the arg accessed from the BXL context's ",(0,l.mdx)("inlineCode",{parentName:"p"},"cli_args"),"\nattrbute will always be in snakecase. For example, if you passed in ",(0,l.mdx)("inlineCode",{parentName:"p"},"my-arg"),", accessing it\nwithin BXL would look like ",(0,l.mdx)("inlineCode",{parentName:"p"},"ctx.cli_args.my_arg"),"."),(0,l.mdx)("p",null,"This attribute is not available on the bxl context within the a dynamic lambda."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextconfigured_targets"},"bxl.Context.configured","_","targets"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.configured_targets(\n    labels: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label],\n    /,\n    target_platform: None | str | target_label = _\n) -> None | bxl.ConfiguredTargetNode | target_set\n")),(0,l.mdx)("p",null,"Gets the target nodes for the ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),", accepting an optional ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," which is the target platform configuration used to resolve configurations of any unconfigured target nodes. The ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," is either a string that can be parsed as a target label, or a target label."),(0,l.mdx)("p",null,"The given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is a ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"TargetListExpr"),"]",", which is either:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"- a single string that is a `target pattern`.\n- a single target node or label, configured or unconfigured\n- a list of the two options above.\n")),(0,l.mdx)("p",null,"Note that this function does not accept ",(0,l.mdx)("inlineCode",{parentName:"p"},"Label")," (which is a configured provider label), since this\nis the label of a subtarget. You can get the underlying configured target label on the ",(0,l.mdx)("inlineCode",{parentName:"p"},"Label"),"\nusing ",(0,l.mdx)("inlineCode",{parentName:"p"},"configured_targets()")," (ex: ",(0,l.mdx)("inlineCode",{parentName:"p"},"my_label.configured_target()"),")."),(0,l.mdx)("p",null,"This returns either a single ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_node")," if the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),'\nis "singular", a dict keyed by target labels of ',(0,l.mdx)("inlineCode",{parentName:"p"},"target_node")," if the\ngiven ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is list-like"),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextcquery"},"bxl.Context.cquery"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.cquery(\n    target_platform: None | str | target_label = _\n) -> bxl.CqueryContext\n")),(0,l.mdx)("p",null,"Returns the ",(0,l.mdx)("inlineCode",{parentName:"p"},"cqueryctx")," that holds all the cquery functions. This function takes an optional parameter ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform"),", which is the target platform configuration used to configured any unconfigured target nodes."),(0,l.mdx)("p",null,"The ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," is a target label, or a string that is a target label."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextfs"},"bxl.Context.fs"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"bxl.Context.fs: bxl.Filesystem\n")),(0,l.mdx)("p",null,"Returns the ",(0,l.mdx)("inlineCode",{parentName:"p"},"bxl.Filesystem")," for performing a basic set of filesystem operations within bxl"),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextinstant_event"},"bxl.Context.instant","_","event"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.instant_event(*, id: str, metadata) -> None\n")),(0,l.mdx)("p",null,"Emits a user-defined instant event, taking in a required string id and a metadata dictionary where the keys are strings, and values are either strings, bools, or ints. The id is user-supplied, and used to identify the instant events in the event logs more easily."),(0,l.mdx)("p",null,"You may pass in an ensured artifact as a value in the metadata. The resulting output would be the ensured\nartifact's relative or absolute path as a string."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextoutput"},"bxl.Context.output"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"bxl.Context.output: bxl.OutputStream\n")),(0,l.mdx)("p",null,"Gets the output stream to the console via stdout. Items written to the output stream are considered to be the results of a bxl script, which will be displayed to stdout by buck2 even when the script is cached."),(0,l.mdx)("p",null,"Prints that are not result of the bxl should be printed via stderr via the stdlib ",(0,l.mdx)("inlineCode",{parentName:"p"},"print"),"\nand ",(0,l.mdx)("inlineCode",{parentName:"p"},"pprint"),"."),(0,l.mdx)("p",null,"This function is not available on the ",(0,l.mdx)("inlineCode",{parentName:"p"},"bxl_ctx")," when called from ",(0,l.mdx)("inlineCode",{parentName:"p"},"dynamic_output"),"."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextresolve"},"bxl.Context.resolve"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.resolve(action_factory: actions, promise: promise)\n")),(0,l.mdx)("p",null,"Awaits a promise and returns an optional value of the promise."),(0,l.mdx)("p",null,"Sample usage:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},'load("//path/to/rules:rules.bzl", "my_anon_targets_rule", "my_map_function")\n\ndef _resolve_impl(ctx):\n    actions = ctx.bxl_actions().actions\n    my_attrs = {\n        "false": False,\n        "int": 42,\n        "list_string": ["a", "b", "c"],\n        "string": "a-string",\n        "true": True,\n    }\n\n    promise = actions.anon_target(my_anon_targets_rule, attrs).promise.map(my_map_function)\n    providers_result = ctx.resolve(actions, promise) # result is `provider_collection` type, which is a collection of `provider`s\n    ctx.output.print(providers_result[0].my_field)\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextroot"},"bxl.Context.root"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.root() -> str\n")),(0,l.mdx)("p",null,"Returns the absolute path to the root of the repository"),(0,l.mdx)("p",null,"This function is not available on the ",(0,l.mdx)("inlineCode",{parentName:"p"},"bxl_ctx")," when called from ",(0,l.mdx)("inlineCode",{parentName:"p"},"dynamic_output"),"."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontexttarget_exists"},"bxl.Context.target","_","exists"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.target_exists(label: str) -> bool\n")),(0,l.mdx)("p",null,"Checks if a target label exists. Target label must be a string literal, and an exact target."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontexttarget_universe"},"bxl.Context.target","_","universe"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.target_universe(\n    labels: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label],\n    target_platform: None | str | target_label = _,\n    *,\n    keep_going: bool = False\n) -> bxl.TargetUniverse\n")),(0,l.mdx)("p",null,"Returns the ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_universe")," that can lookup valid configured nodes in the universe."),(0,l.mdx)("p",null,"The given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is a target expression, which is either:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"- a single string that is a `target pattern`.\n- a single target node or label, configured or unconfigured\n- a single subtarget label, configured or unconfigured\n- a list of the two options above.\n")),(0,l.mdx)("p",null,"Also takes in an optional ",(0,l.mdx)("inlineCode",{parentName:"p"},"target_platform")," param to configure the nodes with, and a ",(0,l.mdx)("inlineCode",{parentName:"p"},"keep_going``\nflag to skip any loading or configuration errors. Note that "),"keep_going` currently can only be used\nif the input labels is a single target pattern as a string literal."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextunconfigured_sub_targets"},"bxl.Context.unconfigured","_","sub","_","targets"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.unconfigured_sub_targets(\n    labels: bxl.UnconfiguredTargetNode | providers_label | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | providers_label | str | target_label]\n) -> providers_label | dict[str, providers_label]\n")),(0,l.mdx)("p",null,"Gets the unconfigured subtargets for the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")),(0,l.mdx)("p",null,"The given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is a providers expression, which is either:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"- a single string that is a `target pattern`.\n- a single target node or label, configured or unconfigured\n- a single subtarget label, configured or unconfigured\n- a list of the two options above.\n")),(0,l.mdx)("p",null,"This returns either a single ",(0,l.mdx)("inlineCode",{parentName:"p"},"providers_label")," if the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),' argument\nis "singular", or dict of the subtarget string representation to the\n',(0,l.mdx)("inlineCode",{parentName:"p"},"providers_label")," if the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," argument is list-like."),(0,l.mdx)("p",null,"Note that this function does not check that this subtarget exists in the repo."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextunconfigured_targets"},"bxl.Context.unconfigured","_","targets"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.unconfigured_targets(\n    labels: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label]\n) -> bxl.UnconfiguredTargetNode | target_set\n")),(0,l.mdx)("p",null,"Gets the unconfigured target nodes for the ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")),(0,l.mdx)("p",null,"The given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is either:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"- a single string that is a `target pattern`.\n- a single unconfigured  target node or label\n- a list of the two options above.\n")),(0,l.mdx)("p",null,"This returns either a single ","[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkTargetNode"),"]"," if the given ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels"),'\nis "singular", a dict keyed by target labels of ',"[",(0,l.mdx)("inlineCode",{parentName:"p"},"StarlarkTargetNode"),"]"," if the\ngiven ",(0,l.mdx)("inlineCode",{parentName:"p"},"labels")," is list-like"),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"bxlcontextuquery"},"bxl.Context.uquery"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-python"},"def bxl.Context.uquery() -> bxl.UqueryContext\n")),(0,l.mdx)("p",null,"Returns the ",(0,l.mdx)("inlineCode",{parentName:"p"},"uqueryctx")," that holds all uquery functions."))}u.isMDXComponent=!0}}]);