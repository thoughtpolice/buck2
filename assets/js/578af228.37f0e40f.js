"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6742],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>m,MDXProvider:()=>u,mdx:()=>y,useMDXComponents:()=>s,withMDXComponents:()=>d});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},r.apply(this,arguments)}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var m=a.createContext({}),d=function(e){return function(n){var t=s(n.components);return a.createElement(e,r({},n,{components:t}))}},s=function(e){var n=a.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(m.Provider,{value:n},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},x=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=p(e,["components","mdxType","originalType","parentName"]),d=s(t),u=i,c=d["".concat(l,".").concat(u)]||d[u]||h[u]||r;return t?a.createElement(c,o(o({ref:n},m),{},{components:t})):a.createElement(c,o({ref:n},m))}));function y(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=x;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var m=2;m<r;m++)l[m]=t[m];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}x.displayName="MDXCreateElement"},99238:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>s,frontMatter:()=>r,metadata:()=>o,toc:()=>m});var a=t(87462),i=(t(67294),t(3905));const r={id:"types"},l="Starlark Types",o={unversionedId:"developers/starlark/types",id:"developers/starlark/types",title:"Starlark Types",description:"The Starlark 'types' extension is highly experimental and likely to be modified",source:"@site/../docs/developers/starlark/types.generated.md",sourceDirName:"developers/starlark",slug:"/developers/starlark/types",permalink:"/docs/developers/starlark/types",draft:!1,tags:[],version:"current",frontMatter:{id:"types"},sidebar:"mainSidebar",previous:{title:"Starlark Language Specification",permalink:"/docs/developers/starlark/spec"},next:{title:"Value Representation",permalink:"/docs/developers/starlark/values"}},p={},m=[{value:"What does a type mean?",id:"what-does-a-type-mean",level:2},{value:"Record types",id:"record-types",level:2},{value:"Enum types",id:"enum-types",level:2}],d={toc:m};function s(e){let{components:n,...t}=e;return(0,i.mdx)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"starlark-types"},"Starlark Types"),(0,i.mdx)("p",null,"The Starlark 'types' extension is highly experimental and likely to be modified\nin the future."),(0,i.mdx)("p",null,"Types can be added to function arguments, or function return types."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},"def fib(i: int) -> int:\n    ...\n")),(0,i.mdx)("p",null,"There are moments where types can be checked:"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"At runtime, as a function is executed, when a value of the appropriate type\nis available."),(0,i.mdx)("li",{parentName:"ol"},"Statically, without executing anything."),(0,i.mdx)("li",{parentName:"ol"},"At compile time, when the definitions of all symbols imported using ",(0,i.mdx)("inlineCode",{parentName:"li"},"load"),"\nare available.")),(0,i.mdx)("p",null,"Currently runtime is the normal way of checking, but other systems built on\nStarlark (e.g. Buck2) may also perform additional types of checking. In all\ncases the meaning of the types is the same."),(0,i.mdx)("p",null,"The rest of this document lays out what types mean and what type-supporting\nvalues are available (records and enums)."),(0,i.mdx)("h2",{id:"what-does-a-type-mean"},"What does a type mean?"),(0,i.mdx)("p",null,"A type is a Starlark expression that has a meaning as a type:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"When ",(0,i.mdx)("inlineCode",{parentName:"li"},"fib(3)")," is called, the ",(0,i.mdx)("em",{parentName:"li"},"value")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"3")," is passed to ",(0,i.mdx)("inlineCode",{parentName:"li"},"fib")," as parameter ",(0,i.mdx)("inlineCode",{parentName:"li"},"i"),"."),(0,i.mdx)("li",{parentName:"ul"},"When the execution of ",(0,i.mdx)("inlineCode",{parentName:"li"},"fib")," is started, the ",(0,i.mdx)("em",{parentName:"li"},"expression")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"int")," is evaluated to\nthe value of the ",(0,i.mdx)("inlineCode",{parentName:"li"},"int")," function."),(0,i.mdx)("li",{parentName:"ul"},"A check is then made that the value ",(0,i.mdx)("inlineCode",{parentName:"li"},"3")," matches the type represented by ",(0,i.mdx)("inlineCode",{parentName:"li"},"int"),".")),(0,i.mdx)("p",null,"If the value doesn't match, it is a runtime error. Similarly, on ",(0,i.mdx)("inlineCode",{parentName:"p"},"return"),"\nstatements, or the end of the function, a check is made that result type matches\n",(0,i.mdx)("inlineCode",{parentName:"p"},"int"),"."),(0,i.mdx)("p",null,"As some examples of types:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},"typing.Any")," matches any value, with no restrictions."),(0,i.mdx)("li",{parentName:"ul"},"The types ",(0,i.mdx)("inlineCode",{parentName:"li"},"int"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"bool"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"str")," all represent the values produced by the\nrespective functions."),(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},"None")," represents the value ",(0,i.mdx)("inlineCode",{parentName:"li"},"None"),"."),(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},"list[int]")," represents a list of ",(0,i.mdx)("inlineCode",{parentName:"li"},"int")," types, e.g. ",(0,i.mdx)("inlineCode",{parentName:"li"},"list[typing.Any]"),"\nrepresents a list containing any types."),(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},"dict[int, bool]")," represents a dictionary with ",(0,i.mdx)("inlineCode",{parentName:"li"},"int")," keys and ",(0,i.mdx)("inlineCode",{parentName:"li"},"bool"),"\nvalues."),(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},"tuple[int, bool, str]")," represents a tuple of arity 3 with components\nbeing ",(0,i.mdx)("inlineCode",{parentName:"li"},"int"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"bool")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"str"),"."),(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},"tuple[int, ...]")," represents a tuple of unknown arity where all the\ncomponents are of type ",(0,i.mdx)("inlineCode",{parentName:"li"},"int"),"."),(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},"int | bool")," represents a value that is either an ",(0,i.mdx)("inlineCode",{parentName:"li"},"int")," or a ",(0,i.mdx)("inlineCode",{parentName:"li"},"bool"),"."),(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},"typing.Callable")," represents something that can be called as a\nfunction."),(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},"typing.Iterable")," represents something that can be iterated on."),(0,i.mdx)("li",{parentName:"ul"},"The type ",(0,i.mdx)("inlineCode",{parentName:"li"},"typing.Never")," represents a type with no valid values - e.g. the\nresult of ",(0,i.mdx)("inlineCode",{parentName:"li"},"fail")," is ",(0,i.mdx)("inlineCode",{parentName:"li"},"typing.Never")," as the return value of ",(0,i.mdx)("inlineCode",{parentName:"li"},"fail")," can never be\nobserved, given the program terminates.")),(0,i.mdx)("p",null,"The goals of this type system are:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Reuse the existing machinery of Starlark as much as possible, avoiding\ninventing a special class of type values. As a consequence, any optimisations\nfor values like string/list are reused."),(0,i.mdx)("li",{parentName:"ul"},"Provide a pleasing syntax."),(0,i.mdx)("li",{parentName:"ul"},"Some degree of compatibility with Python, which allows types as expressions in\nthe same places Buck2 allows them (but with different meaning and different\nchecking)."),(0,i.mdx)("li",{parentName:"ul"},"And finally, a non-goal is to provide a complete type system capable of\nrepresenting every type invariant: it's intended to be a lossy approximation.")),(0,i.mdx)("p",null,"In addition to these built-in types, records and enumerations are provided as\nspecial concepts."),(0,i.mdx)("h2",{id:"record-types"},"Record types"),(0,i.mdx)("p",null,"A ",(0,i.mdx)("inlineCode",{parentName:"p"},"record")," type represents a set of named values, each with their own type."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},"MyRecord = record(host=str, port=int)\n")),(0,i.mdx)("p",null,"This above statement defines a record ",(0,i.mdx)("inlineCode",{parentName:"p"},"MyRecord")," with 2 fields, the first named\n",(0,i.mdx)("inlineCode",{parentName:"p"},"host")," that must be of type ",(0,i.mdx)("inlineCode",{parentName:"p"},"str"),", and the second named ",(0,i.mdx)("inlineCode",{parentName:"p"},"port")," that must be of\ntype ",(0,i.mdx)("inlineCode",{parentName:"p"},"int"),"."),(0,i.mdx)("p",null,"Now ",(0,i.mdx)("inlineCode",{parentName:"p"},"MyRecord")," is defined, it's possible to do the following:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Create values of this type with ",(0,i.mdx)("inlineCode",{parentName:"li"},'MyRecord(host="localhost", port=80)'),". It is a\nruntime error if any arguments are missed, of the wrong type, or if any\nunexpected arguments are given."),(0,i.mdx)("li",{parentName:"ul"},"Get the type of the record suitable for a type annotation with ",(0,i.mdx)("inlineCode",{parentName:"li"},"MyRecord"),"."),(0,i.mdx)("li",{parentName:"ul"},"Get the fields of the record. For example,\n",(0,i.mdx)("inlineCode",{parentName:"li"},'v = MyRecord(host="localhost", port=80)')," will provide ",(0,i.mdx)("inlineCode",{parentName:"li"},'v.host == "localhost"'),"\nand ",(0,i.mdx)("inlineCode",{parentName:"li"},"v.port == 80"),". Similarly, ",(0,i.mdx)("inlineCode",{parentName:"li"},'dir(v) == ["host", "port"]'),".")),(0,i.mdx)("p",null,"It is also possible to specify default values for parameters using the ",(0,i.mdx)("inlineCode",{parentName:"p"},"field"),"\nfunction."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},"MyRecord = record(host=str, port=field(int, 80))\n")),(0,i.mdx)("p",null,"Now the ",(0,i.mdx)("inlineCode",{parentName:"p"},"port")," field can be omitted, defaulting to ",(0,i.mdx)("inlineCode",{parentName:"p"},"80")," is not present (for\nexample, ",(0,i.mdx)("inlineCode",{parentName:"p"},'MyRecord(host="localhost").port == 80'),")."),(0,i.mdx)("p",null,"Records are stored deduplicating their field names, making them more memory\nefficient than dictionaries."),(0,i.mdx)("h2",{id:"enum-types"},"Enum types"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"enum")," type represents one value picked from a set of values."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-python"},'MyEnum = enum("option1", "option2", "option3")\n')),(0,i.mdx)("p",null,"This statement defines an enumeration ",(0,i.mdx)("inlineCode",{parentName:"p"},"MyEnum")," that consists of the three values\n",(0,i.mdx)("inlineCode",{parentName:"p"},'"option1"'),", ",(0,i.mdx)("inlineCode",{parentName:"p"},'"option2"')," and ",(0,i.mdx)("inlineCode",{parentName:"p"},'"option3"'),"."),(0,i.mdx)("p",null,"Now ",(0,i.mdx)("inlineCode",{parentName:"p"},"MyEnum")," is defined, it's possible to do the following:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Create values of this type with ",(0,i.mdx)("inlineCode",{parentName:"li"},'MyEnum("option2")'),". It is a runtime error if\nthe argument is not one of the predeclared values of the enumeration."),(0,i.mdx)("li",{parentName:"ul"},"Get the type of the enum suitable for a type annotation with ",(0,i.mdx)("inlineCode",{parentName:"li"},"MyEnum"),"."),(0,i.mdx)("li",{parentName:"ul"},"Given a value of the enum (for example, ",(0,i.mdx)("inlineCode",{parentName:"li"},'v = MyEnum("option2")'),"), get the\nunderlying value ",(0,i.mdx)("inlineCode",{parentName:"li"},'v.value == "option2"')," or the index in the enumeration\n",(0,i.mdx)("inlineCode",{parentName:"li"},"v.index == 1"),"."),(0,i.mdx)("li",{parentName:"ul"},"Get a list of the values that make up the array with\n",(0,i.mdx)("inlineCode",{parentName:"li"},'MyEnum.values() == ["option1", "option2", "option3"]'),"."),(0,i.mdx)("li",{parentName:"ul"},"Treat ",(0,i.mdx)("inlineCode",{parentName:"li"},"MyEnum")," a bit like an array, with ",(0,i.mdx)("inlineCode",{parentName:"li"},"len(MyEnum) == 3"),",\n",(0,i.mdx)("inlineCode",{parentName:"li"},'MyEnum[1] == MyEnum("option2")')," and iteration over enums\n",(0,i.mdx)("inlineCode",{parentName:"li"},'[x.value for x in MyEnum] == ["option1", "option2", "option3"]'),".")),(0,i.mdx)("p",null,"Enumeration types store each value once, which are then efficiently referenced\nby enumeration values."))}s.isMDXComponent=!0}}]);