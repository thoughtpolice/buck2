"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6259],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>c,MDXProvider:()=>p,mdx:()=>g,useMDXComponents:()=>u,withMDXComponents:()=>d});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},i.apply(this,arguments)}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),d=function(e){return function(t){var n=u(t.components);return r.createElement(e,i({},t,{components:n}))}},u=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(c.Provider,{value:t},e.children)},h="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,a=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(n),p=o,h=d["".concat(a,".").concat(p)]||d[p]||f[p]||i;return n?r.createElement(h,s(s({ref:t},c),{},{components:n})):r.createElement(h,s({ref:t},c))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},50594:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(87462),o=(n(67294),n(3905));const i={},a="Digest Kinds",s={unversionedId:"rfcs/drafts/digest-kinds",id:"rfcs/drafts/digest-kinds",title:"Digest Kinds",description:"Use cases:",source:"@site/../docs/rfcs/drafts/digest-kinds.md",sourceDirName:"rfcs/drafts",slug:"/rfcs/drafts/digest-kinds",permalink:"/docs/rfcs/drafts/digest-kinds",draft:!1,tags:[],version:"current",frontMatter:{}},l={},c=[{value:"Use cases:",id:"use-cases",level:2},{value:"Proposed plan",id:"proposed-plan",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Hashes received from RE",id:"hashes-received-from-re",level:3},{value:"Hashes of files",id:"hashes-of-files",level:3},{value:"Hashes of directories",id:"hashes-of-directories",level:3}],d={toc:c};function u(e){let{components:t,...n}=e;return(0,o.mdx)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("h1",{id:"digest-kinds"},"Digest Kinds"),(0,o.mdx)("h2",{id:"use-cases"},"Use cases:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Buck2 needs to support more than just SHA1 for open-sourcing, since publicly\navailable RE providers use SHA256."),(0,o.mdx)("li",{parentName:"ul"},"Internally, we want to migrate to (potentially keyed) Blake3, and there will\nbe a transition period where we need to support both Blake3 and SHA1.")),(0,o.mdx)("h2",{id:"proposed-plan"},"Proposed plan"),(0,o.mdx)("p",null,"Make all the ways in which Buck2 ",(0,o.mdx)("em",{parentName:"p"},"ingests")," digests either configurable or\nexplicit about the type of digest they expect."),(0,o.mdx)("p",null,"Internally, we may keep track of digest types for debugging purposes, but we\nwill never compute more than one digest. It follows that we won't expose\nconfiguration for the digests we ",(0,o.mdx)("em",{parentName:"p"},"output")," (namely: to use on RE): if we only\nhave one digest for each blob, making it configurable has no utility since you\nnever have a choice about the hash to use."),(0,o.mdx)("h2",{id:"implementation"},"Implementation"),(0,o.mdx)("h3",{id:"hashes-received-from-re"},"Hashes received from RE"),(0,o.mdx)("p",null,"For interactions with RE, we'll expose two configurations (this can be on the\nCommandExecutorConfig):"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Preferred hash to use when Buck2 is doing the hashing (e.g. hashing\ndirectories)."),(0,o.mdx)("li",{parentName:"ul"},"Accepted hashes.")),(0,o.mdx)("p",null,"We'll use the format of the digests we receive from RE (in particular their\nsize) to infer what algorithm they used (remember: the RE API provides no way of\nknowing the format of a digest, it's just a string)."),(0,o.mdx)("h3",{id:"hashes-of-files"},"Hashes of files"),(0,o.mdx)("p",null,"We'll expose the hash to use via a buckconfig. Our\nthings-that-produce-hashes-of-files should either use the config to choose how\nthey hash, or fail if they cannot provide the right hash format (e.g. that'll be\ntrue of Eden I/O)."),(0,o.mdx)("h3",{id:"hashes-of-directories"},"Hashes of directories"),(0,o.mdx)("p",null,"This one gets a little tricky. Our directories currently have an implementation\nof fingerprinting that receives only the directory as input, so some refactoring\nis in order."),(0,o.mdx)("p",null,"We have two options:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Pick the hashing algorithm based on the contents of the directory (pick one\nthat's already used). Dealing with empty directories is a bit annoying."),(0,o.mdx)("li",{parentName:"ul"},"Refactor the directory implementation and have directories parameterized over\ntheir fingerprints, not their hasher.")),(0,o.mdx)("p",null,"The first one is easier but has the downside of not working with keyed Blake3\n(because you don't have a way to bring in the key), so I'm aiming for the second\nimplementation for now."))}u.isMDXComponent=!0}}]);