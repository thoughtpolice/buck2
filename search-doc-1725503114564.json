[{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/","content":"","keywords":""},{"title":"Buck2 Documentation Website Links​","type":1,"pageTitle":"Introduction","url":"/docs/#buck2-documentation-website-links","content":""},{"title":"For end users​","type":1,"pageTitle":"Introduction","url":"/docs/#for-end-users","content":"Getting Started - how to get started with using Buck2.Benefits - the benefits of using Buck2. "},{"title":"For people writing rules​","type":1,"pageTitle":"Introduction","url":"/docs/#for-people-writing-rules","content":"Writing Rules - how to write rules to support new languages.Build APIs - documentation for the APIs available when writing rules.Starlark Types - rules are written in Starlark (which is approximately Python), but our version adds types. "},{"title":"For people integrating with Buck2​","type":1,"pageTitle":"Introduction","url":"/docs/#for-people-integrating-with-buck2","content":"Extending Buck via BXL - powerful Starlark scripts for introspection of Buck2's graphs.Buck2 change detector - tools for building a CI that only builds/tests what has changed in diff/PR.Buck2 GitHub actions installer - script to make GitHub CI with Buck2 easier.Reindeer - a set of tools for importing Rust crates from crates.io, git repos etc and generating a BUCK file for using them.ocaml-scripts - scripts to generate a BUCK file enabling the use of OCaml packages from an OPAM switch.Buckle - a launcher for Buck2 on a per-project basis. Enables a project or team to do seamless upgrades of their build system tooling. "},{"title":"External articles about Buck2​","type":1,"pageTitle":"Introduction","url":"/docs/#external-articles-about-buck2","content":"Introducing Buck2 - our initial introduction when we open sourced Buck2.Reddit AMAwhere the Buck2 team answered a number of questions.Using buck to build Rust projects - working through an initial small Rust project, bySteve Klabnik. Followed up bybuilding from crates.ioand updating Buck2.Awesome Buck2 is a collection of resources about Buck2.Buck2 Unboxing is a general review of Buck2 by Son Luong Ngoc.A tour around Buck2 gives an overview of Buck2 and how it differs from Bazel. "},{"title":"External videos about Buck2​","type":1,"pageTitle":"Introduction","url":"/docs/#external-videos-about-buck2","content":"Accelerating builds with Buck2Neil talks about why Buck2 is fast.Buck2: optimizations &amp; dynamic dependenciesNeil and Chris talk about why Buck2 is fast and some of the advanced dependency features.Building Erlang with Buck2Andreas talks about building WhatsApp with Buck2.antlir2: Deterministic image bulids with Buck2talks about layering a packaging system over Buck2. "},{"title":"External projects using Buck2​","type":1,"pageTitle":"Introduction","url":"/docs/#external-projects-using-buck2","content":"System Initiative build their DevOps productusing Buck2, with their own custom prelude.Rust cxx library has examples and tests with a wide variety of build systems, including Buck2.ocamlrep library allows for interop between OCaml and Rust code, and can bebuilt with Buck2.buck2-nix is an experiment to integrate Buck2, Sapling andNix together in a harmonious way. Feel free tosend a PR adding your project. "},{"title":"Benefits When Compared to Buck1","type":0,"sectionRef":"#","url":"/docs/about/benefits/compared_to_buck1/","content":"","keywords":""},{"title":"Benefits for end users​","type":1,"pageTitle":"Benefits When Compared to Buck1","url":"/docs/about/benefits/compared_to_buck1/#benefits-for-end-users","content":"&quot;buck2 build SOME_TARGET_I_ALREADY_BUILT_BEFORE is basically instantaneous and is a super delightful experience. 🙂&quot; - End user experience &quot;Buck2 is largely faster and more memory efficient than buck1, and where I’ve seen counter-examples, the buck2 team quickly optimizes and fixes that.🙂&quot; - Software Engineer feedback For people who use Buck on a daily basis (such as using Buck build as part of their development inner loop), switching to Buck2 provides the following benefits: Performance - the performance of Buck2 is better in four ways: Fast things are fast - in Buck1, simply typing buck build when there is nothing to do can be expensive (23 seconds in some benchmarks). In Buck2, the same build action takes 0.1 seconds. Actions that should be fast are fast, which enables developers to use Buck more freely, without trying to work around the build system.Slow things are faster - when there is real work to do, Buck2 is significantly closer to the critical path. Benchmarks range from 5%/10s faster for changing a header file (lots of parallel C++ computations, Buck1 already nearly at the critical path) to 42%/145s faster (changing a Thrift file in a large project).Users contribute to the shared cache - with Buck1, only trusted CI builds write to the network cache, while with Buck2 everyone writes to the cache through sandboxed remote execution. This increases the chance of cache hits, saving capacity and time.CI builds go faster - these numbers vary day by day, but most projects are 2-4x faster. This means spending less time waiting for CI and saving some capacity at the same time. Correctness - in Buck2, rules are hermetic by default. Missing dependencies are errors. These restrictions apply to both the user-writtenBUCK files and the language rules. During the process of migrating to Buck2, a huge number of missing dependencies have been fixed. However, during the same process, several Buck1 issues were identified that are not going to be fixed in Buck1 (such as missing headers, genrules without dependencies, and OCaml rules don’t track all deps). The end result is that Buck2 gives the right answer more often, cutting down on user surprises. Rule features - the rules in Buck2, especially for less commonly used languages (such as Haskell, OCaml, and Rust) support features above and beyond those in Buck1. Examples: dependencies can be given as arguments toprebuilt_ocaml_library, Haskell enables the use of stub headers from C++, and Rust has experimental pipelining support. Actively developed - the Meta build team is putting all its efforts behind Buck2; it's vastly easier to develop than Buck1. While Buck2 is already ahead of Buck1 in many important aspects, the difference is only going to grow with several improvements in the pipeline.Support - Meta can provide much better support to those having difficulties with Buck2 than to those using Buck1. "},{"title":"Benefits for Rule Authors​","type":1,"pageTitle":"Benefits When Compared to Buck1","url":"/docs/about/benefits/compared_to_buck1/#benefits-for-rule-authors","content":"If you write language-specific rules, then Buck2 is in a different league to Buck1. &quot;This is all rather fun! Buck2 rules are so much more hackable than Buck1.&quot; - Software Engineer feedback There are a number of reasons why Buck2 excels for Rule Authors: Faster developer cycle - in Buck1, the time from changing a rule to seeing the impact is many minutes: you first have to compile Buck1, invalidate the dependency cache (and so on), and perhaps work between multiple OSs. With Buck2, it takes seconds, you don’t even need to restart the daemon.Simple API - Buck2 rules use a small and documented Starlark API, which is dependency-correct by construction. In Buck1, the rules must obey a lot of subtle side conditions with a much larger API.Easier deployment - for Buck2, deployment is just checking the rules in, with an atomic commit changing associated macros (when required). For Buck1, you have to make the repo work with the old and new rules and wait for a Buck version bump to ship your changes, perhaps a few days later.Low barrier to entry - writing rules in Buck2 is vastly easier than Buck1, significantly increasing the developer pool. This means that writing rules is now accessible to language experts, not just Buck experts. "},{"title":"Benefits for Integrators​","type":1,"pageTitle":"Benefits When Compared to Buck1","url":"/docs/about/benefits/compared_to_buck1/#benefits-for-integrators","content":"For those people who integrate Buck2 into larger systems, in addition to many of the above benefits apply, Buck2 provides the following benefits: Faster queries - many integrators make extensive use of buck uquery andcquery. In Buck2, these commands are faster and use less memory. For example, on CI target determination (a bunch of targets/queries), Buck2 is 25% faster at P50 (moving to 40% faster at P95) with 25% less memory (saving over 20Gb, and crossing below the 64Gb threshold). Profiling - Buck2 already ships with five types of profiling for both loading and analysis (flame graphs, statement breakdown, heap profiles etc). With Buck2, these tools are much more easily accessible to people not on the Build Infra team. "},{"title":"The downside​","type":1,"pageTitle":"Benefits When Compared to Buck1","url":"/docs/about/benefits/compared_to_buck1/#the-downside","content":"While there are many benefits, it would be remiss not to include a small list of temporary issues: Stability - Buck2 is under active development, which means the risk of regression is correspondingly higher. There may be issues, but they will be fixed as quickly as possible (and lessons learned) through the through Meta's SEV-review process.Corner cases - Buck1 has been battle-tested for nearly a decade, which has included attention to events such as error messages in unlikely corner cases. Only time and user feedback will enable Meta to bring Buck2 to the same level. Please share all such feedback! "},{"title":"Bootstrapping Buck2","type":0,"sectionRef":"#","url":"/docs/about/bootstrapping/","content":"Bootstrapping Buck2 To generate BUCK files for buck2's dependencies, we usereindeer. Note that the resulting binary will be compiled without optimisations orjemalloc, so we recommend using the Cargo-produced binary in further development. First, install reindeer with Cargo: cargo install --locked --git https://github.com/facebookincubator/reindeer reindeer Next, run the following to buckify dependencies: cd buck2/ reindeer --third-party-dir shim/third-party/rust buckify Build buck2 with buck2: buck2 build //:buck2 ","keywords":""},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/about/getting_started/","content":"","keywords":""},{"title":"Installing Buck2​","type":1,"pageTitle":"Getting Started","url":"/docs/about/getting_started/#installing-buck2","content":"The latest set of buck2 executables can be found under thelatest release page. Additionally, for each bi-monthly release there is adotslash file that is appropriate for checkin to a repository. This will automatically fetch the correct version and architecture for each user, and ensures a consistent build environment for each commit in the repo. To get started, first install rustup, then compile thebuck2 executable: rustup install nightly-2024-06-08 cargo +nightly-2024-06-08 install --git https://github.com/facebook/buck2.git buck2  The above commands install buck2 into a suitable directory, such as$HOME/.cargo/bin, which you should then add to your $PATH: Linux / macOS export PATH=$HOME/.cargo/bin:$PATH  Windows Powershell $Env:PATH += &quot;;$HOME\\.cargo\\bin&quot;  With Buck2 installed, you can build projects with buck2! "},{"title":"Windows configuration​","type":1,"pageTitle":"Getting Started","url":"/docs/about/getting_started/#windows-configuration","content":"Some of our rules use symlinks, which are disabled by default for non-admin Windows users. You can fix that byenabling Developer Mode. "},{"title":"Compiling your first project​","type":1,"pageTitle":"Getting Started","url":"/docs/about/getting_started/#compiling-your-first-project","content":"This section covers the building of a'hello_world' example projectthat contains a simple C++ binary. If you are interested in seeing how other languages can be built, take a look at theprelude example project, which contains Rust, C++, Python, and OCaml targets. First, clone the buck2 repository and cd into the 'hello_world' project: git clone https://github.com/facebook/buck2.git cd buck2/examples/hello_world  buck2 init --git is all the setup you need to start building. This will use git submodule to pull buck2-preludeinto your project: buck2 init --git  To use another version control system, run buck2 init and manually downloadbuck2-prelude into prelude at root. buck2 init  To build the entire project, run: Note: Requires clang and lld to be in the path buck2 build //...  Note that this uses asimple C++ toolchainthat requires a recent version of clang to be installed on your system. This can be installed with any package manager (ex. apt install clang,xcode-select --install on macOS, choco install llvm). After installing any external tools or changing your PATH, run buck2 kill before running a build. To list all targets available in the project, run: buck2 targets //...  To run the main C++ binary, run: buck2 run //:main  The newly built binary can be found with the --show-output flag: buck2 build //:main --show-output  Output: Build ID: 0e890477-5b7f-4829-9ffe-662e572320a0 Jobs completed: 3. Time elapsed: 0.0s. BUILD SUCCEEDED root//:main buck-out/v2/gen/root/9f4d83578bb24895/__main__/main  "},{"title":"Creating your first hello_world project​","type":1,"pageTitle":"Getting Started","url":"/docs/about/getting_started/#creating-your-first-hello_world-project","content":"This section demonstrates how to create a simple C++ 'hello_world' project. To get started, make a new folder for your project and cd into it. mkdir hello_world cd hello_world  Next, run buck2 init --git to initialize the project. This command will set up your project with git and pull inbuck2-prelude as a submodule. Additionally, it will generate multiple files with default values. buck2 init --git  Next, add the source code main.cpp , #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello from a C++ Buck2 program!&quot; &lt;&lt; std::endl; }  Then, define a cxx_binary in the root BUCK file: # BUCK cxx_binary( name = &quot;main&quot;, srcs = [&quot;main.cpp&quot;], link_style = &quot;static&quot;, )  If you try to build //:main at this point, you'll see an error about buck2not being able to find toolchains//:cxx. The final step is to define the necessary toolchain targets. For that project, you need system_cxx_toolchain and system_python_bootstrap_toolchain, which will pick up the necessary tools (clang++, python, and so on) from the system. # toolchains/BUCK load(&quot;@prelude//toolchains:cxx.bzl&quot;, &quot;system_cxx_toolchain&quot;) load(&quot;@prelude//toolchains:python.bzl&quot;, &quot;system_python_bootstrap_toolchain&quot;) system_cxx_toolchain( name = &quot;cxx&quot;, visibility = [&quot;PUBLIC&quot;], ) system_python_bootstrap_toolchain( name = &quot;python_bootstrap&quot;, visibility = [&quot;PUBLIC&quot;], )  At this point, your project should have the following files: $ tree -a -I &quot;buck-out|prelude|.git&quot; |-- .buckconfig |-- .gitmodules |-- BUCK |-- main.cpp `-- toolchains `-- BUCK  Now, you're ready to see the build in action. To build the main C++ target, run: buck2 build //:main  To run the main C++ target, run: buck2 run //:main  In summary, a buck2 project requires: A .buckconfig file in the root which has a [cells] section listing outcellsA prelude directory, which contains a collection ofrules of your choice.buck2 init will pull in thebuck2-prelude as a git submodule by defaultIf using the buck2-prelude, a toolchains directory that declares relevant toolchains. We provide some basic toolchains inprelude/toolchainsBUCK files that specify targets for your project buck2 init --git will generate all of these with reasonable default values. "},{"title":"Learning More​","type":1,"pageTitle":"Getting Started","url":"/docs/about/getting_started/#learning-more","content":"You should now be ready to explore Buck2 for use in your own projects. You can explore the examplesfolder. Look out for more tutorials in the future. "},{"title":"APIs","type":0,"sectionRef":"#","url":"/docs/api/","content":"APIs A lot of Buck2 is driven by Starlark APIs. While there is aStarlark specification, for most purposes it can be considered a subset of Python. There are three main places you can write Starlark in Buck2: In BUCK files, where you can define the rules. The most interesting functions are the rules themselves, but you will often use the builtin Starlark functions (most of which are the same as in Python), and a few of the build functions (e.g.glob).In rule definitions, where you can use the same Starlark standard functions, but will heavily be using the build functions (e.g. ruleand attrs).In BXL, where the context type is one of the more important ones.","keywords":""},{"title":"Why Buck2","type":0,"sectionRef":"#","url":"/docs/about/why/","content":"","keywords":""},{"title":"Why does Buck2 exist?​","type":1,"pageTitle":"Why Buck2","url":"/docs/about/why/#why-does-buck2-exist","content":"Meta employs a very large monorepo, consisting of a variety of programming languages, including C++, Python, Rust, Kotlin, Swift, Objective-C, Haskell, OCaml, and more. Google employs a different but functionally similar monorepo. These large scale and multi-language repositories are generally beyond the capabilities of traditional build systems like make. To optimize the build and performance of these large systems, Facebook and Google developed their own build systems, respectively Buck and Bazel. While the internal version of Bazel was started first (also known as Blaze), Buck was open sourced first (back in March 2013), followed by Bazel a few years later (March 2015). The retroactively named Buck1 was a capable build system and is still in use today at Meta (although many users have migrated). Buck2 is a rewrite that aims to keep the best bits of Buck1 (with a high degree of target compatibility) but also borrows ideas from academicresearch and build systems, including Bazel, Pants,Shake, Tup, and more. Following are aspects common to Buck1 and Buck2 (and in most cases, Bazel): Targets that can be queried - the build is defined as a series of targets, specified in BUCK files, that depend on other targets. This graph of targets can be queried to understand how they relate to each other and what the potential impact of a change might be.Remote execution - the build can send actions to a set of remote servers to be executed, increasing the parallelism significantly.Multi-language composability - there can be lots of different languages in a single build, and they can be put together. For example, you could have a Python library that depends on a Rust library, which, in turn depends on a C library.File watching - at large enough scale, simply looking for changed files is prohibitively expensive. Buck can integrate withWatchman to discover which files have changed efficiently. However, for simplicity of setup, the open-source version defaults to using inotify or similar functionality.Uses Starlark - Starlark is a deterministic Python-like language used to specify the targets, enabling the definition of targets as literals and more advanced manipulation/sharing. "},{"title":"What's different about Buck2?​","type":1,"pageTitle":"Why Buck2","url":"/docs/about/why/#whats-different-about-buck2","content":"Buck2 has many minor differences from Buck1, but there are a number that give new efficiency or expressiveness that are of note (most of these are also different from Bazel). Buck2 is written in Rust - Buck1 was written in Java. One of the advantages of using Rust is the absence of GC pauses, However, Java also has advantages, such as better memory profiling tools.Buck2 is remote execution first - local execution is considered a special case of remote execution, in contrast to Buck1 where it was added after. That means that things such as directory hashes can be pre-computed ready to send to remote execution, giving efficiency benefits.All Buck2 rules are written in Starlark - whereas, in Buck1, they were written in Java as part of the binary, which makes iteration on rules much faster.The Buck2 binary is entirely language agnostic - as a consequence of having all the rules external to the binary, the most important and complex rule (such as in C++), don't have access to magic internal features. As a result, features have been made available to all rules, including: Dep files - the ability to declare that a subset of the files weren't actually used, and thus not be sensitive to changes within them.Incremental actions - the ability to have the action short-circuit some subset of the work if run again. Buck2 uses a dynamic (aka monadic) graph as its underlying computation engine - while most dependencies are specified statically, there are two particular features that expose dynamic power to rule authors: Dynamic dependencies - enable rules to build a file then look at its contents before specifying the dependencies and steps in future actions. Common uses are languages where the dependency structure within a project must follow imports (e.g. Haskell, OCaml) and distributed ThinLTO (where the best optimization plan is generated from summaries).Anonymous targets - enable rules to create a graph that has more sharing than the original user graph. As a result, two unrelated binaries can compile shared code only once, despite the shared code not knowing about this commonality. This feature is useful for rules like Swift feature resolution. Transitive-sets - similar in purpose to Bazel's depset. But, instead of being just a memory optimization, are also wired into the dependency graph, providing a reduction in the size of the dependency graph.Buck2 is not phased - there are no target graph/action graph phases, just a series of dependencies in asingle graph on DICEthat result in whatever the user requested. That means that Buck2 can sometimes parallelise different phases and track changes very precisely.Buck2 can integrate with the virtual filesystemEden - this provides good performance, even when the file system is backed by source control fetches. However, Eden is not required, and a normal file system will also work well.The Buck2 Starlark implementation is availableas a standalone library - this provides features such as IDE integration (both LSP and DAP bindings), linters, typecheckers, and more. These features are integrated into Buck2 to give a better developer experience (which is still evolving).Buck2 supports configurations - (such as select) to provide multi-platform/architecture builds, which are heavily inspired by Bazel. Within that space, there is a number of small differences, such astoolchain_deps.Buck2 is fast - in our internal tests, we observed that Buck2 completed builds 2x as fast as Buck1. For a comprehensive list of benefits, seeBenefits Compared to Buck1. "},{"title":"Why use Buck2?​","type":1,"pageTitle":"Why Buck2","url":"/docs/about/why/#why-use-buck2","content":"It would be delightful if you tried out Buck2! But it is early-stage software, so users may run into unexpected issues. If you encounter an issue, please report it via Github issues. Buck2 is being used internally within Meta and is available as open-source from 2023. There are several differences between the internal and open-source versions: Meta uses an internal version of remote execution with builds always hooked up to remote execution. The open-source binding, which uses Buck2 without remote execution, may be less polished.There are some configuration differences between the open source and internal versions. For example, file changes default to inotify in open-source, and to Watchman internally.The prelude (containing all the rules) is the same for open-source as internal, but toolchains are not open-sourced. The required custom toolchains may not work as well. There are also some things that aren't quite yet finished: There are not yet mechanisms to build in release mode (that should be achieved by modifying the toolchain).Windows/Mac builds are still in progress; open-source code is mostly tested on Linux. If none of that puts you off, give Buck2 a go! "},{"title":"ActionErrorCtx type","type":0,"sectionRef":"#","url":"/docs/api/build/ActionErrorCtx/","content":"","keywords":""},{"title":"ActionErrorCtx.new_error_location​","type":1,"pageTitle":"ActionErrorCtx type","url":"/docs/api/build/ActionErrorCtx/#actionerrorctxnew_error_location","content":"def ActionErrorCtx.new_error_location( *, file: str, line: None | int = None ) -&gt; ActionErrorLocation  Create a new error location, specifying a file path and an optional line number. The file path should be either a project-relative path, or an absolute path.  "},{"title":"ActionErrorCtx.new_sub_error​","type":1,"pageTitle":"ActionErrorCtx type","url":"/docs/api/build/ActionErrorCtx/#actionerrorctxnew_sub_error","content":"def ActionErrorCtx.new_sub_error( *, category: str, message: None | str = None, locations: None | list[ActionErrorLocation] | tuple[ActionErrorLocation, ...] = None ) -&gt; ActionSubError  Create a new sub error, specifying an error category name, optional message, and an optional list of error locations. The category should be finer grain error categorizations provided by the rule authors, and tend to be language specific. These should not be any kind of shared concepts among all errors for all languages/rules. For example, timeouts and infra errors should not go here - buck2 tries to categorize these types of errors automatically. An example of a finer grain error category may be the error code for rustc outputs. The message will be emitted to the build report, and to the stderr in the error diagnostics section.  "},{"title":"ActionErrorCtx.stderr​","type":1,"pageTitle":"ActionErrorCtx type","url":"/docs/api/build/ActionErrorCtx/#actionerrorctxstderr","content":"ActionErrorCtx.stderr: str  The stderr of the failed action.  "},{"title":"ActionErrorCtx.stdout​","type":1,"pageTitle":"ActionErrorCtx type","url":"/docs/api/build/ActionErrorCtx/#actionerrorctxstdout","content":"ActionErrorCtx.stdout: str  The stdout of the failed action. "},{"title":"ActionSubError type","type":0,"sectionRef":"#","url":"/docs/api/build/ActionSubError/","content":"","keywords":""},{"title":"ActionSubError.category​","type":1,"pageTitle":"ActionSubError type","url":"/docs/api/build/ActionSubError/#actionsuberrorcategory","content":"ActionSubError.category: str  The category name of this sub error. This function is only needed for action error handler unit testing.  "},{"title":"ActionSubError.locations​","type":1,"pageTitle":"ActionSubError type","url":"/docs/api/build/ActionSubError/#actionsuberrorlocations","content":"ActionSubError.locations: None | list[ActionErrorLocation]  Any locations associated with this sub error. This function is only needed for action error handler unit testing.  "},{"title":"ActionSubError.message​","type":1,"pageTitle":"ActionSubError type","url":"/docs/api/build/ActionSubError/#actionsuberrormessage","content":"ActionSubError.message: None | str  The optional message associated with this sub error. This function is only needed for action error handler unit testing. "},{"title":"ActionErrorLocation type","type":0,"sectionRef":"#","url":"/docs/api/build/ActionErrorLocation/","content":"","keywords":""},{"title":"ActionErrorLocation.file​","type":1,"pageTitle":"ActionErrorLocation type","url":"/docs/api/build/ActionErrorLocation/#actionerrorlocationfile","content":"ActionErrorLocation.file: str  The file of the error location. This is only needed for action error handler unit testing.  "},{"title":"ActionErrorLocation.line​","type":1,"pageTitle":"ActionErrorLocation type","url":"/docs/api/build/ActionErrorLocation/#actionerrorlocationline","content":"ActionErrorLocation.line: None | int  The line of the error location. This is only needed for action error handler unit testing. "},{"title":"anon_targets type","type":0,"sectionRef":"#","url":"/docs/api/build/anon_targets/","content":"","keywords":""},{"title":"anon_targets.anon_targets​","type":1,"pageTitle":"anon_targets type","url":"/docs/api/build/anon_targets/#anon_targetsanon_targets","content":"anon_targets.anon_targets: typing.Any  Returns a list of StarlarkAnonTargets.  "},{"title":"anon_targets.promise​","type":1,"pageTitle":"anon_targets type","url":"/docs/api/build/anon_targets/#anon_targetspromise","content":"anon_targets.promise: promise  Returns the promise that maps to the result of the joined anon rules. "},{"title":"anon_target type","type":0,"sectionRef":"#","url":"/docs/api/build/anon_target/","content":"","keywords":""},{"title":"anon_target.artifact​","type":1,"pageTitle":"anon_target type","url":"/docs/api/build/anon_target/#anon_targetartifact","content":"def anon_target.artifact(name: str)  Gets a specific StarlarkPromiseArtifact by name. Returns an error if the name was not found in the registered promise artifacts for the anon target.  "},{"title":"anon_target.artifacts​","type":1,"pageTitle":"anon_target type","url":"/docs/api/build/anon_target/#anon_targetartifacts","content":"def anon_target.artifacts()  Returns a dict where the key is the promise artifact's name, and the value is the StarlarkPromiseArtifact. To get a promise artifact where the short path is accessible, call ctx.actions.assert_short_path(...) and pass in the artifact retrieved from this dict.  "},{"title":"anon_target.promise​","type":1,"pageTitle":"anon_target type","url":"/docs/api/build/anon_target/#anon_targetpromise","content":"anon_target.promise: promise  Returns the promise that maps to the result of the anon rule. "},{"title":"buck_regex type","type":0,"sectionRef":"#","url":"/docs/api/build/buck_regex/","content":"","keywords":""},{"title":"buck_regex.match​","type":1,"pageTitle":"buck_regex type","url":"/docs/api/build/buck_regex/#buck_regexmatch","content":"def buck_regex.match(str: str, /) -&gt; bool  "},{"title":"artifact type","type":0,"sectionRef":"#","url":"/docs/api/build/artifact/","content":"","keywords":""},{"title":"artifact.as_output​","type":1,"pageTitle":"artifact type","url":"/docs/api/build/artifact/#artifactas_output","content":"def artifact.as_output() -&gt; output_artifact  Returns a StarlarkOutputArtifact instance, or fails if the artifact is either an Artifact, or is a bound Artifact (You cannot bind twice)  "},{"title":"artifact.basename​","type":1,"pageTitle":"artifact type","url":"/docs/api/build/artifact/#artifactbasename","content":"artifact.basename: str  The base name of this artifact. e.g. for an artifact at foo/bar, this is bar  "},{"title":"artifact.extension​","type":1,"pageTitle":"artifact type","url":"/docs/api/build/artifact/#artifactextension","content":"artifact.extension: str  The file extension of this artifact. e.g. for an artifact at foo/bar.sh, this is .sh. If no extension is present, &quot;&quot; is returned.  "},{"title":"artifact.is_source​","type":1,"pageTitle":"artifact type","url":"/docs/api/build/artifact/#artifactis_source","content":"artifact.is_source: bool  Whether the artifact represents a source file  "},{"title":"artifact.owner​","type":1,"pageTitle":"artifact type","url":"/docs/api/build/artifact/#artifactowner","content":"artifact.owner: None | label  The Label of the rule that originally created this artifact. May also be None in the case of source files, or if the artifact has not be used in an action, or if the action was not created by a rule.  "},{"title":"artifact.project​","type":1,"pageTitle":"artifact type","url":"/docs/api/build/artifact/#artifactproject","content":"def artifact.project( path: str, /, *, hide_prefix: bool = False ) -&gt; artifact  Create an artifact that lives at path relative from this artifact. For example, if artifact foo is a directory containing a file bar, then foo.project(&quot;bar&quot;)yields the file bar. It is possible for projected artifacts to hide the prefix in order to have the short name of the resulting artifact only contain the projected path, by passinghide_prefix = True to project().  "},{"title":"artifact.short_path​","type":1,"pageTitle":"artifact type","url":"/docs/api/build/artifact/#artifactshort_path","content":"artifact.short_path: str  The interesting part of the path, relative to somewhere in the output directory. For an artifact declared as foo/bar, this is foo/bar.  "},{"title":"artifact.with_associated_artifacts​","type":1,"pageTitle":"artifact type","url":"/docs/api/build/artifact/#artifactwith_associated_artifacts","content":"def artifact.with_associated_artifacts(artifacts: list[artifact]) -&gt; artifact  Returns a StarlarkArtifact instance which is identical to the original artifact, but with potentially additional artifacts. The artifacts must be bound.  "},{"title":"artifact.without_associated_artifacts​","type":1,"pageTitle":"artifact type","url":"/docs/api/build/artifact/#artifactwithout_associated_artifacts","content":"def artifact.without_associated_artifacts() -&gt; artifact  Returns a StarlarkArtifact instance which is identical to the original artifact, except with no associated artifacts "},{"title":"cmd_args type","type":0,"sectionRef":"#","url":"/docs/api/build/cmd_args/","content":"","keywords":""},{"title":"cmd_args.add​","type":1,"pageTitle":"cmd_args type","url":"/docs/api/build/cmd_args/#cmd_argsadd","content":"def cmd_args.add(*args) -&gt; cmd_args  A list of arguments to be added to the command line, which may including cmd_args, artifacts, strings, RunInfo or lists thereof. Note that this operation mutates the input cmd_args.  "},{"title":"cmd_args.copy​","type":1,"pageTitle":"cmd_args type","url":"/docs/api/build/cmd_args/#cmd_argscopy","content":"def cmd_args.copy() -&gt; cmd_args  Returns a copy of the cmd_args such that any modifications to the original or the returned value will not impact each other. Note that this is a shallow copy, so any inner cmd_args can still be modified.  "},{"title":"cmd_args.inputs​","type":1,"pageTitle":"cmd_args type","url":"/docs/api/build/cmd_args/#cmd_argsinputs","content":"cmd_args.inputs: command_line_inputs  Collect all the inputs (including hidden) referenced by this command line. The output can be compared for equality and have its len requested to see whether there are any inputs, but is otherwise mostly opaque.  "},{"title":"cmd_args.outputs​","type":1,"pageTitle":"cmd_args type","url":"/docs/api/build/cmd_args/#cmd_argsoutputs","content":"cmd_args.outputs: list[output_artifact]  Collect all the outputs (including hidden) referenced by this command line.  "},{"title":"cmd_args.relative_to​","type":1,"pageTitle":"cmd_args type","url":"/docs/api/build/cmd_args/#cmd_argsrelative_to","content":"def cmd_args.relative_to( directory: artifact | cell_root | project_root, /, *, parent: int = _ ) -&gt; cmd_args  Make all artifact paths relative to a given location. Typically used when the command you are running changes directory. By default, the paths are relative to the artifacts themselves (equivalent toparent = 0). Use parent to make the paths relative to an ancestor directory. For example parent = 1 would make all paths relative to the containing dirs of any artifacts in the cmd_args. dir = symlinked_dir(...) script = [ cmd_args(cmd_args(dir, format = &quot;cd {}&quot;), original_script.relative_to(dir) ]  "},{"title":"context type","type":0,"sectionRef":"#","url":"/docs/api/build/context/","content":"","keywords":""},{"title":"context.actions​","type":1,"pageTitle":"context type","url":"/docs/api/build/context/#contextactions","content":"context.actions: actions  Returns an actions value containing functions to define actual actions that are run. See the actions type for the operations that are available.  "},{"title":"context.attrs​","type":1,"pageTitle":"context type","url":"/docs/api/build/context/#contextattrs","content":"context.attrs: struct(..)  Returns the attributes of the target as a Starlark struct with a field for each attribute, which varies per rule. As an example, given a rule with the attrs argument of {&quot;foo&quot;: attrs.string()}, this field will be a struct containing a field foo of type string.  "},{"title":"context.label​","type":1,"pageTitle":"context type","url":"/docs/api/build/context/#contextlabel","content":"context.label: None | label  Returns a label representing the target, or None if being invoked from a dynamic_output in Bxl.  "},{"title":"context.plugins​","type":1,"pageTitle":"context type","url":"/docs/api/build/context/#contextplugins","content":"context.plugins: AnalysisPlugins  An opaque value that can be indexed with a plugin kind to get a list of the available plugin deps of that kind. The rule must set an appropriate value on uses_plugins in its declaration. "},{"title":"configured_target_label type","type":0,"sectionRef":"#","url":"/docs/api/build/configured_target_label/","content":"","keywords":""},{"title":"configured_target_label.cell​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/build/configured_target_label/#configured_target_labelcell","content":"configured_target_label.cell: str   "},{"title":"configured_target_label.config​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/build/configured_target_label/#configured_target_labelconfig","content":"def configured_target_label.config() -&gt; configuration   "},{"title":"configured_target_label.name​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/build/configured_target_label/#configured_target_labelname","content":"configured_target_label.name: str   "},{"title":"configured_target_label.package​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/build/configured_target_label/#configured_target_labelpackage","content":"configured_target_label.package: str   "},{"title":"configured_target_label.path​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/build/configured_target_label/#configured_target_labelpath","content":"configured_target_label.path: label_relative_path   "},{"title":"configured_target_label.raw_target​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/build/configured_target_label/#configured_target_labelraw_target","content":"def configured_target_label.raw_target() -&gt; target_label  Returns the unconfigured underlying target label.  "},{"title":"configured_target_label.with_sub_target​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/build/configured_target_label/#configured_target_labelwith_sub_target","content":"def configured_target_label.with_sub_target( subtarget_name: str | list[str] = _ ) -&gt; label  Converts a ConfiguredTargetLabel into its corresponding Label given the subtarget name which is a list for each layer of subtarget Sample usage: def _impl_sub_target(ctx): owners = ctx.cquery().owner(&quot;bin/TARGETS.fixture&quot;) for owner in owners: configured_label = owner.label ctx.output.print(configured_label.with_sub_target()) ctx.output.print(configured_label.with_sub_target(&quot;subtarget1&quot;)) ctx.output.print(configured_label.with_sub_target([&quot;subtarget1&quot;, &quot;subtarget2&quot;]))  "},{"title":"attrs type","type":0,"sectionRef":"#","url":"/docs/api/build/attrs/","content":"","keywords":""},{"title":"attrs.any​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsany","content":"def attrs.any(*, doc: str = &quot;&quot;, default = _) -&gt; attribute  Takes most builtin literals and passes them to the rule as a string. Discouraged, as it provides little type safety and destroys the structure.  "},{"title":"attrs.arg​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsarg","content":"def attrs.arg( *, json: bool = False, default = _, doc: str = &quot;&quot;, anon_target_compatible: bool = False ) -&gt; attribute  Takes a command line argument from the user and supplies a cmd_args compatible value to the rule. The argument may contain special macros such as $(location :my_target) or $(exe :my_target) which will be replaced with references to those values in the rule. Takes in an optional anon_target_compatible flag, which indicates whether the args can be passed into anon targets. Note that there is a slight memory hit when using this flag.  "},{"title":"attrs.bool​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsbool","content":"def attrs.bool(*, default = _, doc: str = &quot;&quot;) -&gt; attribute  Takes a boolean and passes it to the rule as a boolean.  "},{"title":"attrs.configuration_label​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsconfiguration_label","content":"def attrs.configuration_label(*, doc: str = &quot;&quot;) -&gt; attribute   "},{"title":"attrs.configured_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsconfigured_dep","content":"def attrs.configured_dep( *, providers: list[typing.Any] | tuple = [], default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.default_only​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsdefault_only","content":"def attrs.default_only( inner: attribute, /, *, doc: str = &quot;&quot; ) -&gt; attribute  Rejects all values and uses the default for the inner argument. Often used to resolve dependencies, which otherwise can't be resolved inside a rule. attrs.default_only(attrs.dep(default = &quot;foo//my_package:my_target&quot;))   "},{"title":"attrs.dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsdep","content":"def attrs.dep( *, providers: list[typing.Any] | tuple = [], pulls_plugins: list[typing.Any] | tuple = [], pulls_and_pushes_plugins: all_plugins | list[typing.Any] | tuple = _, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a target from the user, as a string, and supplies a dependency to the rule. A target can be specified as an absolute dependency foo//bar:baz, omitting the cell (//bar:baz) or omitting the package name (:baz). If supplied the providers argument ensures that specific providers will be present on the dependency.  "},{"title":"attrs.dict​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsdict","content":"def attrs.dict( key: attribute, value: attribute, *, sorted: bool = False, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a dict from the user, supplies a dict to the rule.  "},{"title":"attrs.enum​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsenum","content":"def attrs.enum( variants: list[str] | tuple[str, ...], /, *, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a string from one of the variants given, and gives that string to the rule. Strings are matched case-insensitively, and always passed to the rule lowercase.  "},{"title":"attrs.exec_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsexec_dep","content":"def attrs.exec_dep( *, providers: list[typing.Any] | tuple = [], default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a target from the user, as a string, and supplies a dependency to the rule. The dependency will transition to the execution platform. Use exec_dep if you plan to execute things from this dependency as part of the compilation.  "},{"title":"attrs.int​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsint","content":"def attrs.int(*, default = _, doc: str = &quot;&quot;) -&gt; attribute  Takes an int from the user, supplies an int to the rule.  "},{"title":"attrs.label​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrslabel","content":"def attrs.label(*, default = _, doc: str = &quot;&quot;) -&gt; attribute  Takes a target (as per deps) and passes a label to the rule. Validates that the target exists, but does not introduce a dependency on it.  "},{"title":"attrs.list​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrslist","content":"def attrs.list( inner: attribute, /, *, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a list from the user, supplies a list to the rule.  "},{"title":"attrs.named_set​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsnamed_set","content":"def attrs.named_set( value_type: attribute, /, *, sorted: bool = False, default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.one_of​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsone_of","content":"def attrs.one_of(*args: attribute, default = _, doc: str = &quot;&quot;) -&gt; attribute  Given a list of alternative attributes, selects the first that matches and gives that to the rule.  "},{"title":"attrs.option​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsoption","content":"def attrs.option( inner: attribute, /, *, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a value that may be None or some inner type, and passes either None or the value corresponding to the inner to the rule. Often used to make a rule optional: attrs.option(attr.string(), default = None)   "},{"title":"attrs.plugin_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsplugin_dep","content":"def attrs.plugin_dep( *, kind, default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.query​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsquery","content":"def attrs.query(*, doc: str = &quot;&quot;) -&gt; attribute   "},{"title":"attrs.regex​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsregex","content":"def attrs.regex(*, default = _, doc: str = &quot;&quot;) -&gt; attribute  Currently an alias for attrs.string.  "},{"title":"attrs.set​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsset","content":"def attrs.set( value_type: attribute, /, *, sorted: bool = False, default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.source​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrssource","content":"def attrs.source( *, allow_directory: bool = False, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a source file from the user, supplies an artifact to the rule. The source file may be specified as a literal string (representing the path within this package), or a target (which must have a DefaultInfo with a default_outputs value).  "},{"title":"attrs.split_transition_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrssplit_transition_dep","content":"def attrs.split_transition_dep( *, providers: list[typing.Any] | tuple = [], cfg, default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.string​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsstring","content":"def attrs.string( *, default = _, validate = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a string from the user, supplies a string to the rule.  "},{"title":"attrs.toolchain_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrstoolchain_dep","content":"def attrs.toolchain_dep( *, providers: list[typing.Any] | tuple = [], default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a target from the user, as a string, and supplies a dependency to the rule. The dependency will be a toolchain dependency, meaning that its execution platform dependencies will be used to select the execution platform for this rule.  "},{"title":"attrs.transition_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrstransition_dep","content":"def attrs.transition_dep( *, providers: list[typing.Any] | tuple = [], cfg, default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.tuple​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrstuple","content":"def attrs.tuple(*args: attribute, default = _, doc: str = &quot;&quot;) -&gt; attribute  Takes a tuple of values and gives a tuple to the rule.  "},{"title":"attrs.versioned​","type":1,"pageTitle":"attrs type","url":"/docs/api/build/attrs/#attrsversioned","content":"def attrs.versioned(value_type: attribute, *, doc: str = &quot;&quot;) -&gt; attribute  "},{"title":"dependency type","type":0,"sectionRef":"#","url":"/docs/api/build/dependency/","content":"","keywords":""},{"title":"dependency.get​","type":1,"pageTitle":"dependency type","url":"/docs/api/build/dependency/#dependencyget","content":"def dependency.get(index) -&gt; None | provider  Gets a provider by indexing on a ProviderCallable object. e.g. FooInfo = provider(fields=[&quot;bar&quot;]) .... collection.get(FooInfo) # None if absent, a FooInfo instance if present   "},{"title":"dependency.label​","type":1,"pageTitle":"dependency type","url":"/docs/api/build/dependency/#dependencylabel","content":"dependency.label: label   "},{"title":"dependency.providers​","type":1,"pageTitle":"dependency type","url":"/docs/api/build/dependency/#dependencyproviders","content":"dependency.providers: list[typing.Any]   "},{"title":"dependency.sub_target​","type":1,"pageTitle":"dependency type","url":"/docs/api/build/dependency/#dependencysub_target","content":"def dependency.sub_target(subtarget: str, /) -&gt; dependency  Obtain the dependency representing a subtarget. In most cases you will want to use x[DefaultInfo].sub_targets[&quot;foo&quot;] to get the providers of the subtarget, but if you need a real Dependency type (e.g. for use with ctx.action.anon_target) then use this method. "},{"title":"label_relative_path type","type":0,"sectionRef":"#","url":"/docs/api/build/label_relative_path/","content":"","keywords":""},{"title":"label_relative_path.add​","type":1,"pageTitle":"label_relative_path type","url":"/docs/api/build/label_relative_path/#label_relative_pathadd","content":"def label_relative_path.add(arg: str) -&gt; label_relative_path  "},{"title":"digest_config type","type":0,"sectionRef":"#","url":"/docs/api/build/digest_config/","content":"","keywords":""},{"title":"digest_config.allows_blake3​","type":1,"pageTitle":"digest_config type","url":"/docs/api/build/digest_config/#digest_configallows_blake3","content":"def digest_config.allows_blake3() -&gt; bool   "},{"title":"digest_config.allows_blake3_keyed​","type":1,"pageTitle":"digest_config type","url":"/docs/api/build/digest_config/#digest_configallows_blake3_keyed","content":"def digest_config.allows_blake3_keyed() -&gt; bool   "},{"title":"digest_config.allows_sha1​","type":1,"pageTitle":"digest_config type","url":"/docs/api/build/digest_config/#digest_configallows_sha1","content":"def digest_config.allows_sha1() -&gt; bool   "},{"title":"digest_config.allows_sha256​","type":1,"pageTitle":"digest_config type","url":"/docs/api/build/digest_config/#digest_configallows_sha256","content":"def digest_config.allows_sha256() -&gt; bool  "},{"title":"label type","type":0,"sectionRef":"#","url":"/docs/api/build/label/","content":"","keywords":""},{"title":"label.cell​","type":1,"pageTitle":"label type","url":"/docs/api/build/label/#labelcell","content":"label.cell: str  For the label fbcode//buck2/hello:world (ovr_config//platform/linux:x86_64-fbcode-46b26edb4b80a905) this gives back fbcode  "},{"title":"label.cell_root​","type":1,"pageTitle":"label type","url":"/docs/api/build/label/#labelcell_root","content":"label.cell_root: cell_root  Obtain a reference to this target label's cell root. This can be used as if it were an artifact in places that expect one, such as cmd_args().relative_to.  "},{"title":"label.configured_target​","type":1,"pageTitle":"label type","url":"/docs/api/build/label/#labelconfigured_target","content":"def label.configured_target() -&gt; configured_target_label  Returns the underlying configured target label, dropping the sub target  "},{"title":"label.name​","type":1,"pageTitle":"label type","url":"/docs/api/build/label/#labelname","content":"label.name: str  For the label fbcode//buck2/hello:world (ovr_config//platform/linux:x86_64-fbcode-46b26edb4b80a905) this gives back world  "},{"title":"label.package​","type":1,"pageTitle":"label type","url":"/docs/api/build/label/#labelpackage","content":"label.package: str  For the label fbcode//buck2/hello:world (ovr_config//platform/linux:x86_64-fbcode-46b26edb4b80a905) this gives back buck2/hello  "},{"title":"label.path​","type":1,"pageTitle":"label type","url":"/docs/api/build/label/#labelpath","content":"label.path: label_relative_path  For the label fbcode//buck2/hello:world (ovr_config//platform/linux:x86_64-fbcode-46b26edb4b80a905) this gives back fbcode/buck2/hello  "},{"title":"label.project_root​","type":1,"pageTitle":"label type","url":"/docs/api/build/label/#labelproject_root","content":"label.project_root: project_root  Obtain a reference to the project's root. This can be used as if it were an artifact in places that expect one, such as cmd_args().relative_to.  "},{"title":"label.raw_target​","type":1,"pageTitle":"label type","url":"/docs/api/build/label/#labelraw_target","content":"def label.raw_target() -&gt; target_label  For the label fbcode//buck2/hello:world (ovr_config//platform/linux:x86_64-fbcode-46b26edb4b80a905) this returns the unconfigured underlying target label (fbcode//buck2/hello:world)  "},{"title":"label.sub_target​","type":1,"pageTitle":"label type","url":"/docs/api/build/label/#labelsub_target","content":"label.sub_target: None | list[str]  "},{"title":"plugins type","type":0,"sectionRef":"#","url":"/docs/api/build/plugins/","content":"","keywords":""},{"title":"plugins.All​","type":1,"pageTitle":"plugins type","url":"/docs/api/build/plugins/#pluginsall","content":"plugins.All: all_plugins  A special value for use with pulls_and_pushes_plugins. This value can be passed to pulls_and_pushes_plugins on any attr.dep() to indicate that all plugin kinds from the dep should be pulled and pushed. This is useful for rules likealias. This value is not supported on uses_plugins at this time, and hence it is not useful onpulls_plugins either.  "},{"title":"plugins.PluginKind​","type":1,"pageTitle":"plugins type","url":"/docs/api/build/plugins/#pluginspluginkind","content":"plugins.PluginKind: type  Type symbol for PluginKind.  "},{"title":"plugins.kind​","type":1,"pageTitle":"plugins type","url":"/docs/api/build/plugins/#pluginskind","content":"def plugins.kind() -&gt; PluginKind  Create a new plugin kind. The value returned should always be immediately bound to a global, like MyPluginKind = plugins.kind() "},{"title":"actions type","type":0,"sectionRef":"#","url":"/docs/api/build/actions/","content":"","keywords":""},{"title":"actions.anon_target​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionsanon_target","content":"def actions.anon_target( rule: &quot;function&quot;, attrs: dict[str, typing.Any] ) -&gt; anon_target  An anonymous target is defined by the hash of its attributes, rather than its name. During analysis, rules can define and access the providers of anonymous targets before producing their own providers. Two distinct rules might ask for the same anonymous target, sharing the work it performs. For more details see https://buck2.build/docs/rule_authors/anon_targets/  "},{"title":"actions.anon_targets​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionsanon_targets","content":"def actions.anon_targets( rules: list[(&quot;function&quot;, dict[str, typing.Any])] | tuple[(&quot;function&quot;, dict[str, typing.Any]), ...] ) -&gt; anon_targets  Generate a series of anonymous targets.  "},{"title":"actions.artifact_tag​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionsartifact_tag","content":"def actions.artifact_tag() -&gt; artifact_tag  Allocate a new input tag. Used with the dep_files argument to run.  "},{"title":"actions.assert_short_path​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionsassert_short_path","content":"def actions.assert_short_path(artifact: artifact, short_path: str) -&gt; artifact  Generate a promise artifact that has short path accessible on it. The short path's correctness will be asserted during analysis time. TODO - we would prefer the API to be ctx.actions.anon_target(xxx).artifact(&quot;foo&quot;, short_path=yyy), but we cannot support this until we can get access to the AnalysisContext without passing it into this method.  "},{"title":"actions.cas_artifact​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionscas_artifact","content":"def actions.cas_artifact( output: artifact | output_artifact | str, digest: str, use_case: str, /, *, expires_after_timestamp: int, is_executable: bool = False, is_tree: bool = False, is_directory: bool = False ) -&gt; artifact  Downloads a CAS artifact to an output digest: must look like SHA1:SIZEuse_case: your RE use caseexpires_after_timestamp: must be a UNIX timestamp. Your digest's TTL must exceed this timestamp. Your build will break once the digest expires, so make sure the expiry is long enough (preferably, in years).is_executable: indicates the resulting file should be marked with executable permissionsis_tree: digest must point to a blob of typeRE.Treeis_directory: digest must point to a blob of typeRE.Directory  "},{"title":"actions.copied_dir​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionscopied_dir","content":"def actions.copied_dir( output: artifact | output_artifact | str, srcs: dict[str, artifact], / ) -&gt; artifact  Returns an artifact which is a directory containing copied files. The srcs must be a dictionary of path (as string, relative to the result directory) to the bound artifact, which will be laid out in the directory.  "},{"title":"actions.copy_dir​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionscopy_dir","content":"def actions.copy_dir( dest: artifact | output_artifact | str, src: artifact, / ) -&gt; artifact  Make a copy of a directory.  "},{"title":"actions.copy_file​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionscopy_file","content":"def actions.copy_file( dest: artifact | output_artifact | str, src: artifact, / ) -&gt; artifact  Copies the source artifact to the destination (which can be a string representing a filename or an output artifact) and returns the output artifact. The copy works for files or directories.  "},{"title":"actions.declare_output​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionsdeclare_output","content":"def actions.declare_output( prefix: str, filename: str = _, /, *, dir: bool = False ) -&gt; artifact  Returns an unbound artifact, representing where a file will go, which must be bound before analysis terminates. The usual way of binding an artifact is with ctx.actions.run. As an example: my_output = ctx.actions.declare_output(&quot;output.o&quot;) ctx.actions.run([&quot;gcc&quot;, &quot;-c&quot;, my_source, &quot;-o&quot;, my_output.as_output()], category = &quot;compile&quot;)  This snippet declares an output with the filename output.o (it will be located in the output directory for this target). Note the use of as_output to tag this artifact as being an output in the action. After binding the artifact you can subsequently use my_output as either an input for subsequent actions, or as the result in a provider. Artifacts from a single target may not have the same name, so if you then want a second artifact also named output.o you need to supply a prefix, e.g.ctx.actions.declare_output(&quot;directory&quot;, &quot;output.o&quot;). The artifact will still report having name output.o, but will be located at directory/output.o. The dir argument should be set to True if the binding will be a directory.  "},{"title":"actions.digest_config​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionsdigest_config","content":"def actions.digest_config() -&gt; digest_config  Obtain this daemon's digest configuration. This allows rules to discover what digests the daemon may be able to e.g. defer download because they conform to its RE backend's expected digest format.  "},{"title":"actions.download_file​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionsdownload_file","content":"def actions.download_file( output: artifact | output_artifact | str, url: str, /, *, vpnless_url: None | str = None, sha1: None | str = None, sha256: None | str = None, is_executable: bool = False, is_deferrable: bool = False ) -&gt; artifact  Downloads a URL to an output (filename as string or output artifact). The file at the URL must have the given sha1 or the command will fail. The optional parameter is_executable indicates whether the resulting file should be marked with executable permissions. (Meta-internal) The optional parameter vpnless_url indicates a url from which this resource can be downloaded off VPN; this has the same restrictions as url above.  "},{"title":"actions.dynamic_output​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionsdynamic_output","content":"def actions.dynamic_output( *, dynamic: list[artifact] | tuple[artifact, ...], inputs: list[artifact] | tuple[artifact, ...] = _, outputs: list[output_artifact] | tuple[output_artifact, ...], f: typing.Callable[[typing.Any, dict[artifact, artifact_value], dict[artifact, artifact]], None] ) -&gt; None  dynamic_output allows a rule to use information that was not available when the rule was first run at analysis time. Examples include things like Distributed ThinLTO (where the index file is created by another action) or OCaml builds (where the dependencies are created by ocamldeps). The arguments are: dynamic - a list of artifacts whose values will be available in the function. These will be built before the function is run.inputs - parameter is ignored.outputs - a list of unbound artifacts (created with declare_artifact) which will be bound by the function.The function argument is given 3 arguments: ctx (context) - which is the same as that passed to the initial rule analysis.artifacts - using one of the artifacts from dynamic (example usage:artifacts[artifact_from_dynamic]) gives an artifact value containing the methodsread_string, read_lines, and read_json to obtain the values from the disk in various formats. Anything too complex should be piped through a Python script for transformation to JSON.outputs - using one of the artifacts from the dynamic_output's outputs (example usage: outputs[artifact_from_dynamic_output_outputs]) gives an unbounded artifact. The function argument must use its outputs argument to bind output artifacts, rather than reusing artifacts from the outputs passed into dynamic_output directly. The function must call ctx.actions (probably ctx.actions.run) to bind all outputs. It can examine the values of the dynamic variables and depends on the inputs. The function will usually be a def, as lambda in Starlark does not allow statements, making it quite underpowered. For full details seehttps://buck2.build/docs/rule_authors/dynamic_dependencies/. Besides dynamic dependencies, there is a second use case for dynamic_output: say that you have some output artifact, and that the analysis to produce the action that outputs that artifact is expensive, ie takes a lot of CPU time; you would like to skip that work in builds that do not actually use that artifact. This can be accomplished by putting the analysis for that artifact behind a dynamic_outputwith an empty dynamic list. The dynamic_output's function will not be run unless one of the actions it outputs is actually requested as part of the build.  "},{"title":"actions.dynamic_output_new​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionsdynamic_output_new","content":"def actions.dynamic_output_new( dynamic_actions: DynamicAction, / ) -&gt; DynamicValue  New version of dynamic_output. This is work in progress, and will eventually replace the old dynamic_output.  "},{"title":"actions.run​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionsrun","content":"def actions.run( arguments: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo, /, *, category: str, identifier: None | str = None, env: dict[str, artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | RunInfo] = _, local_only: bool = False, prefer_local: bool = False, prefer_remote: bool = False, low_pass_filter: bool = True, always_print_stderr: bool = False, weight: int = _, weight_percentage: int = _, dep_files: dict[str, artifact_tag] = _, metadata_env_var: str = _, metadata_path: str = _, no_outputs_cleanup: bool = False, allow_cache_upload: bool = False, allow_dep_file_cache_upload: bool = False, force_full_hybrid_if_capable: bool = False, exe: RunInfo | WorkerRunInfo = _, unique_input_inodes: bool = False, error_handler: typing.Callable = _, remote_execution_dependencies: list[dict[str, str]] = [] ) -&gt; None  Runs a command arguments: must be of type cmd_args, or a type convertible to such (such as a list of strings and artifacts) and must contain at least one .as_output() artifactcategory: category and identifier - when used together, identify the action in Buck2's event stream, and must be unique for a given targetweight: used to note how heavy the command is and will typically be set to a higher value to indicate that less such commands should be run in parallel (if running locally)no_outputs_cleanup: if this flag is set then Buck2 won't clean the outputs of a previous build that might be present on a disk; in which case, command from arguments should be responsible for the cleanup (that is useful, for example, when an action is supporting incremental mode and its outputs are based on result from a previous build)metadata_env_var and meadata_path should be used together: both set or both unset metadata_path: defines a path relative to the result directory for a file with action metadata, which will be created right before the command will be run.Metadata contains the path relative to the Buck2 project root and hash digest for every action input (this excludes symlinks as they could be resolved by a user script if needed). The resolved path relative to the Buck2 project for the metadata file will be passed to command from arguments, via the environment variable, with its name set by metadata_env_varBoth metadata_env_var and metadata_path are useful when making actions behave in an incremental manner (for details, see Incremental Actions) The prefer_local, prefer_remote and local_only options allow selecting where the action should run if the executor selected for this target is a hybrid executor. * All those options disable concurrent execution: the action will run on the preferred platform first (concurrent execution only happens with a &quot;full&quot; hybrid executor). * Execution may be retried on the &quot;non-preferred&quot; platform if it fails due to a transient error, except for `local_only`, which does not allow this. * If the executor selected is a remote-only executor and you use `local_only`, that's an error. The other options will not raise errors. * Setting more than one of those options is an error. * Those flags behave the same way as the equivalent `--prefer-remote`, `--prefer-local` and `--local-only` CLI flags. The CLI flags take precedence. * The `force_full_hybrid_if_capable` option overrides the `use_limited_hybrid` hybrid. The options listed above take precedence if set. remote_execution_dependencies: list of dependencies which is passed to Remote Execution. Each dependency is dictionary with the following keys: smc_tier: name of the SMC tier to call by RE Scheduler.id: name of the dependency. When actions execute, they'll do so from the root of the repository. As they execute, actions have exclusive access to their output directory. Actions also get exclusive access to a &quot;scratch&quot; path that is exposed via the environment variable BUCK_SCRATCH_PATH. This path is expressed as a path relative to the working directory (i.e. relative to the project). This path is guaranteed to exist when the action executes. When actions run locally, the scratch path is also used as the TMPDIR.  "},{"title":"actions.symlink_file​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionssymlink_file","content":"def actions.symlink_file( dest: artifact | output_artifact | str, src: artifact, / ) -&gt; artifact  Creates a symlink to the source artifact at the destination (which can be a string representing a filename or an output artifact) and returns the output artifact. The symlink works for files or directories.  "},{"title":"actions.symlinked_dir​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionssymlinked_dir","content":"def actions.symlinked_dir( output: artifact | output_artifact | str, srcs: dict[str, artifact], / ) -&gt; artifact  Returns an artifact that is a directory containing symlinks. The srcs must be a dictionary of path (as string, relative to the result directory) to bound artifact, which will be laid out in the directory.  "},{"title":"actions.tset​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionstset","content":"def actions.tset( definition: transitive_set_definition, /, value = _, children: typing.Iterable = _ ) -&gt; transitive_set  Creates a new transitive set. For details, see https://buck2.build/docs/rule_authors/transitive_sets/.  "},{"title":"actions.write​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionswrite","content":"def actions.write( output: artifact | output_artifact | str, content: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo, /, *, is_executable: bool = False, allow_args: bool = False, with_inputs: bool = False, absolute: bool = False ) -&gt; artifact | (artifact, list[artifact])  Returns an artifact whose contents are content is_executable (optional): indicates whether the resulting file should be marked with executable permissionsallow_args (optional): must be set to True if you want to write parameter arguments to the file (in particular, macros that write to file) If it is true, the result will be a pair of the artifact containing content and a list of artifact values that were written by macros, which should be used in hidden fields or similar absolute (optional): if set, this action will produce absolute paths in its output when rendering artifact paths. You generally shouldn't use this if you plan to use this action as the input for anything else, as this would effectively result in losing all shared caching. The content is often a string, but can be any ArgLike value. This is occasionally useful for generating scripts to run as a part of another action. cmd_args in the content are newline separated unless another delimiter is explicitly specified.  "},{"title":"actions.write_json​","type":1,"pageTitle":"actions type","url":"/docs/api/build/actions/#actionswrite_json","content":"def actions.write_json( output: artifact | output_artifact | str, content: None | artifact | bool | cell_root | cmd_args | enum | int | label | label_relative_path | output_artifact | project_root | record | resolved_macro | str | tagged_command_line | tagged_value | target_label | transitive_set_args_projection | transitive_set_json_projection | write_json_cli_args | list[typing.Any] | tuple | dict[typing.Any, typing.Any] | struct(..) | RunInfo | provider, /, *, with_inputs: bool = False, pretty: bool = False, absolute: bool = False ) -&gt; artifact | write_json_cli_args  Returns an artifact whose contents are content written as a JSON value. output: can be a string, or an existing artifact created with declare_outputcontent: must be composed of the basic json types (boolean, number, string, list/tuple, dictionary) plus artifacts and command lines An artifact will be written as a string containing the pathA command line will be written as a list of strings, unless joined=True is set, in which case it will be a string If you pass with_inputs = True, you'll get back a cmd_args that expands to the JSON file but carries all the underlying inputs as dependencies (so you don't have to use, for example, hidden for them to be added to an action that already receives the JSON file)pretty (optional): write formatted JSON (defaults to False)absolute (optional): if set, this action will produce absolute paths in its output when rendering artifact paths. You generally shouldn't use this if you plan to use this action as the input for anything else, as this would effectively result in losing all shared caching. (defaults to False) "},{"title":"promise type","type":0,"sectionRef":"#","url":"/docs/api/build/promise/","content":"","keywords":""},{"title":"promise.join​","type":1,"pageTitle":"promise type","url":"/docs/api/build/promise/#promisejoin","content":"def promise.join(*args) -&gt; promise  Join a set of promises together into a single promise. Given a series of promises, p4 = p1.join(p2, p3) will produce a promise where the value is promise that resolves to a tuple containing the three values, those from p1, p2 and p3 respectively.  "},{"title":"promise.map​","type":1,"pageTitle":"promise type","url":"/docs/api/build/promise/#promisemap","content":"def promise.map(func: typing.Callable[[typing.Any], typing.Any], /) -&gt; promise  Given a promise, apply a function to the value it contains, producing a promise with the resulting value. "},{"title":"provider_collection type","type":0,"sectionRef":"#","url":"/docs/api/build/provider_collection/","content":"","keywords":""},{"title":"provider_collection.get​","type":1,"pageTitle":"provider_collection type","url":"/docs/api/build/provider_collection/#provider_collectionget","content":"def provider_collection.get(index) -&gt; None | provider  "},{"title":"providers_label type","type":0,"sectionRef":"#","url":"/docs/api/build/providers_label/","content":"","keywords":""},{"title":"providers_label.cell​","type":1,"pageTitle":"providers_label type","url":"/docs/api/build/providers_label/#providers_labelcell","content":"providers_label.cell: str   "},{"title":"providers_label.name​","type":1,"pageTitle":"providers_label type","url":"/docs/api/build/providers_label/#providers_labelname","content":"providers_label.name: str   "},{"title":"providers_label.path​","type":1,"pageTitle":"providers_label type","url":"/docs/api/build/providers_label/#providers_labelpath","content":"providers_label.path: label_relative_path   "},{"title":"providers_label.raw_target​","type":1,"pageTitle":"providers_label type","url":"/docs/api/build/providers_label/#providers_labelraw_target","content":"def providers_label.raw_target() -&gt; target_label  Returns the unconfigured underlying target label.  "},{"title":"providers_label.sub_target​","type":1,"pageTitle":"providers_label type","url":"/docs/api/build/providers_label/#providers_labelsub_target","content":"providers_label.sub_target: None | list[str]  "},{"title":"StackFrame type","type":0,"sectionRef":"#","url":"/docs/api/build/StackFrame/","content":"","keywords":""},{"title":"StackFrame.func_name​","type":1,"pageTitle":"StackFrame type","url":"/docs/api/build/StackFrame/#stackframefunc_name","content":"StackFrame.func_name: str  Returns the name of the entry on the call-stack.  "},{"title":"StackFrame.module_path​","type":1,"pageTitle":"StackFrame type","url":"/docs/api/build/StackFrame/#stackframemodule_path","content":"StackFrame.module_path: None | str  Returns a path of the module from which the entry was called, or [None] for native Rust functions. "},{"title":"target_label type","type":0,"sectionRef":"#","url":"/docs/api/build/target_label/","content":"","keywords":""},{"title":"target_label.cell​","type":1,"pageTitle":"target_label type","url":"/docs/api/build/target_label/#target_labelcell","content":"target_label.cell: str   "},{"title":"target_label.name​","type":1,"pageTitle":"target_label type","url":"/docs/api/build/target_label/#target_labelname","content":"target_label.name: str   "},{"title":"target_label.package​","type":1,"pageTitle":"target_label type","url":"/docs/api/build/target_label/#target_labelpackage","content":"target_label.package: str   "},{"title":"target_label.with_sub_target​","type":1,"pageTitle":"target_label type","url":"/docs/api/build/target_label/#target_labelwith_sub_target","content":"def target_label.with_sub_target( subtarget_name: str | list[str] = _ ) -&gt; providers_label  Converts a TargetLabel into its corresponding ProvidersLabel given the subtarget names, which is a list for each layer of subtarget Sample usage: def _impl_sub_target(ctx): owners = ctx.uquery().owner(&quot;bin/TARGETS.fixture&quot;) for owner in owners: unconfigured_label = owner.label ctx.output.print(unconfigured_label.with_sub_target()) ctx.output.print(unconfigured_label.with_sub_target(&quot;subtarget1&quot;)) ctx.output.print(unconfigured_label.with_sub_target([&quot;subtarget1&quot;, &quot;subtarget2&quot;]))  "},{"title":"action_attr type","type":0,"sectionRef":"#","url":"/docs/api/bxl/action_attr/","content":"","keywords":""},{"title":"action_attr.value​","type":1,"pageTitle":"action_attr type","url":"/docs/api/bxl/action_attr/#action_attrvalue","content":"def action_attr.value() -&gt; str  Returns the value of this attribute. "},{"title":"action type","type":0,"sectionRef":"#","url":"/docs/api/bxl/action/","content":"","keywords":""},{"title":"action.owner​","type":1,"pageTitle":"action type","url":"/docs/api/bxl/action/#actionowner","content":"def action.owner() -&gt; configured_target_label  Gets the owning configured target label for an action. Sample usage: def _impl_action(ctx): action = ctx.audit().output(&quot;buck-out/path/to/__target__/artifact&quot;, &quot;your_target_platform&quot;) ctx.output.print(action.owner())  "},{"title":"ActionErrorCtx type","type":0,"sectionRef":"#","url":"/docs/api/bxl/ActionErrorCtx/","content":"","keywords":""},{"title":"ActionErrorCtx.new_error_location​","type":1,"pageTitle":"ActionErrorCtx type","url":"/docs/api/bxl/ActionErrorCtx/#actionerrorctxnew_error_location","content":"def ActionErrorCtx.new_error_location( *, file: str, line: None | int = None ) -&gt; ActionErrorLocation  Create a new error location, specifying a file path and an optional line number. The file path should be either a project-relative path, or an absolute path.  "},{"title":"ActionErrorCtx.new_sub_error​","type":1,"pageTitle":"ActionErrorCtx type","url":"/docs/api/bxl/ActionErrorCtx/#actionerrorctxnew_sub_error","content":"def ActionErrorCtx.new_sub_error( *, category: str, message: None | str = None, locations: None | list[ActionErrorLocation] | tuple[ActionErrorLocation, ...] = None ) -&gt; ActionSubError  Create a new sub error, specifying an error category name, optional message, and an optional list of error locations. The category should be finer grain error categorizations provided by the rule authors, and tend to be language specific. These should not be any kind of shared concepts among all errors for all languages/rules. For example, timeouts and infra errors should not go here - buck2 tries to categorize these types of errors automatically. An example of a finer grain error category may be the error code for rustc outputs. The message will be emitted to the build report, and to the stderr in the error diagnostics section.  "},{"title":"ActionErrorCtx.stderr​","type":1,"pageTitle":"ActionErrorCtx type","url":"/docs/api/bxl/ActionErrorCtx/#actionerrorctxstderr","content":"ActionErrorCtx.stderr: str  The stderr of the failed action.  "},{"title":"ActionErrorCtx.stdout​","type":1,"pageTitle":"ActionErrorCtx type","url":"/docs/api/bxl/ActionErrorCtx/#actionerrorctxstdout","content":"ActionErrorCtx.stdout: str  The stdout of the failed action. "},{"title":"ActionErrorLocation type","type":0,"sectionRef":"#","url":"/docs/api/bxl/ActionErrorLocation/","content":"","keywords":""},{"title":"ActionErrorLocation.file​","type":1,"pageTitle":"ActionErrorLocation type","url":"/docs/api/bxl/ActionErrorLocation/#actionerrorlocationfile","content":"ActionErrorLocation.file: str  The file of the error location. This is only needed for action error handler unit testing.  "},{"title":"ActionErrorLocation.line​","type":1,"pageTitle":"ActionErrorLocation type","url":"/docs/api/bxl/ActionErrorLocation/#actionerrorlocationline","content":"ActionErrorLocation.line: None | int  The line of the error location. This is only needed for action error handler unit testing. "},{"title":"ActionSubError type","type":0,"sectionRef":"#","url":"/docs/api/bxl/ActionSubError/","content":"","keywords":""},{"title":"ActionSubError.category​","type":1,"pageTitle":"ActionSubError type","url":"/docs/api/bxl/ActionSubError/#actionsuberrorcategory","content":"ActionSubError.category: str  The category name of this sub error. This function is only needed for action error handler unit testing.  "},{"title":"ActionSubError.locations​","type":1,"pageTitle":"ActionSubError type","url":"/docs/api/bxl/ActionSubError/#actionsuberrorlocations","content":"ActionSubError.locations: None | list[ActionErrorLocation]  Any locations associated with this sub error. This function is only needed for action error handler unit testing.  "},{"title":"ActionSubError.message​","type":1,"pageTitle":"ActionSubError type","url":"/docs/api/bxl/ActionSubError/#actionsuberrormessage","content":"ActionSubError.message: None | str  The optional message associated with this sub error. This function is only needed for action error handler unit testing. "},{"title":"anon_targets type","type":0,"sectionRef":"#","url":"/docs/api/bxl/anon_targets/","content":"","keywords":""},{"title":"anon_targets.anon_targets​","type":1,"pageTitle":"anon_targets type","url":"/docs/api/bxl/anon_targets/#anon_targetsanon_targets","content":"anon_targets.anon_targets: typing.Any  Returns a list of StarlarkAnonTargets.  "},{"title":"anon_targets.promise​","type":1,"pageTitle":"anon_targets type","url":"/docs/api/bxl/anon_targets/#anon_targetspromise","content":"anon_targets.promise: promise  Returns the promise that maps to the result of the joined anon rules. "},{"title":"anon_target type","type":0,"sectionRef":"#","url":"/docs/api/bxl/anon_target/","content":"","keywords":""},{"title":"anon_target.artifact​","type":1,"pageTitle":"anon_target type","url":"/docs/api/bxl/anon_target/#anon_targetartifact","content":"def anon_target.artifact(name: str)  Gets a specific StarlarkPromiseArtifact by name. Returns an error if the name was not found in the registered promise artifacts for the anon target.  "},{"title":"anon_target.artifacts​","type":1,"pageTitle":"anon_target type","url":"/docs/api/bxl/anon_target/#anon_targetartifacts","content":"def anon_target.artifacts()  Returns a dict where the key is the promise artifact's name, and the value is the StarlarkPromiseArtifact. To get a promise artifact where the short path is accessible, call ctx.actions.assert_short_path(...) and pass in the artifact retrieved from this dict.  "},{"title":"anon_target.promise​","type":1,"pageTitle":"anon_target type","url":"/docs/api/bxl/anon_target/#anon_targetpromise","content":"anon_target.promise: promise  Returns the promise that maps to the result of the anon rule. "},{"title":"artifact type","type":0,"sectionRef":"#","url":"/docs/api/bxl/artifact/","content":"","keywords":""},{"title":"artifact.as_output​","type":1,"pageTitle":"artifact type","url":"/docs/api/bxl/artifact/#artifactas_output","content":"def artifact.as_output() -&gt; output_artifact  Returns a StarlarkOutputArtifact instance, or fails if the artifact is either an Artifact, or is a bound Artifact (You cannot bind twice)  "},{"title":"artifact.basename​","type":1,"pageTitle":"artifact type","url":"/docs/api/bxl/artifact/#artifactbasename","content":"artifact.basename: str  The base name of this artifact. e.g. for an artifact at foo/bar, this is bar  "},{"title":"artifact.extension​","type":1,"pageTitle":"artifact type","url":"/docs/api/bxl/artifact/#artifactextension","content":"artifact.extension: str  The file extension of this artifact. e.g. for an artifact at foo/bar.sh, this is .sh. If no extension is present, &quot;&quot; is returned.  "},{"title":"artifact.is_source​","type":1,"pageTitle":"artifact type","url":"/docs/api/bxl/artifact/#artifactis_source","content":"artifact.is_source: bool  Whether the artifact represents a source file  "},{"title":"artifact.owner​","type":1,"pageTitle":"artifact type","url":"/docs/api/bxl/artifact/#artifactowner","content":"artifact.owner: None | label  The Label of the rule that originally created this artifact. May also be None in the case of source files, or if the artifact has not be used in an action, or if the action was not created by a rule.  "},{"title":"artifact.project​","type":1,"pageTitle":"artifact type","url":"/docs/api/bxl/artifact/#artifactproject","content":"def artifact.project( path: str, /, *, hide_prefix: bool = False ) -&gt; artifact  Create an artifact that lives at path relative from this artifact. For example, if artifact foo is a directory containing a file bar, then foo.project(&quot;bar&quot;)yields the file bar. It is possible for projected artifacts to hide the prefix in order to have the short name of the resulting artifact only contain the projected path, by passinghide_prefix = True to project().  "},{"title":"artifact.short_path​","type":1,"pageTitle":"artifact type","url":"/docs/api/bxl/artifact/#artifactshort_path","content":"artifact.short_path: str  The interesting part of the path, relative to somewhere in the output directory. For an artifact declared as foo/bar, this is foo/bar.  "},{"title":"artifact.with_associated_artifacts​","type":1,"pageTitle":"artifact type","url":"/docs/api/bxl/artifact/#artifactwith_associated_artifacts","content":"def artifact.with_associated_artifacts(artifacts: list[artifact]) -&gt; artifact  Returns a StarlarkArtifact instance which is identical to the original artifact, but with potentially additional artifacts. The artifacts must be bound.  "},{"title":"artifact.without_associated_artifacts​","type":1,"pageTitle":"artifact type","url":"/docs/api/bxl/artifact/#artifactwithout_associated_artifacts","content":"def artifact.without_associated_artifacts() -&gt; artifact  Returns a StarlarkArtifact instance which is identical to the original artifact, except with no associated artifacts "},{"title":"buck_regex type","type":0,"sectionRef":"#","url":"/docs/api/bxl/buck_regex/","content":"","keywords":""},{"title":"buck_regex.match​","type":1,"pageTitle":"buck_regex type","url":"/docs/api/bxl/buck_regex/#buck_regexmatch","content":"def buck_regex.match(str: str, /) -&gt; bool  "},{"title":"bxl.ActionQueryNode type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.ActionQueryNode/","content":"","keywords":""},{"title":"bxl.ActionQueryNode.action​","type":1,"pageTitle":"bxl.ActionQueryNode type","url":"/docs/api/bxl/bxl.ActionQueryNode/#bxlactionquerynodeaction","content":"def bxl.ActionQueryNode.action() -&gt; None | action  Gets optional action from the action query target node.  "},{"title":"bxl.ActionQueryNode.analysis​","type":1,"pageTitle":"bxl.ActionQueryNode type","url":"/docs/api/bxl/bxl.ActionQueryNode/#bxlactionquerynodeanalysis","content":"def bxl.ActionQueryNode.analysis() -&gt; None | bxl.AnalysisResult  Gets optional analysis from the action query target node.  "},{"title":"bxl.ActionQueryNode.attrs​","type":1,"pageTitle":"bxl.ActionQueryNode type","url":"/docs/api/bxl/bxl.ActionQueryNode/#bxlactionquerynodeattrs","content":"bxl.ActionQueryNode.attrs: typing.Any  Gets the attributes from the action query node. Returns a struct.  "},{"title":"bxl.ActionQueryNode.rule_type​","type":1,"pageTitle":"bxl.ActionQueryNode type","url":"/docs/api/bxl/bxl.ActionQueryNode/#bxlactionquerynoderule_type","content":"bxl.ActionQueryNode.rule_type: str  Gets the kind of action query node, either analysis or action kind. "},{"title":"actions type","type":0,"sectionRef":"#","url":"/docs/api/bxl/actions/","content":"","keywords":""},{"title":"actions.anon_target​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionsanon_target","content":"def actions.anon_target( rule: &quot;function&quot;, attrs: dict[str, typing.Any] ) -&gt; anon_target  An anonymous target is defined by the hash of its attributes, rather than its name. During analysis, rules can define and access the providers of anonymous targets before producing their own providers. Two distinct rules might ask for the same anonymous target, sharing the work it performs. For more details see https://buck2.build/docs/rule_authors/anon_targets/  "},{"title":"actions.anon_targets​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionsanon_targets","content":"def actions.anon_targets( rules: list[(&quot;function&quot;, dict[str, typing.Any])] | tuple[(&quot;function&quot;, dict[str, typing.Any]), ...] ) -&gt; anon_targets  Generate a series of anonymous targets.  "},{"title":"actions.artifact_tag​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionsartifact_tag","content":"def actions.artifact_tag() -&gt; artifact_tag  Allocate a new input tag. Used with the dep_files argument to run.  "},{"title":"actions.assert_short_path​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionsassert_short_path","content":"def actions.assert_short_path(artifact: artifact, short_path: str) -&gt; artifact  Generate a promise artifact that has short path accessible on it. The short path's correctness will be asserted during analysis time. TODO - we would prefer the API to be ctx.actions.anon_target(xxx).artifact(&quot;foo&quot;, short_path=yyy), but we cannot support this until we can get access to the AnalysisContext without passing it into this method.  "},{"title":"actions.cas_artifact​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionscas_artifact","content":"def actions.cas_artifact( output: artifact | output_artifact | str, digest: str, use_case: str, /, *, expires_after_timestamp: int, is_executable: bool = False, is_tree: bool = False, is_directory: bool = False ) -&gt; artifact  Downloads a CAS artifact to an output digest: must look like SHA1:SIZEuse_case: your RE use caseexpires_after_timestamp: must be a UNIX timestamp. Your digest's TTL must exceed this timestamp. Your build will break once the digest expires, so make sure the expiry is long enough (preferably, in years).is_executable: indicates the resulting file should be marked with executable permissionsis_tree: digest must point to a blob of typeRE.Treeis_directory: digest must point to a blob of typeRE.Directory  "},{"title":"actions.copied_dir​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionscopied_dir","content":"def actions.copied_dir( output: artifact | output_artifact | str, srcs: dict[str, artifact], / ) -&gt; artifact  Returns an artifact which is a directory containing copied files. The srcs must be a dictionary of path (as string, relative to the result directory) to the bound artifact, which will be laid out in the directory.  "},{"title":"actions.copy_dir​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionscopy_dir","content":"def actions.copy_dir( dest: artifact | output_artifact | str, src: artifact, / ) -&gt; artifact  Make a copy of a directory.  "},{"title":"actions.copy_file​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionscopy_file","content":"def actions.copy_file( dest: artifact | output_artifact | str, src: artifact, / ) -&gt; artifact  Copies the source artifact to the destination (which can be a string representing a filename or an output artifact) and returns the output artifact. The copy works for files or directories.  "},{"title":"actions.declare_output​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionsdeclare_output","content":"def actions.declare_output( prefix: str, filename: str = _, /, *, dir: bool = False ) -&gt; artifact  Returns an unbound artifact, representing where a file will go, which must be bound before analysis terminates. The usual way of binding an artifact is with ctx.actions.run. As an example: my_output = ctx.actions.declare_output(&quot;output.o&quot;) ctx.actions.run([&quot;gcc&quot;, &quot;-c&quot;, my_source, &quot;-o&quot;, my_output.as_output()], category = &quot;compile&quot;)  This snippet declares an output with the filename output.o (it will be located in the output directory for this target). Note the use of as_output to tag this artifact as being an output in the action. After binding the artifact you can subsequently use my_output as either an input for subsequent actions, or as the result in a provider. Artifacts from a single target may not have the same name, so if you then want a second artifact also named output.o you need to supply a prefix, e.g.ctx.actions.declare_output(&quot;directory&quot;, &quot;output.o&quot;). The artifact will still report having name output.o, but will be located at directory/output.o. The dir argument should be set to True if the binding will be a directory.  "},{"title":"actions.digest_config​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionsdigest_config","content":"def actions.digest_config() -&gt; digest_config  Obtain this daemon's digest configuration. This allows rules to discover what digests the daemon may be able to e.g. defer download because they conform to its RE backend's expected digest format.  "},{"title":"actions.download_file​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionsdownload_file","content":"def actions.download_file( output: artifact | output_artifact | str, url: str, /, *, vpnless_url: None | str = None, sha1: None | str = None, sha256: None | str = None, is_executable: bool = False, is_deferrable: bool = False ) -&gt; artifact  Downloads a URL to an output (filename as string or output artifact). The file at the URL must have the given sha1 or the command will fail. The optional parameter is_executable indicates whether the resulting file should be marked with executable permissions. (Meta-internal) The optional parameter vpnless_url indicates a url from which this resource can be downloaded off VPN; this has the same restrictions as url above.  "},{"title":"actions.dynamic_output​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionsdynamic_output","content":"def actions.dynamic_output( *, dynamic: list[artifact] | tuple[artifact, ...], inputs: list[artifact] | tuple[artifact, ...] = _, outputs: list[output_artifact] | tuple[output_artifact, ...], f: typing.Callable[[typing.Any, dict[artifact, artifact_value], dict[artifact, artifact]], None] ) -&gt; None  dynamic_output allows a rule to use information that was not available when the rule was first run at analysis time. Examples include things like Distributed ThinLTO (where the index file is created by another action) or OCaml builds (where the dependencies are created by ocamldeps). The arguments are: dynamic - a list of artifacts whose values will be available in the function. These will be built before the function is run.inputs - parameter is ignored.outputs - a list of unbound artifacts (created with declare_artifact) which will be bound by the function.The function argument is given 3 arguments: ctx (context) - which is the same as that passed to the initial rule analysis.artifacts - using one of the artifacts from dynamic (example usage:artifacts[artifact_from_dynamic]) gives an artifact value containing the methodsread_string, read_lines, and read_json to obtain the values from the disk in various formats. Anything too complex should be piped through a Python script for transformation to JSON.outputs - using one of the artifacts from the dynamic_output's outputs (example usage: outputs[artifact_from_dynamic_output_outputs]) gives an unbounded artifact. The function argument must use its outputs argument to bind output artifacts, rather than reusing artifacts from the outputs passed into dynamic_output directly. The function must call ctx.actions (probably ctx.actions.run) to bind all outputs. It can examine the values of the dynamic variables and depends on the inputs. The function will usually be a def, as lambda in Starlark does not allow statements, making it quite underpowered. For full details seehttps://buck2.build/docs/rule_authors/dynamic_dependencies/. Besides dynamic dependencies, there is a second use case for dynamic_output: say that you have some output artifact, and that the analysis to produce the action that outputs that artifact is expensive, ie takes a lot of CPU time; you would like to skip that work in builds that do not actually use that artifact. This can be accomplished by putting the analysis for that artifact behind a dynamic_outputwith an empty dynamic list. The dynamic_output's function will not be run unless one of the actions it outputs is actually requested as part of the build.  "},{"title":"actions.dynamic_output_new​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionsdynamic_output_new","content":"def actions.dynamic_output_new( dynamic_actions: DynamicAction, / ) -&gt; DynamicValue  New version of dynamic_output. This is work in progress, and will eventually replace the old dynamic_output.  "},{"title":"actions.run​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionsrun","content":"def actions.run( arguments: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo, /, *, category: str, identifier: None | str = None, env: dict[str, artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | RunInfo] = _, local_only: bool = False, prefer_local: bool = False, prefer_remote: bool = False, low_pass_filter: bool = True, always_print_stderr: bool = False, weight: int = _, weight_percentage: int = _, dep_files: dict[str, artifact_tag] = _, metadata_env_var: str = _, metadata_path: str = _, no_outputs_cleanup: bool = False, allow_cache_upload: bool = False, allow_dep_file_cache_upload: bool = False, force_full_hybrid_if_capable: bool = False, exe: RunInfo | WorkerRunInfo = _, unique_input_inodes: bool = False, error_handler: typing.Callable = _, remote_execution_dependencies: list[dict[str, str]] = [] ) -&gt; None  Runs a command arguments: must be of type cmd_args, or a type convertible to such (such as a list of strings and artifacts) and must contain at least one .as_output() artifactcategory: category and identifier - when used together, identify the action in Buck2's event stream, and must be unique for a given targetweight: used to note how heavy the command is and will typically be set to a higher value to indicate that less such commands should be run in parallel (if running locally)no_outputs_cleanup: if this flag is set then Buck2 won't clean the outputs of a previous build that might be present on a disk; in which case, command from arguments should be responsible for the cleanup (that is useful, for example, when an action is supporting incremental mode and its outputs are based on result from a previous build)metadata_env_var and meadata_path should be used together: both set or both unset metadata_path: defines a path relative to the result directory for a file with action metadata, which will be created right before the command will be run.Metadata contains the path relative to the Buck2 project root and hash digest for every action input (this excludes symlinks as they could be resolved by a user script if needed). The resolved path relative to the Buck2 project for the metadata file will be passed to command from arguments, via the environment variable, with its name set by metadata_env_varBoth metadata_env_var and metadata_path are useful when making actions behave in an incremental manner (for details, see Incremental Actions) The prefer_local, prefer_remote and local_only options allow selecting where the action should run if the executor selected for this target is a hybrid executor. * All those options disable concurrent execution: the action will run on the preferred platform first (concurrent execution only happens with a &quot;full&quot; hybrid executor). * Execution may be retried on the &quot;non-preferred&quot; platform if it fails due to a transient error, except for `local_only`, which does not allow this. * If the executor selected is a remote-only executor and you use `local_only`, that's an error. The other options will not raise errors. * Setting more than one of those options is an error. * Those flags behave the same way as the equivalent `--prefer-remote`, `--prefer-local` and `--local-only` CLI flags. The CLI flags take precedence. * The `force_full_hybrid_if_capable` option overrides the `use_limited_hybrid` hybrid. The options listed above take precedence if set. remote_execution_dependencies: list of dependencies which is passed to Remote Execution. Each dependency is dictionary with the following keys: smc_tier: name of the SMC tier to call by RE Scheduler.id: name of the dependency. When actions execute, they'll do so from the root of the repository. As they execute, actions have exclusive access to their output directory. Actions also get exclusive access to a &quot;scratch&quot; path that is exposed via the environment variable BUCK_SCRATCH_PATH. This path is expressed as a path relative to the working directory (i.e. relative to the project). This path is guaranteed to exist when the action executes. When actions run locally, the scratch path is also used as the TMPDIR.  "},{"title":"actions.symlink_file​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionssymlink_file","content":"def actions.symlink_file( dest: artifact | output_artifact | str, src: artifact, / ) -&gt; artifact  Creates a symlink to the source artifact at the destination (which can be a string representing a filename or an output artifact) and returns the output artifact. The symlink works for files or directories.  "},{"title":"actions.symlinked_dir​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionssymlinked_dir","content":"def actions.symlinked_dir( output: artifact | output_artifact | str, srcs: dict[str, artifact], / ) -&gt; artifact  Returns an artifact that is a directory containing symlinks. The srcs must be a dictionary of path (as string, relative to the result directory) to bound artifact, which will be laid out in the directory.  "},{"title":"actions.tset​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionstset","content":"def actions.tset( definition: transitive_set_definition, /, value = _, children: typing.Iterable = _ ) -&gt; transitive_set  Creates a new transitive set. For details, see https://buck2.build/docs/rule_authors/transitive_sets/.  "},{"title":"actions.write​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionswrite","content":"def actions.write( output: artifact | output_artifact | str, content: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo, /, *, is_executable: bool = False, allow_args: bool = False, with_inputs: bool = False, absolute: bool = False ) -&gt; artifact | (artifact, list[artifact])  Returns an artifact whose contents are content is_executable (optional): indicates whether the resulting file should be marked with executable permissionsallow_args (optional): must be set to True if you want to write parameter arguments to the file (in particular, macros that write to file) If it is true, the result will be a pair of the artifact containing content and a list of artifact values that were written by macros, which should be used in hidden fields or similar absolute (optional): if set, this action will produce absolute paths in its output when rendering artifact paths. You generally shouldn't use this if you plan to use this action as the input for anything else, as this would effectively result in losing all shared caching. The content is often a string, but can be any ArgLike value. This is occasionally useful for generating scripts to run as a part of another action. cmd_args in the content are newline separated unless another delimiter is explicitly specified.  "},{"title":"actions.write_json​","type":1,"pageTitle":"actions type","url":"/docs/api/bxl/actions/#actionswrite_json","content":"def actions.write_json( output: artifact | output_artifact | str, content: None | artifact | bool | cell_root | cmd_args | enum | int | label | label_relative_path | output_artifact | project_root | record | resolved_macro | str | tagged_command_line | tagged_value | target_label | transitive_set_args_projection | transitive_set_json_projection | write_json_cli_args | list[typing.Any] | tuple | dict[typing.Any, typing.Any] | struct(..) | RunInfo | provider, /, *, with_inputs: bool = False, pretty: bool = False, absolute: bool = False ) -&gt; artifact | write_json_cli_args  Returns an artifact whose contents are content written as a JSON value. output: can be a string, or an existing artifact created with declare_outputcontent: must be composed of the basic json types (boolean, number, string, list/tuple, dictionary) plus artifacts and command lines An artifact will be written as a string containing the pathA command line will be written as a list of strings, unless joined=True is set, in which case it will be a string If you pass with_inputs = True, you'll get back a cmd_args that expands to the JSON file but carries all the underlying inputs as dependencies (so you don't have to use, for example, hidden for them to be added to an action that already receives the JSON file)pretty (optional): write formatted JSON (defaults to False)absolute (optional): if set, this action will produce absolute paths in its output when rendering artifact paths. You generally shouldn't use this if you plan to use this action as the input for anything else, as this would effectively result in losing all shared caching. (defaults to False) "},{"title":"bxl.Actions type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.Actions/","content":"","keywords":""},{"title":"bxl.Actions.actions​","type":1,"pageTitle":"bxl.Actions type","url":"/docs/api/bxl/bxl.Actions/#bxlactionsactions","content":"bxl.Actions.actions: actions  Gets the analysis action context to create and register actions on the execution platform corresponding to this bxl action's execution platform resolution.  "},{"title":"bxl.Actions.exec_deps​","type":1,"pageTitle":"bxl.Actions type","url":"/docs/api/bxl/bxl.Actions/#bxlactionsexec_deps","content":"bxl.Actions.exec_deps: dict[providers_label, dependency]  Gets the execution deps requested correctly configured for the current execution platform  "},{"title":"bxl.Actions.toolchains​","type":1,"pageTitle":"bxl.Actions type","url":"/docs/api/bxl/bxl.Actions/#bxlactionstoolchains","content":"bxl.Actions.toolchains: dict[providers_label, dependency]  Gets the toolchains requested configured for the current execution platform "},{"title":"attrs type","type":0,"sectionRef":"#","url":"/docs/api/bxl/attrs/","content":"","keywords":""},{"title":"attrs.any​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsany","content":"def attrs.any(*, doc: str = &quot;&quot;, default = _) -&gt; attribute  Takes most builtin literals and passes them to the rule as a string. Discouraged, as it provides little type safety and destroys the structure.  "},{"title":"attrs.arg​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsarg","content":"def attrs.arg( *, json: bool = False, default = _, doc: str = &quot;&quot;, anon_target_compatible: bool = False ) -&gt; attribute  Takes a command line argument from the user and supplies a cmd_args compatible value to the rule. The argument may contain special macros such as $(location :my_target) or $(exe :my_target) which will be replaced with references to those values in the rule. Takes in an optional anon_target_compatible flag, which indicates whether the args can be passed into anon targets. Note that there is a slight memory hit when using this flag.  "},{"title":"attrs.bool​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsbool","content":"def attrs.bool(*, default = _, doc: str = &quot;&quot;) -&gt; attribute  Takes a boolean and passes it to the rule as a boolean.  "},{"title":"attrs.configuration_label​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsconfiguration_label","content":"def attrs.configuration_label(*, doc: str = &quot;&quot;) -&gt; attribute   "},{"title":"attrs.configured_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsconfigured_dep","content":"def attrs.configured_dep( *, providers: list[typing.Any] | tuple = [], default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.default_only​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsdefault_only","content":"def attrs.default_only( inner: attribute, /, *, doc: str = &quot;&quot; ) -&gt; attribute  Rejects all values and uses the default for the inner argument. Often used to resolve dependencies, which otherwise can't be resolved inside a rule. attrs.default_only(attrs.dep(default = &quot;foo//my_package:my_target&quot;))   "},{"title":"attrs.dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsdep","content":"def attrs.dep( *, providers: list[typing.Any] | tuple = [], pulls_plugins: list[typing.Any] | tuple = [], pulls_and_pushes_plugins: all_plugins | list[typing.Any] | tuple = _, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a target from the user, as a string, and supplies a dependency to the rule. A target can be specified as an absolute dependency foo//bar:baz, omitting the cell (//bar:baz) or omitting the package name (:baz). If supplied the providers argument ensures that specific providers will be present on the dependency.  "},{"title":"attrs.dict​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsdict","content":"def attrs.dict( key: attribute, value: attribute, *, sorted: bool = False, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a dict from the user, supplies a dict to the rule.  "},{"title":"attrs.enum​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsenum","content":"def attrs.enum( variants: list[str] | tuple[str, ...], /, *, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a string from one of the variants given, and gives that string to the rule. Strings are matched case-insensitively, and always passed to the rule lowercase.  "},{"title":"attrs.exec_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsexec_dep","content":"def attrs.exec_dep( *, providers: list[typing.Any] | tuple = [], default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a target from the user, as a string, and supplies a dependency to the rule. The dependency will transition to the execution platform. Use exec_dep if you plan to execute things from this dependency as part of the compilation.  "},{"title":"attrs.int​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsint","content":"def attrs.int(*, default = _, doc: str = &quot;&quot;) -&gt; attribute  Takes an int from the user, supplies an int to the rule.  "},{"title":"attrs.label​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrslabel","content":"def attrs.label(*, default = _, doc: str = &quot;&quot;) -&gt; attribute  Takes a target (as per deps) and passes a label to the rule. Validates that the target exists, but does not introduce a dependency on it.  "},{"title":"attrs.list​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrslist","content":"def attrs.list( inner: attribute, /, *, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a list from the user, supplies a list to the rule.  "},{"title":"attrs.named_set​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsnamed_set","content":"def attrs.named_set( value_type: attribute, /, *, sorted: bool = False, default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.one_of​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsone_of","content":"def attrs.one_of(*args: attribute, default = _, doc: str = &quot;&quot;) -&gt; attribute  Given a list of alternative attributes, selects the first that matches and gives that to the rule.  "},{"title":"attrs.option​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsoption","content":"def attrs.option( inner: attribute, /, *, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a value that may be None or some inner type, and passes either None or the value corresponding to the inner to the rule. Often used to make a rule optional: attrs.option(attr.string(), default = None)   "},{"title":"attrs.plugin_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsplugin_dep","content":"def attrs.plugin_dep( *, kind, default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.query​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsquery","content":"def attrs.query(*, doc: str = &quot;&quot;) -&gt; attribute   "},{"title":"attrs.regex​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsregex","content":"def attrs.regex(*, default = _, doc: str = &quot;&quot;) -&gt; attribute  Currently an alias for attrs.string.  "},{"title":"attrs.set​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsset","content":"def attrs.set( value_type: attribute, /, *, sorted: bool = False, default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.source​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrssource","content":"def attrs.source( *, allow_directory: bool = False, default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a source file from the user, supplies an artifact to the rule. The source file may be specified as a literal string (representing the path within this package), or a target (which must have a DefaultInfo with a default_outputs value).  "},{"title":"attrs.split_transition_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrssplit_transition_dep","content":"def attrs.split_transition_dep( *, providers: list[typing.Any] | tuple = [], cfg, default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.string​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsstring","content":"def attrs.string( *, default = _, validate = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a string from the user, supplies a string to the rule.  "},{"title":"attrs.toolchain_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrstoolchain_dep","content":"def attrs.toolchain_dep( *, providers: list[typing.Any] | tuple = [], default = _, doc: str = &quot;&quot; ) -&gt; attribute  Takes a target from the user, as a string, and supplies a dependency to the rule. The dependency will be a toolchain dependency, meaning that its execution platform dependencies will be used to select the execution platform for this rule.  "},{"title":"attrs.transition_dep​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrstransition_dep","content":"def attrs.transition_dep( *, providers: list[typing.Any] | tuple = [], cfg, default = _, doc: str = &quot;&quot; ) -&gt; attribute   "},{"title":"attrs.tuple​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrstuple","content":"def attrs.tuple(*args: attribute, default = _, doc: str = &quot;&quot;) -&gt; attribute  Takes a tuple of values and gives a tuple to the rule.  "},{"title":"attrs.versioned​","type":1,"pageTitle":"attrs type","url":"/docs/api/bxl/attrs/#attrsversioned","content":"def attrs.versioned(value_type: attribute, *, doc: str = &quot;&quot;) -&gt; attribute  "},{"title":"bxl.AnalysisResult type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.AnalysisResult/","content":"","keywords":""},{"title":"bxl.AnalysisResult.as_dependency​","type":1,"pageTitle":"bxl.AnalysisResult type","url":"/docs/api/bxl/bxl.AnalysisResult/#bxlanalysisresultas_dependency","content":"def bxl.AnalysisResult.as_dependency() -&gt; dependency  Converts the analysis result into a dependency. Currently, you can only get a dependency without any transitions. This means that you cannot create an exec dep or toolchain from an analysis result. We may support other dependency transition types in the future. This is useful for passing in the results of ctx.analysis() into anon targets. Sample usage: def _impl_dependency(ctx): node = ctx.configured_targets(&quot;root//bin:the_binary&quot;) dependency = ctx.analysis(node).as_dependency()   "},{"title":"bxl.AnalysisResult.providers​","type":1,"pageTitle":"bxl.AnalysisResult type","url":"/docs/api/bxl/bxl.AnalysisResult/#bxlanalysisresultproviders","content":"def bxl.AnalysisResult.providers()  Access the providers of the rule. Returns a provider_collection the same as accessing providers of dependencies within a rule implementation. Sample usage: def _impl_providers(ctx): node = ctx.configured_targets(&quot;root//bin:the_binary&quot;) providers = ctx.analysis(node).providers() ctx.output.print(providers[FooInfo]) providers = ctx.analysis(&quot;//:bin&quot;).providers() ctx.output.print(providers[FooInfo])  "},{"title":"globals","type":0,"sectionRef":"#","url":"/docs/api/build/globals/","content":"","keywords":""},{"title":"ActionErrorCtx​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#actionerrorctx","content":"ActionErrorCtx: type   "},{"title":"ActionErrorLocation​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#actionerrorlocation","content":"ActionErrorLocation: type   "},{"title":"ActionSubError​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#actionsuberror","content":"ActionSubError: type   "},{"title":"AnalysisActions​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#analysisactions","content":"AnalysisActions: type   "},{"title":"AnalysisContext​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#analysiscontext","content":"AnalysisContext: type   "},{"title":"AnonTarget​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#anontarget","content":"AnonTarget: type   "},{"title":"AnonTargets​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#anontargets","content":"AnonTargets: type   "},{"title":"Artifact​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#artifact","content":"Artifact: type   "},{"title":"ArtifactTag​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#artifacttag","content":"ArtifactTag: type   "},{"title":"ArtifactValue​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#artifactvalue","content":"ArtifactValue: type   "},{"title":"Attr​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#attr","content":"Attr: type   "},{"title":"CellPath​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#cellpath","content":"CellPath: type   "},{"title":"CellRoot​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#cellroot","content":"CellRoot: type   "},{"title":"CommandExecutorConfig​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#commandexecutorconfig","content":"def CommandExecutorConfig( *, local_enabled: bool, remote_enabled: bool, remote_cache_enabled: None | bool = None, remote_dep_file_cache_enabled: bool = False, remote_execution_properties = None, remote_execution_action_key = None, remote_execution_max_input_files_mebibytes: None | int = None, remote_execution_queue_time_threshold_s: None | int = None, remote_execution_use_case = None, use_limited_hybrid: bool = False, allow_limited_hybrid_fallbacks: bool = False, allow_hybrid_fallbacks_on_failure: bool = False, use_windows_path_separators: bool = False, use_persistent_workers: bool = False, allow_cache_uploads: bool = False, max_cache_upload_mebibytes: None | int = None, experimental_low_pass_filter: bool = False, remote_output_paths: None | str = None, remote_execution_resource_units: None | int = None, remote_execution_dependencies: list[dict[str, str]] = [] ) -&gt; command_executor_config  Contains configurations for how actions should be executed .type attribute​ Produces &quot;command_executor_config&quot; Details​ local_enabled : Whether to use local execution for this execution platform. If both remote_enabled and local_enabled are True, we will use the hybrid executorremote_enabled: Whether to use remote execution for this execution platformremote_cache_enabled: Whether to query RE cachesremote_execution_properties: Properties for remote execution for this platformremote_execution_action_key: A component to inject into the action key This should typically used to inject variability into the action key so that it's different across e.g. build modes (RE uses the action key for things like expected memory utilization)remote_execution_max_input_files_mebibytes: The maximum input file size (in bytes) that remote execution can supportremote_execution_queue_time_threshold_s: The maximum time in seconds we are willing to wait in the RE queue for remote execution to start running our actionremote_execution_use_case: The use case to use when communicating with REuse_limited_hybrid: Whether to use the limited hybrid executorallow_limited_hybrid_fallbacks: Whether to allow fallbacksallow_hybrid_fallbacks_on_failure: Whether to allow fallbacks when the result is failure (i.e. the command failed on the primary, but the infra worked)use_windows_path_separators: Whether to use Windows path separators in command line argumentsuse_persistent workers: Whether to use persistent workers for local execution if they are availableallow_cache_uploads: Whether to upload local actions to the RE cachemax_cache_upload_mebibytes: Maximum size to upload in cache uploadsexperimental_low_pass_filter: Whether to use the experimental low pass filterremote_output_paths: How to express output paths to REremote_execution_resource_units: The resources (eg. GPUs) to use for remote executionremote_execution_dependencies: Dependencies for remote execution for this platform  "},{"title":"ConfigurationInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#configurationinfo","content":"def ConfigurationInfo( *, constraints: dict[target_label, ConstraintValueInfo], values: dict[str, str] ) -&gt; ConfigurationInfo  Provider that signals that a rule contains configuration info. This is used both as part of defining configurations (platform(), constraint_value()) and defining whether a target &quot;matches&quot; a configuration or not (config_setting(), constraint_value()) .type attribute​ Produces &quot;ConfigurationInfo&quot; Details​ Provides a number of fields that can be accessed: constraints: dict[target_label, ConstraintValueInfo] - field values: dict[str, str] - field  "},{"title":"ConfiguredProvidersLabel​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#configuredproviderslabel","content":"ConfiguredProvidersLabel: type   "},{"title":"ConfiguredTargetLabel​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#configuredtargetlabel","content":"ConfiguredTargetLabel: type   "},{"title":"ConstraintSettingInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#constraintsettinginfo","content":"def ConstraintSettingInfo(*, label: target_label) -&gt; ConstraintSettingInfo  Provider that signals that a target can be used as a constraint key. This is the only provider returned by a constraint_setting() target. .type attribute​ Produces &quot;ConstraintSettingInfo&quot; Details​ Provides a number of fields that can be accessed: label: target_label - field  "},{"title":"ConstraintValueInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#constraintvalueinfo","content":"def ConstraintValueInfo( *, setting: ConstraintSettingInfo, label: target_label ) -&gt; ConstraintValueInfo  Provider that signals that a target can be used as a constraint key. This is the only provider returned by a constraint_value() target. .type attribute​ Produces &quot;ConstraintValueInfo&quot; Details​ Provides a number of fields that can be accessed: setting: ConstraintSettingInfo - field label: target_label - field  "},{"title":"DefaultInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#defaultinfo","content":"def DefaultInfo( default_output: None | artifact = None, default_outputs: None | list[artifact] = None, other_outputs: list[artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | RunInfo] = _, sub_targets: dict[str, typing.Any] = _ ) -&gt; DefaultInfo  A provider that all rules' implementations must return .type attribute​ Produces &quot;DefaultInfo&quot; Details​ In many simple cases, this can be inferred for the user. Example of a rule's implementation function and how these fields are used by the framework: # //foo_binary.bzl def impl(ctx): ctx.action.run([ctx.attrs._cc[RunInfo], &quot;-o&quot;, ctx.attrs.out.as_output()] + ctx.attrs.srcs) ctx.action.run([ ctx.attrs._strip[RunInfo], &quot;--binary&quot;, ctx.attrs.out, &quot;--stripped-out&quot;, ctx.attrs.stripped.as_output(), &quot;--debug-symbols-out&quot;, ctx.attrs.debug_info.as_output(), ]) return [ DefaultInfo( sub_targets = { &quot;stripped&quot;: [ DefaultInfo(default_outputs = [ctx.attrs.stripped, ctx.attrs.debug_info]), ], }, default_output = ctx.attrs.out, ] foo_binary = rule( impl=impl, attrs={ &quot;srcs&quot;: attrs.list(attrs.source()), &quot;out&quot;: attrs.output(), &quot;stripped&quot;: attrs.output(), &quot;debug_info&quot;: attrs.output(), &quot;_cc&quot;: attrs.dep(default=&quot;//tools:cc&quot;, providers=[RunInfo]), &quot;_strip_script&quot;: attrs.dep(default=&quot;//tools:strip&quot;, providers=[RunInfo]) ) def foo_binary_wrapper(name, srcs): foo_binary( name = name, srcs = src, out = name, stripped = name + &quot;.stripped&quot;, debug_info = name + &quot;.debug_info&quot;, ) # //subdir/BUCK load(&quot;//:foo_binary.bzl&quot;, &quot;foo_binary_wrapper&quot;) genrule(name = &quot;gen_stuff&quot;, ...., default_outs = [&quot;foo.cpp&quot;]) # &quot;:gen_stuff&quot; pulls the default_outputs for //subdir:gen_stuff foo_binary_wrapper(name = &quot;foo&quot;, srcs = glob([&quot;*.cpp&quot;]) + [&quot;:gen_stuff&quot;]) # Builds just 'foo' binary. The strip command is never invoked. $ buck build //subdir:foo # builds the 'foo' binary, because it is needed by the 'strip' command. Ensures that # both the stripped binary and the debug symbols are built. $ buck build //subdir:foo[stripped]  Provides a number of fields that can be accessed: sub_targets: dict[str, provider_collection] - A mapping of names to ProviderCollections. The keys are used when resolving the ProviderName portion of a ProvidersLabel in order to access the providers for a subtarget, such as when doing buck2 build cell//foo:bar[baz]. Just like any ProviderCollection, this collection must include at least a DefaultInfo provider. The subtargets can have their own subtargets as well, which can be accessed by chaining them, e.g.: buck2 build cell//foo:bar[baz][qux]. default_outputs: list[artifact] - A list of Artifacts that are built by default if this rule is requested explicitly (via CLI or $(location) etc), or depended on as as a &quot;source&quot; (i.e., attrs.source()). other_outputs: list[artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | RunInfo] - A list of ArtifactTraversable. The underlying Artifacts they define will be built by default if this rule is requested (via CLI or $(location) etc), but not when it's depended on as as a &quot;source&quot; (i.e., attrs.source()). ArtifactTraversable can be an Artifact (which yields itself), or cmd_args, which expand to all their inputs.  "},{"title":"Dependency​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#dependency","content":"Dependency: type   "},{"title":"DynamicActions​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#dynamicactions","content":"DynamicActions: type   "},{"title":"DynamicActionsCallable​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#dynamicactionscallable","content":"DynamicActionsCallable: type   "},{"title":"DynamicValue​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#dynamicvalue","content":"DynamicValue: type   "},{"title":"ExecutionPlatformInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#executionplatforminfo","content":"def ExecutionPlatformInfo( *, label: target_label, configuration: ConfigurationInfo, executor_config: command_executor_config ) -&gt; ExecutionPlatformInfo  Provider that signals that a target represents an execution platform. Provides a number of fields that can be accessed: label: target_label - label of the defining rule, used in informative messages configuration: ConfigurationInfo - The configuration of the execution platform executor_config: command_executor_config - The executor config  "},{"title":"ExecutionPlatformRegistrationInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#executionplatformregistrationinfo","content":"def ExecutionPlatformRegistrationInfo( *, platforms: list[ExecutionPlatformInfo], fallback = None ) -&gt; ExecutionPlatformRegistrationInfo  Provider that gives the list of all execution platforms available for this build. Provides a number of fields that can be accessed: platforms: list[ExecutionPlatformInfo] - field fallback: typing.Any - field  "},{"title":"ExternalRunnerTestInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#externalrunnertestinfo","content":"def ExternalRunnerTestInfo( type, command = None, env = None, labels = None, contacts = None, use_project_relative_paths = None, run_from_project_root = None, default_executor = None, executor_overrides = None, local_resources = None, worker = None ) -&gt; ExternalRunnerTestInfo  Provider that signals that a rule can be tested using an external runner. This is the Buck1-compatible API for tests. .type attribute​ Produces &quot;ExternalRunnerTestInfo&quot; Details​ Provides a number of fields that can be accessed: test_type: str - A Starlark value representing the type of this test. command: list[typing.Any] - A Starlark value representing the command for this test. The external test runner is what gives meaning to this command. env: dict[str, typing.Any] - A Starlark value representing the environment for this test. Here again, the external test runner is what will this meaning. This is of type dict[str, ArgLike]. labels: list[str] - A starlark value representing the labels for this test. contacts: list[str] - A starlark value representing the contacts for this test. This is largely expected to be an oncall, though it's not validated in any way. use_project_relative_paths: bool - Whether this test should use relative paths run_from_project_root: bool - Whether this test should run from the project root, as opposed to the cell rootDefaults to True. default_executor: command_executor_config - Default executor to use to run tests. If none is passed we will default to the execution platform. executor_overrides: dict[str, command_executor_config] - Executors that Tpx can use to override the default executor. local_resources: dict[str, None | label] - Mapping from a local resource type to a target with a corresponding provider. Required types are passed from test runner. If the value for a corresponding type is omitted it means local resource should be ignored when executing tests even if those are passed as required from test runner. worker: WorkerInfo - Configuration needed to spawn a new worker. This worker will be used to run every single command related to test execution, including listing.  "},{"title":"InstallInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#installinfo","content":"def InstallInfo(installer: label, files: dict[str, artifact]) -&gt; InstallInfo  A provider that can be constructed and have its fields accessed. Returned by rules. Provides a number of fields that can be accessed: installer: label - field files: dict[str, artifact] - field  "},{"title":"Label​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#label","content":"Label: type   "},{"title":"LocalResourceInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#localresourceinfo","content":"def LocalResourceInfo( *, setup: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo, resource_env_vars: dict[str, str], setup_timeout_seconds: None | float | int = None ) -&gt; LocalResourceInfo  A provider that can be constructed and have its fields accessed. Returned by rules. .type attribute​ Produces &quot;LocalResourceInfo&quot; Details​ Provides a number of fields that can be accessed: setup: cmd_args - Command to run to initialize a local resource. Running this command writes a JSON to stdout. This JSON represents a pool of local resources which are ready to be used. Example JSON would be: { &quot;pid&quot;: 42, &quot;resources&quot;: [ {&quot;socket_address&quot;: &quot;foo:1&quot;}, {&quot;socket_address&quot;: &quot;bar:2&quot;} ] } Where '&quot;pid&quot;maps to a PID of a process which should be sent SIGTERM to release the pool of resources when they are no longer needed.&quot;resources&quot;maps to the pool of resources. When a local resource from this particular pool is needed for an execution command, single entity will be reserved from the pool, for example{&quot;socket_address&quot;: &quot;bar:2&quot;}and environment variable with name resolved using mapping inresource_env_varsfield and&quot;socket_address&quot;` key will be added to execution command. resource_env_vars: dict[str, str] - Mapping from environment variable (appended to an execution command which is dependent on this local resource) to keys in setup command JSON output. setup_timeout_seconds: None | float | int - Timeout in seconds for setup command.  "},{"title":"OutputArtifact​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#outputartifact","content":"OutputArtifact: type   "},{"title":"PlatformInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#platforminfo","content":"def PlatformInfo( *, label: str, configuration: ConfigurationInfo ) -&gt; PlatformInfo  A provider that can be constructed and have its fields accessed. Returned by rules. .type attribute​ Produces &quot;PlatformInfo&quot; Details​ Provides a number of fields that can be accessed: label: str - field configuration: ConfigurationInfo - field  "},{"title":"ProjectRoot​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#projectroot","content":"ProjectRoot: type   "},{"title":"Promise​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#promise","content":"Promise: type   "},{"title":"Provider​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#provider","content":"Provider: type   "},{"title":"ProviderCollection​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#providercollection","content":"ProviderCollection: type   "},{"title":"ProvidersLabel​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#providerslabel","content":"ProvidersLabel: type   "},{"title":"ResolvedDynamicValue​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#resolveddynamicvalue","content":"ResolvedDynamicValue: type   "},{"title":"ResolvedStringWithMacros​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#resolvedstringwithmacros","content":"ResolvedStringWithMacros: type   "},{"title":"RunInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#runinfo","content":"def RunInfo( args: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo = _ ) -&gt; RunInfo  Provider that signals that a rule is runnable .type attribute​ Produces &quot;RunInfo&quot; Details​ Provides a number of fields that can be accessed: args: cmd_args - The command to run, stored as CommandLine  "},{"title":"Select​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#select","content":"Select: type   "},{"title":"TargetLabel​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#targetlabel","content":"TargetLabel: type   "},{"title":"TemplatePlaceholderInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#templateplaceholderinfo","content":"def TemplatePlaceholderInfo( unkeyed_variables = {}, keyed_variables = {} ) -&gt; TemplatePlaceholderInfo  A provider that is used for expansions in string attribute templates .type attribute​ Produces &quot;TemplatePlaceholderInfo&quot; Details​ String attribute templates allow two types of user-defined placeholders, &quot;unkeyed placeholders&quot; like $(CXX) or $(aapt) and &quot;keyed placeholders&quot; that include a target key like$(cxxppflags //some:target). The expansion of each of these types is based on theTemplatePlaceholderInfo providers. &quot;keyed placeholders&quot; are used for the form $(&lt;key&gt; &lt;target&gt;) or $(&lt;key&gt; &lt;target&gt; &lt;arg&gt;). In both cases the lookup will expect a TemplatePlaceholderInfo in the providers of &lt;target&gt;. It will then lookup&lt;key&gt; in the keyed_variables (call this the value). There are then four valid possibilities: no-arg placeholder, an arg-like value: resolve to valueno-arg placeholder, a dictionary value: resolve to value[&quot;DEFAULT&quot;]arg placeholder, a non-dictionary value: this is an errorarg placeholder, a dictionary value: resolve to value[&lt;arg&gt;] &quot;unkeyed placeholders&quot; are resolved by matching to any of the deps of the target. $(CXX) will resolve to the &quot;CXX&quot; value in any dep's TemplateProviderInfo.unkeyed_variables Fields: unkeyed_variables: A mapping of names to arg-like values. These are used for &quot;unkeyed placeholder&quot; expansion.keyed_variables: A mapping of names to arg-like values or dictionary of string to arg-like values. These are used for &quot;keyed placeholder&quot; expansion. Provides a number of fields that can be accessed: unkeyed_variables: dict[str, typing.Any] - field keyed_variables: dict[str, typing.Any] - field  "},{"title":"TransitiveSet​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#transitiveset","content":"TransitiveSet: type   "},{"title":"TransitiveSetArgsProjection​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#transitivesetargsprojection","content":"TransitiveSetArgsProjection: type   "},{"title":"TransitiveSetArgsProjectionIterator​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#transitivesetargsprojectioniterator","content":"TransitiveSetArgsProjectionIterator: type   "},{"title":"TransitiveSetDefinition​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#transitivesetdefinition","content":"TransitiveSetDefinition: type   "},{"title":"TransitiveSetIterator​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#transitivesetiterator","content":"TransitiveSetIterator: type   "},{"title":"TransitiveSetJsonProjection​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#transitivesetjsonprojection","content":"TransitiveSetJsonProjection: type   "},{"title":"ValidationInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#validationinfo","content":"def ValidationInfo(*, validations: list[ValidationSpec]) -&gt; ValidationInfo  Provider describing how a given target node should be validated. Validations are run when target with ValidationInfo provider is a transitive dependency of a requested target. .type attribute​ Produces &quot;ValidationInfo&quot; Details​ Provides a number of fields that can be accessed: validations: list[ValidationSpec] - List of ValidationSpec values each representing a single validation.  "},{"title":"ValidationSpec​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#validationspec","content":"def ValidationSpec( *, name: str, validation_result: artifact, optional: bool = False ) -&gt; ValidationSpec  .type attribute​ Produces &quot;ValidationSpec&quot;  "},{"title":"WorkerInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#workerinfo","content":"def WorkerInfo(exe = [], *, concurrency: None | int = None) -&gt; WorkerInfo  Provider that signals that a rule is a worker tool .type attribute​ Produces &quot;WorkerInfo&quot; Details​ Provides a number of fields that can be accessed: exe: cmd_args - field concurrency: None | int - field  "},{"title":"WorkerRunInfo​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#workerruninfo","content":"def WorkerRunInfo(*, worker: WorkerInfo, exe = []) -&gt; WorkerRunInfo  Provider that signals that a rule can run using a worker .type attribute​ Produces &quot;WorkerRunInfo&quot; Details​ Provides a number of fields that can be accessed: worker: WorkerInfo - field exe: cmd_args - field  "},{"title":"anon_rule​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#anon_rule","content":"def anon_rule( *, impl: typing.Callable[[typing.Any], list[typing.Any]], attrs: dict[str, attribute], doc: str = &quot;&quot;, artifact_promise_mappings: dict[str, typing.Callable[[typing.Any], list[typing.Any]]] ) -&gt; &quot;function&quot;  Define an anon rule, similar to how a normal rule is defined, except with an extra artifact_promise_mappings field. This is a dict where the keys are the string name of the artifact, and the values are the callable functions that produce the artifact. This is only intended to be used with anon targets.  "},{"title":"attrs​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#attrs","content":"attrs: attrs   "},{"title":"bxl​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#bxl","content":"bxl: struct(ActionQueryNode = type, Actions = type, AnalysisResult = type, AqueryContext = type, AuditContext = type, BuildResult = type, CliArgs = type, ConfiguredTargetNode = type, ConfiguredTargetSet = type, Context = type, CqueryContext = type, EnsuredArtifact = type, FileNode = type, Filesystem = type, LazyResolvedAttrs = type, OutputStream = type, TargetUniverse = type, UnconfiguredTargetNode = type, UnconfiguredTargetSet = type, UqueryContext = type, cli_args = struct(bool = &quot;function&quot;, enum = &quot;function&quot;, float = &quot;function&quot;, int = &quot;function&quot;, json = &quot;function&quot;, list = &quot;function&quot;, option = &quot;function&quot;, string = &quot;function&quot;, sub_target = &quot;function&quot;, sub_target_expr = &quot;function&quot;, target_expr = &quot;function&quot;, target_label = &quot;function&quot;), ctarget_set = &quot;function&quot;, fail_no_stacktrace = &quot;function&quot;, file_set = &quot;function&quot;, get_path_without_materialization = &quot;function&quot;, get_paths_without_materialization = &quot;function&quot;, now = &quot;function&quot;, utarget_set = &quot;function&quot;)   "},{"title":"bxl_main​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#bxl_main","content":"def bxl_main( *, impl: typing.Callable, cli_args: dict[str, bxl.CliArgs], doc: str = &quot;&quot; )   "},{"title":"cli_args​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#cli_args","content":"cli_args: struct(bool = &quot;function&quot;, enum = &quot;function&quot;, float = &quot;function&quot;, int = &quot;function&quot;, json = &quot;function&quot;, list = &quot;function&quot;, option = &quot;function&quot;, string = &quot;function&quot;, sub_target = &quot;function&quot;, sub_target_expr = &quot;function&quot;, target_expr = &quot;function&quot;, target_label = &quot;function&quot;)   "},{"title":"cmd_args​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#cmd_args","content":"def cmd_args( *args: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo, hidden: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo = _, delimiter: str = _, format: str = _, prepend: str = _, quote: str = _, ignore_artifacts: bool = False, absolute_prefix: str = _, absolute_suffix: str = _, parent: int = 0, relative_to: artifact | cell_root | project_root | (artifact | cell_root | project_root, int) = _, replace_regex: list[(buck_regex | str, str)] | (buck_regex | str, str) = _ ) -&gt; cmd_args  The cmd_args type is created by this function and is consumed by ctx.actions.run. The type is a mutable collection of strings and artifact values. In general, command lines, artifacts, strings, RunInfo and lists thereof can be added to or used to construct a cmd_args value. .type attribute​ Produces &quot;cmd_args&quot; Details​ The arguments are: *args - a list of things to add to the command line, each of which must be coercible to a command line. Further items can be added with cmd.add.format - a string that provides a format to apply to the argument. for example, cmd_args(x, format=&quot;--args={}&quot;) would prepend --args= before x, or if x was a list, before each element in x.delimiter - added between arguments to join them together. For example, cmd_args([&quot;--args=&quot;,x], delimiter=&quot;&quot;) would produce a single argument to the underlying tool.prepend - added as a separate argument before each argument.quote - indicates whether quoting is to be applied to each argument. The only current valid value is &quot;shell&quot;.ignore_artifacts - if True, artifacts paths are used, but artifacts are not pulled.hidden - artifacts not present on the command line, but added as dependencies.absolute_prefix and absolute_suffix - added to the start and end of each artifact.parent - for all the artifacts use their parentth directory (e.g. parent = 1 for the directory the artifact is located, parent = 2 for that directory's parent, etc.).relative_to - make all artifact paths relative to a given location.replace_regex - replaces arguments with a regular expression. "},{"title":"ignore_artifacts​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#ignore_artifacts","content":"ignore_artifacts=True makes cmd_args to have no declared dependencies. Allows you to reference the path of an artifact without introducing dependencies on it. As an example where this can be useful, consider passing a dependency that is only accessed at runtime, but whose path must be baked into the binary. As an example: resources = cmd_args(resource_file, format = &quot;-DFOO={}&quot;).ignore_artifacts() ctx.actions.run(cmd_args(&quot;gcc&quot;, &quot;-c&quot;, source_file, resources))  Note that ignore_artifacts sets all artifacts referenced by this cmd_args to be ignored, including those added afterwards, so generally create a special cmd_args and scope it quite tightly. If you actually do use the inputs referenced by this command, you will either error out due to missing dependencies (if running actions remotely) or have untracked dependencies that will fail to rebuild when it should. "},{"title":"hidden​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#hidden","content":"Things to add to the command line which do not show up but are added as dependencies. The values can be anything normally permissible to pass to add. Typically used if the command you are running implicitly depends on files that are not passed on the command line, e.g. headers in the case of a C compilation. "},{"title":"absolute_prefix and absolute_suffix​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#absolute_prefix-and-absolute_suffix","content":"Adds a prefix to the start or end of every artifact. Prefix is often used if you have a $ROOT variable in a shell script and want to use it to make files absolute. Suffix is often used in conjunction with absolute_prefixto wrap artifacts in function calls. cmd_args(script, absolute_prefix = &quot;$ROOT/&quot;) cmd_args(script, absolute_prefix = &quot;call&quot;, absolute_suffix = &quot;)&quot;)  `parent ` For all the artifacts use their parent directory. Typically used when the file name is passed one way, and the directory another, e.g. cmd_args(artifact, format=&quot;-L{}&quot;, parent=1). relative_to=dir or relative_to=(dir, parent) Make all artifact paths relative to a given location. Typically used when the command you are running changes directory. By default, the paths are relative to the artifacts themselves (equivalent to parent equals to 0). Use parent to make the paths relative to an ancestor directory. For example parent equals to 1 would make all paths relative to the containing dirs of any artifacts in the cmd_args. dir = symlinked_dir(...) script = [ cmd_args(dir, format = &quot;cd {}&quot;, relative_to=dir), ]  replace_regex Replaces all parts matching pattern regular expression (or regular expressions) in each argument with replacement strings.  "},{"title":"ctarget_set​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#ctarget_set","content":"def ctarget_set(nodes: list[bxl.ConfiguredTargetNode] = _) -&gt; target_set  Creates a target set from a list of configured nodes. Sample usage: def _impl_ctarget_set(ctx): targets = bxl.ctarget_set([cnode_a, cnode_b]) ctx.output.print(type(targets)) ctx.output.print(len(targets))   "},{"title":"dedupe​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#dedupe","content":"def dedupe(val, /)  Remove duplicates in a list. Uses identity of value (pointer), rather than by equality. In many cases you should use a transitive set instead.  "},{"title":"dynamic_actions​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#dynamic_actions","content":"def dynamic_actions( *, impl: typing.Callable[&quot;actions: actions, artifacts: dict[artifact, artifact_value], dynamic_values: dict[typing.Any, typing.Any], outputs: dict[artifact, artifact], arg: typing.Any&quot;, list[typing.Any]] ) -&gt; DynamicActionCallable  Create new dynamic action callable. Returned object will be callable, and the result of calling it can be passed to ctx.actions.dynamic_output_new.  "},{"title":"fail_no_stacktrace​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#fail_no_stacktrace","content":"def fail_no_stacktrace(*args) -&gt; None   "},{"title":"file_set​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#file_set","content":"def file_set() -&gt; file_set  Creates an empty file set for configured nodes. Sample usage: def _impl_file_set(ctx): files = file_set() ctx.output.print(type(files)) ctx.output.print(len(files))   "},{"title":"get_base_path​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#get_base_path","content":"def get_base_path() -&gt; str  get_base_path() can only be called in buildfiles (e.g. BUCK files) or PACKAGE files, and returns the name of the package. E.g. inside foo//bar/baz/BUCK the output will be bar/baz. E.g. inside foo//bar/PACKAGE the output will be bar. This function is identical to package_name.  "},{"title":"get_cell_name​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#get_cell_name","content":"def get_cell_name() -&gt; str  get_cell_name() can be called from either a BUCK file or a .bzl file, and returns the name of the cell where the BUCK file that started the call lives. For example, inside foo//bar/baz/BUCK the output will be foo. If that BUCK file does a load(&quot;hello//world.bzl&quot;, &quot;something&quot;) then the result in that .bzl file will also be foo.  "},{"title":"get_path_without_materialization​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#get_path_without_materialization","content":"def get_path_without_materialization( this: artifact, ctx: bxl.Context, /, *, abs: bool = False ) -&gt; str  The output path of an artifact-like (source, build, declared). Takes an optional boolean to print the absolute or relative path. Note that this method returns an artifact path without asking for the artifact to be materialized (i.e. it may not actually exist on the disk yet). This is a risky function to call because you may accidentally pass this path to further BXL actions that expect the artifact to be materialized. If this happens, the BXL script will error out. If you want the path without materialization for other uses that don’t involve passing them into further actions, then it’s safe. Sample usage: def _impl_get_path_without_materialization(ctx): owner = ctx.cquery().owner(&quot;cell//path/to/file&quot;)[0] artifact = owner.get_source(&quot;cell//path/to/file&quot;, ctx) source_artifact_project_rel_path = get_path_without_materialization(artifact, ctx) ctx.output.print(source_artifact_project_rel_path) # Note this artifact is NOT ensured or materialized   "},{"title":"get_paths_without_materialization​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#get_paths_without_materialization","content":"def get_paths_without_materialization( cmd_line: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | RunInfo, ctx: bxl.Context, /, *, abs: bool = False )  The output paths of a cmd_args() inputs. The output paths will be returned as a list. Takes an optional boolean to print the absolute or relative path. Note that this method returns an artifact path without asking for the artifact to be materialized, (i.e. it may not actually exist on the disk yet). This is a risky function to call because you may accidentally pass this path to further BXL actions that expect the artifact to be materialized. If this happens, the BXL script will error out. If you want the path without materialization for other uses that don’t involve passing them into further actions, then it’s safe. Sample usage: def _impl_get_paths_without_materialization(ctx): node = ctx.configured_targets(&quot;root//bin:the_binary&quot;) providers = ctx.analysis(node).providers() path = get_paths_without_materialization(providers[RunInfo], abs=True) # Note this artifact is NOT ensured or materialized ctx.output.print(path)   "},{"title":"glob​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#glob","content":"def glob( include: list[str] | tuple[str, ...], *, exclude: list[str] | tuple[str, ...] = [] ) -&gt; list[str]  The glob() function specifies a set of files using patterns. Only available from BUCK files. A typical glob call looks like: glob([&quot;foo/**/*.h&quot;])  This call will match all header files in the foo directory, recursively. You can also pass a named exclude parameter to remove files matching a pattern: glob([&quot;foo/**/*.h&quot;], exclude = [&quot;**/config.h&quot;])  This call will remove all config.h files from the initial match. The glob() call is evaluated against the list of files owned by this BUCK file. A file is owned by whichever BUCK file is closest above it - so given foo/BUCK andfoo/bar/BUCK the file foo/file.txt would be owned by foo/BUCK (and available from its glob results) but the file foo/bar/file.txt would be owned by foo/bar/BUCkand not appear in the glob result of foo/BUCK, even if you write glob([&quot;bar/file.txt&quot;]). As a consequence of this rule, glob([&quot;../foo.txt&quot;]) will always return an empty list of files. Currently glob is evaluated case-insensitively on all file systems, but we expect that to change to case sensitive in the near future.  "},{"title":"host_info​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#host_info","content":"def host_info() -&gt; struct(..)  The host_info() function is used to get the current OS and processor architecture on the host. The structure returned is laid out thusly: struct( os=struct( is_linux=True|False, is_macos=True|False, is_windows=True|False, is_freebsd=True|False, is_unknown=True|False, ), arch=struct( is_aarch64=True|False, is_arm=True|False, is_armeb=True|False, is_i386=True|False, is_mips=True|False, is_mips64=True|False, is_mipsel=True|False, is_mipsel64=True|False, is_powerpc=True|False, is_ppc64=True|False, is_x86_64=True|False, is_unknown=True|False, ), )   "},{"title":"implicit_package_symbol​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#implicit_package_symbol","content":"def implicit_package_symbol(name: str, default = _)   "},{"title":"load_symbols​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#load_symbols","content":"def load_symbols(symbols: dict[str, typing.Any]) -&gt; None  Used in a .bzl file to set exported symbols. In most cases just defining the symbol as a top-level binding is sufficient, but sometimes the names might be programatically generated. It is undefined behaviour if you try and use any of the symbols exported here later in the same module, or if they overlap with existing definitions. This function should be used rarely.  "},{"title":"now​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#now","content":"def now() -&gt; instant  Creates an Instant at the current time. Sample usage: def _impl_elapsed_millis(ctx): instant = now() time_a = instant.elapsed_millis() # do something that takes a long time time_b = instant.elapsed_millis() ctx.output.print(time_a) ctx.output.print(time_b)  This function is only accessible through Bxl.  "},{"title":"oncall​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#oncall","content":"def oncall(name: str, /) -&gt; None  Called in a BUCK file to declare the oncall contact details for all the targets defined. Must be called at most once, before any targets have been declared. Errors if called from a .bzl file.  "},{"title":"package​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#package","content":"def package( *, inherit: bool = False, visibility: list[str] | tuple[str, ...] = [], within_view: list[str] | tuple[str, ...] = [] ) -&gt; None   "},{"title":"package_name​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#package_name","content":"def package_name() -&gt; str  package_name() can only be called in buildfiles (e.g. BUCK files) or PACKAGE files, and returns the name of the package. E.g. inside foo//bar/baz/BUCK the output will be bar/baz. E.g. inside foo//bar/PACKAGE the output will be bar.  "},{"title":"plugins​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#plugins","content":"plugins: plugins   "},{"title":"provider​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#provider-1","content":"def provider( *, doc: str = &quot;&quot;, fields: list[str] | tuple[str, ...] | dict[str, typing.Any] ) -&gt; provider_callable  Create a &quot;provider&quot; type that can be returned from rule implementations. Used to pass information from a rule to the things that depend on it. Typically named with an Info suffix. GroovyLibraryInfo(fields = [ &quot;objects&quot;, # a list of artifacts &quot;options&quot;, # a string containing compiler options ])  Given a dependency you can obtain the provider with my_dep[GroovyLibraryInfo]which returns either None or a value of type GroovyLibraryInfo. For providers that accumulate upwards a transitive set is often a good choice.  "},{"title":"provider_field​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#provider_field","content":"def provider_field( ty, /, *, default = _ ) -&gt; ProviderField  Create a field definition object which can be passed to provider type constructor.  "},{"title":"read_config​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#read_config","content":"def read_config(section: str, key: str, default = _)  Read a configuration from the nearest enclosing .buckconfig of the BUCK file that started evaluation of this code. As an example, if you have a .buckconfig of: [package_options] compile = super_fast  Then you would get the following results: read_config(&quot;package_options&quot;, &quot;compile&quot;) == &quot;super_fast&quot; read_config(&quot;package_options&quot;, &quot;linker&quot;) == None read_config(&quot;package_options&quot;, &quot;linker&quot;, &quot;a_default&quot;) == &quot;a_default&quot;  In general the use of .buckconfig is discouraged in favour of select, but it can still be useful.  "},{"title":"read_oncall​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#read_oncall","content":"def read_oncall() -&gt; None | str  Called in a BUCK file to retrieve the previously set oncall, or None if none has been set. It is an error to call oncall after calling this function.  "},{"title":"read_package_value​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#read_package_value","content":"def read_package_value(key: str, /)  Read value specified in the PACKAGE file. Returns None if value is not set.  "},{"title":"read_parent_package_value​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#read_parent_package_value","content":"def read_parent_package_value(key: str, /)  Read a package value defined in a parent PACKAGE file. This function can only be called in a Package context. Returns None if value is not set.  "},{"title":"read_root_config​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#read_root_config","content":"def read_root_config( section: str, key: str, default: None | str = None, / ) -&gt; None | str  Like read_config but the project root .buckconfig is always consulted, regardless of the cell of the originating BUCK file.  "},{"title":"regex​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#regex","content":"def regex( regex: str, /, *, fancy: bool = False ) -&gt; buck_regex  .type attribute​ Produces &quot;buck_regex&quot;  "},{"title":"regex_match​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#regex_match","content":"def regex_match(regex: str, str: str, /) -&gt; bool  Test if a regular expression matches a string. Fails if the regular expression is malformed. As an example: regex_match(&quot;^[a-z]*$&quot;, &quot;hello&quot;) == True regex_match(&quot;^[a-z]*$&quot;, &quot;1234&quot;) == False   "},{"title":"repository_name​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#repository_name","content":"def repository_name() -&gt; str  Like get_cell_name() but prepends a leading @ for compatibility with Buck1. You should call get_cell_name() instead, and if you really want the @, prepend it yourself.  "},{"title":"rule​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#rule","content":"def rule( *, impl: typing.Callable[[typing.Any], list[typing.Any]], attrs: dict[str, attribute], cfg = _, doc: str = &quot;&quot;, is_configuration_rule: bool = False, is_toolchain_rule: bool = False, uses_plugins: list[typing.Any] | tuple = [] ) -&gt; &quot;function&quot;  Define a rule. As a simple example: def _my_rule(ctx: AnalysisContext) -&gt; list[Provider]: output = ctx.actions.write(&quot;hello.txt&quot;, ctx.attrs.contents, executable = ctx.attrs.exe) return [DefaultInfo(outputs = [output])] MyRule = rule(impl = _my_rule, attrs = { &quot;contents&quot;: attrs.string(), &quot;exe&quot;: attrs.option(attrs.bool(), default = False), })   "},{"title":"rule_exists​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#rule_exists","content":"def rule_exists(name: str) -&gt; bool  Check if the target with name has already been defined, returns True if it has. Note that this function checks for the existence of a target rather than a rule. In general use of this function is discouraged, as it makes definitions of rules not compose.  "},{"title":"select​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#select-1","content":"def select(d, /) -&gt; selector   "},{"title":"select_equal_internal​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#select_equal_internal","content":"def select_equal_internal(left, right, /) -&gt; bool  Tests that two selects are equal to each other. For testing use only. We simply compare their string representations.  "},{"title":"select_map​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#select_map","content":"def select_map(d, func, /)  Maps a selector. Each value within a selector map and on each side of an addition will be passed to the mapping function. The returned selector will have the same structure as this one. Ex: def increment_items(a): return [v + 1 for v in a] select_map([1, 2] + select({&quot;c&quot;: [2]}), increment_items) == [2, 3] + select({&quot;c&quot;: [3]})   "},{"title":"select_test​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#select_test","content":"def select_test(d, func, /) -&gt; bool  Test values in the select expression using the given function. Returns True, if any value in the select passes, else False. Ex: select_test([1] + select({&quot;c&quot;: [1]}), lambda a: len(a) &gt; 1) == False select_test([1, 2] + select({&quot;c&quot;: [1]}), lambda a: len(a) &gt; 1) == True select_test([1] + select({&quot;c&quot;: [1, 2]}), lambda a: len(a) &gt; 1) == True   "},{"title":"set_cfg_constructor​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#set_cfg_constructor","content":"def set_cfg_constructor( *, stage0, stage1, key: str, aliases = None, extra_data = None ) -&gt; None  Register global cfg constructor. This function can only be called from the repository root PACKAGE file. Parameters: stage0: The first cfg constructor that will be invoked before configuration rules are analyzed. stage1: The second cfg constructor that will be invoked after configuration rules are analyzed. key: The key for cfg modifiers on PACKAGE values and metadata. aliases: The aliases map to use for input modifiers. extra_data: Some extra data that may be used by set_cfg_constructor implementation that is custom to our implementation and may not be used in other context like open-source.  "},{"title":"set_starlark_peak_allocated_byte_limit​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#set_starlark_peak_allocated_byte_limit","content":"def set_starlark_peak_allocated_byte_limit(value: int, /) -&gt; None  Set the peak allocated bytes during evaluation of build ctx. Err if it has already been set  "},{"title":"sha256​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#sha256","content":"def sha256(val: str, /) -&gt; str  Computes a sha256 digest for a string. Returns the hex representation of the digest. sha256(&quot;Buck2 is the best build system&quot;) == &quot;bb99a3f19ecba6c4d2c7cd321b63b669684c713881baae21a6b1d759b3ec6ac9&quot;   "},{"title":"soft_error​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#soft_error","content":"def soft_error( category: str, message: str, /, *, quiet: bool = _, stack: bool = _ ) -&gt; None  Produce an error that will become a hard error at some point in the future, but for now is a warning which is logged to the server. In the open source version of Buck2 this function always results in an error. Called passing a stable key (must be snake_case and start with starlark_, used for consistent reporting) and an arbitrary message (used for debugging). As an example: soft_error( &quot;starlark_rule_is_too_long&quot;, &quot;Length of property exceeds 100 characters in &quot; + repr(ctx.label), )   "},{"title":"transition​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#transition","content":"def transition( *, impl: typing.Callable, refs: dict[str, str], attrs: list[str] | tuple[str, ...] = _, split: bool = False ) -&gt; transition   "},{"title":"transitive_set​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#transitive_set","content":"def transitive_set( *, args_projections: dict[str, typing.Any] = _, json_projections: dict[str, typing.Any] = _, reductions: dict[str, typing.Any] = _ ) -&gt; transitive_set_definition   "},{"title":"utarget_set​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#utarget_set","content":"def utarget_set(nodes: list[bxl.UnconfiguredTargetNode] = _) -&gt; target_set  Creates a target set from a list of unconfigured nodes. Sample usage: def _impl_utarget_set(ctx): targets = bxl.utarget_set([unode_a, unode_b]) ctx.output.print(type(targets)) ctx.output.print(len(targets))   "},{"title":"warning​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#warning","content":"def warning(x: str, /) -&gt; None  Print a warning. The line will be decorated with the timestamp and other details, including the word WARN (colored, if the console supports it). If you are not writing a warning, use print instead. Be aware that printing lots of output (warnings or not) can be cause all information to be ignored by the user.  "},{"title":"write_package_value​","type":1,"pageTitle":"globals","url":"/docs/api/build/globals/#write_package_value","content":"def write_package_value( key: str, value, /, *, overwrite: bool = False ) -&gt; None  Set the value to be accessible in the nested PACKAGE files. If any parent PACKAGE value has already set the same key, it will raise an error unless you pass overwrite = True, in which case it will replace the parent value. "},{"title":"bxl.AuditContext type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.AuditContext/","content":"","keywords":""},{"title":"bxl.AuditContext.cell​","type":1,"pageTitle":"bxl.AuditContext type","url":"/docs/api/bxl/bxl.AuditContext/#bxlauditcontextcell","content":"def bxl.AuditContext.cell( aliases_to_resolve: list[str] | tuple[str, ...] = [], *, aliases: bool = False ) -&gt; dict[str, str]  Query information about the [cells] list in .buckconfig. Takes the following parameters: aliases_to_resolve - list of cell aliases to query. These aliases will be resolved in the root cell of the BXL script.optional aliases flag - if enabled, and no explicit aliases are passed, will query for all aliases in the root cell of the BXL script. Returns a dict of cell name to absolute path mappings. Sample usage: def _impl_audit_cell(ctx): result = ctx.audit().cell(aliases = True) ctx.output.print(result)   "},{"title":"bxl.AuditContext.output​","type":1,"pageTitle":"bxl.AuditContext type","url":"/docs/api/bxl/bxl.AuditContext/#bxlauditcontextoutput","content":"def bxl.AuditContext.output( output_path: str, target_platform: None | str | target_label = _ )  Returns either: - The action which created the buck-out path, if exists. - The unconfigured_target_label constructed from the buck-out path, if the configuration hashes do not match. - None, if the configuration hash of the buck-out path matches the one passed into this function, or the default target configuration, but no action could be found that generated the buck-out path. Takes in an optional target platform, otherwise will use the default target platform. Sample usage: def _impl_audit_output(ctx): target_platform = &quot;foo&quot; result = ctx.audit().output(&quot;buck-out/v2/gen/fbcode/some_cfg_hash/path/to/__target__/artifact&quot;, target_platform) ctx.output.print(result)  "},{"title":"bxl.BuildResult type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.BuildResult/","content":"","keywords":""},{"title":"bxl.BuildResult.artifacts​","type":1,"pageTitle":"bxl.BuildResult type","url":"/docs/api/bxl/bxl.BuildResult/#bxlbuildresultartifacts","content":"def bxl.BuildResult.artifacts() -&gt; None | bxl_built_artifacts_iterable  Returns an optional iterable of artifacts that was successfully built. Sample usage: def _impl(ctx): outputs = {} for target, value in ctx.build(ctx.cli_args.target).items(): ctx.output.print(value.artifacts())   "},{"title":"bxl.BuildResult.failures​","type":1,"pageTitle":"bxl.BuildResult type","url":"/docs/api/bxl/bxl.BuildResult/#bxlbuildresultfailures","content":"def bxl.BuildResult.failures() -&gt; None | bxl_failed_artifacts_iterable  Returns an optional of iterable of artifacts that failed to be built. Sample usage: def _impl(ctx): outputs = {} for target, value in ctx.build(ctx.cli_args.target).items(): ctx.output.print(value.failures())  "},{"title":"bxl.AqueryContext type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.AqueryContext/","content":"","keywords":""},{"title":"bxl.AqueryContext.all_actions​","type":1,"pageTitle":"bxl.AqueryContext type","url":"/docs/api/bxl/bxl.AqueryContext/#bxlaquerycontextall_actions","content":"def bxl.AqueryContext.all_actions( targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label | target_set | target_set | target_set | target_set | list[bxl.ActionQueryNode | bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label] ) -&gt; target_set  Obtain all the actions declared within the analysis of a given target. This operation only makes sense on a target literal (it is a simple passthrough when passed an action).  "},{"title":"bxl.AqueryContext.all_outputs​","type":1,"pageTitle":"bxl.AqueryContext type","url":"/docs/api/bxl/bxl.AqueryContext/#bxlaquerycontextall_outputs","content":"def bxl.AqueryContext.all_outputs( targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label | target_set | target_set | target_set | target_set | list[bxl.ActionQueryNode | bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label] ) -&gt; target_set  Obtain the actions for all the outputs provided by the DefaultInfo for the targets passed as input. This includes both the default_outputs and other_outputs. This operation only makes sense on a target literal (it does nothing if passed something else).  "},{"title":"bxl.AqueryContext.attrfilter​","type":1,"pageTitle":"bxl.AqueryContext type","url":"/docs/api/bxl/bxl.AqueryContext/#bxlaquerycontextattrfilter","content":"def bxl.AqueryContext.attrfilter( attr: str, value: str, targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label | target_set | target_set | target_set | target_set | list[bxl.ActionQueryNode | bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label] ) -&gt; target_set  The attrfilter query for rule attribute filtering.  "},{"title":"bxl.AqueryContext.deps​","type":1,"pageTitle":"bxl.AqueryContext type","url":"/docs/api/bxl/bxl.AqueryContext/#bxlaquerycontextdeps","content":"def bxl.AqueryContext.deps( universe: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label | target_set | target_set | target_set | target_set | list[bxl.ActionQueryNode | bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label], depth: None | int = None, filter: None | str = None ) -&gt; target_set  The deps query for finding the transitive closure of dependencies.  "},{"title":"bxl.AqueryContext.eval​","type":1,"pageTitle":"bxl.AqueryContext type","url":"/docs/api/bxl/bxl.AqueryContext/#bxlaquerycontexteval","content":"def bxl.AqueryContext.eval( query: str, query_args: None | target_set | list[str] = None )  Evaluates some general query string. query_args can be a target_set of unconfigured nodes, or a list of strings. Returns a dict of target labels mapped to their target_set results if query_args was passed in, otherwise returns a single target_set. Sample usage: def _impl_eval(ctx): result = ctx.aquery().eval(&quot;:foo&quot;) ctx.output.print(result)  "},{"title":"bxl.ConfiguredTargetNode type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/","content":"","keywords":""},{"title":"bxl.ConfiguredTargetNode.attrs_eager​","type":1,"pageTitle":"bxl.ConfiguredTargetNode type","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/#bxlconfiguredtargetnodeattrs_eager","content":"def bxl.ConfiguredTargetNode.attrs_eager()  Returns a struct of all the attributes of this target node. The structs fields are the attributes names, and the values are [StarlarkConfiguredAttr]. If you need to access many or all attrs on the same node, then this is the preferred way. Otherwise, using attrs_lazy() would be a better option for only accessing only a few attrs, although this really depends on what kind of attrs are on the node. Benchmarking performance will give you the best indication on which method to use. You should store the result of this function call for further usage in the code rather than callingattrs_eager() each time you need to access the attrs. Sample usage: def _impl_attrs_eager(ctx): node = ctx.cquery().owner(&quot;cell//path/to/TARGETS&quot;)[0] attrs = node.attrs_eager() # cache once ctx.output.print(attrs) # do more stuff with attrs   "},{"title":"bxl.ConfiguredTargetNode.attrs_lazy​","type":1,"pageTitle":"bxl.ConfiguredTargetNode type","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/#bxlconfiguredtargetnodeattrs_lazy","content":"def bxl.ConfiguredTargetNode.attrs_lazy() -&gt; lazy_attrs  Returns a lazy_attrs object that you can call get() on that gets an attr one at a time. If you need to access only few attrs on the same node, then this is the preferred way. Otherwise, using attrs_eager() would be a better option for accessing many or all attrs, although this really depends on what kind of attrs are on the node. Benchmarking performance will give you the best indication on which method to use. You should store the result of this function call for further usage in the code rather than callingattrs_lazy() each time to get the lazy_attrs object. Note that if the get() is None, then any methods called on None will result in an error. Sample usage: def _impl_attrs_lazy(ctx): node = ctx.cquery().owner(&quot;cell//path/to/TARGETS&quot;)[0] attrs = node.attrs_lazy() # cache once ctx.output.print(attrs.get(&quot;some_attributes&quot;).value()) ctx.output.print(attrs.get(&quot;some_attribute&quot;).label)   "},{"title":"bxl.ConfiguredTargetNode.buildfile_path​","type":1,"pageTitle":"bxl.ConfiguredTargetNode type","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/#bxlconfiguredtargetnodebuildfile_path","content":"bxl.ConfiguredTargetNode.buildfile_path: bxl.FileNode  Gets the buildfile path from the configured target node. Sample usage: def _impl_label(ctx): target_node = ctx.cquery().eval(&quot;owner('path/to/file')&quot;)[0] ctx.output.print(target_node.buildfile_path)   "},{"title":"bxl.ConfiguredTargetNode.get_source​","type":1,"pageTitle":"bxl.ConfiguredTargetNode type","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/#bxlconfiguredtargetnodeget_source","content":"def bxl.ConfiguredTargetNode.get_source( path: str, ctx: bxl.Context ) -&gt; None | artifact  Gets the source Artifact that corresponds to the given path given a context. The path should be the project relative path to the file, or an absolute path. Sample usage: def _impl_get_source(ctx): owner = ctx.cquery().owner(&quot;project/relative/path/to/file&quot;)[0] artifact = owner.sources()[0] ctx.output.print(artifact)   "},{"title":"bxl.ConfiguredTargetNode.label​","type":1,"pageTitle":"bxl.ConfiguredTargetNode type","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/#bxlconfiguredtargetnodelabel","content":"bxl.ConfiguredTargetNode.label: configured_target_label  Gets the configured target label of this target node. Note that you cannot get a non-configured label from a configured target node because the configured target node is not uniquely identified a non-configured label, only by the configured target label. Sample usage: def _impl_label(ctx): node = ctx.configured_targets(&quot;my_cell//bin:the_binary&quot;) ctx.output.print(node.label)   "},{"title":"bxl.ConfiguredTargetNode.resolved_attrs_eager​","type":1,"pageTitle":"bxl.ConfiguredTargetNode type","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/#bxlconfiguredtargetnoderesolved_attrs_eager","content":"def bxl.ConfiguredTargetNode.resolved_attrs_eager(ctx: bxl.Context)  Returns a struct of all the resolved attributes of this target node. The structs fields are the attributes names, and the values are the underlying Starlark values of the attributes. If you need to access many or all resolved attrs on the same node, then this is the preferred way. Otherwise, using resolved_attrs_lazy() would be a better option for accessing only a few resolved attrs, although this really depends on what kind of resolved attrs are on the node. Benchmarking performance will give you the best indication on which method to use. You should store the result of this function call for further usage in the code rather than callingresolved_attrs_eager() each time you need all the resolved attrs. Sample usage: def _impl_resolved_attrs_eager(ctx): node = ctx.cquery().owner(&quot;cell//path/to/TARGETS&quot;)[0] attrs = node.resolved_attrs_eager(ctx) # cache once ctx.output.print(attrs) # do more stuff with attrs   "},{"title":"bxl.ConfiguredTargetNode.resolved_attrs_lazy​","type":1,"pageTitle":"bxl.ConfiguredTargetNode type","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/#bxlconfiguredtargetnoderesolved_attrs_lazy","content":"def bxl.ConfiguredTargetNode.resolved_attrs_lazy( ctx: bxl.Context ) -&gt; bxl.LazyResolvedAttrs  Returns a lazy_resolved_attrs object that you can call get() on that gets a resolved attr one at a time. If you need to access only few resolved attrs on the same node, then this is the preferred way. Otherwise, using resolved_attrs_eager() would be a better option for accessing many or all resolved attrs, although this really depends on what kind of resolved attrs are on the node. Benchmarking performance will give you the best indication on which method to use. You should store the result of this function call for further usage in the code rather than callingresolved_attrs_lazy() each time to get the lazy_resolved_attrs object. Note that if the get() is None, then any methods called on None will result in an error. Sample usage: def _impl_resolved_attrs_lazy(ctx): node = ctx.cquery().owner(&quot;cell//path/to/TARGETS&quot;)[0] attrs = node.resolved_attrs_lazy(ctx) # cache once ctx.output.print(attrs.get(&quot;some_attributes&quot;).value()) ctx.output.print(attrs.get(&quot;some_attribute&quot;).label)   "},{"title":"bxl.ConfiguredTargetNode.rule_kind​","type":1,"pageTitle":"bxl.ConfiguredTargetNode type","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/#bxlconfiguredtargetnoderule_kind","content":"bxl.ConfiguredTargetNode.rule_kind: str  Gets the targets' corresponding rule's kind which is one of - normal (with no special properties) - configured (usable in a configuration context) - toolchain (only usable as a toolchain dep) Sample usage: def _impl_rule_kind(ctx): node = ctx.configured_targets(&quot;my_cell//bin:the_binary&quot;) ctx.output.print(node.rule_kind)   "},{"title":"bxl.ConfiguredTargetNode.rule_type​","type":1,"pageTitle":"bxl.ConfiguredTargetNode type","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/#bxlconfiguredtargetnoderule_type","content":"bxl.ConfiguredTargetNode.rule_type: str  Gets the targets' corresponding rule's name. This is the fully qualified rule name including the import path. Sample usage: def _impl_rule_type(ctx): node = ctx.configured_targets(&quot;my_cell//bin:the_binary&quot;) ctx.output.print(node.rule_type)   "},{"title":"bxl.ConfiguredTargetNode.sources​","type":1,"pageTitle":"bxl.ConfiguredTargetNode type","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/#bxlconfiguredtargetnodesources","content":"def bxl.ConfiguredTargetNode.sources() -&gt; list[artifact]  Returns a List of all the sources used by this node. Sample usage: def _impl_sources(ctx): node = ctx.configured_targets(&quot;my_cell//bin:the_binary&quot;) ctx.output.print(node.sources())   "},{"title":"bxl.ConfiguredTargetNode.unwrap_forward​","type":1,"pageTitle":"bxl.ConfiguredTargetNode type","url":"/docs/api/bxl/bxl.ConfiguredTargetNode/#bxlconfiguredtargetnodeunwrap_forward","content":"def bxl.ConfiguredTargetNode.unwrap_forward() -&gt; bxl.ConfiguredTargetNode  Skip incoming transition forward node. If a target is a forward node, which is created by applying incoming configuration transition, return the transition target, otherwise return itself. This is is particularly useful when you don't care about 'forward' node. Example usage: def _impl_unwrap_forward(ctx): node = ctx.configured_targets(&quot;my_cell//bin:the_binary&quot;) actual_node = node.unwrap_forward()  "},{"title":"bxl.EnsuredArtifact type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.EnsuredArtifact/","content":"","keywords":""},{"title":"bxl.EnsuredArtifact.abs_path​","type":1,"pageTitle":"bxl.EnsuredArtifact type","url":"/docs/api/bxl/bxl.EnsuredArtifact/#bxlensuredartifactabs_path","content":"def bxl.EnsuredArtifact.abs_path()  Converts this artifact to be printed by its absolute path. Note that this will only print out the absolute path via ctx.output.print(). Starlark's print() will print out the display info for an ensured artifact. Sample usage: def _impl_abs_path(ctx): actions = ctx.bxl_actions().actions output = actions.write(&quot;my_output&quot;, &quot;my_content&quot;) ensured = ctx.output.ensure(output) # currently defaults to creating an EnsuredArtifact with a relative path ensured_with_abs_path = ensured.abs_path() # create a new EnsuredArtifact with absolute path to reuse print(ensured_with_abs_path) # should return something like &lt;ensured artifact ... &gt; ctx.output.print(ensured_with_abs_path) # should return the absolute path of the artifact   "},{"title":"bxl.EnsuredArtifact.rel_path​","type":1,"pageTitle":"bxl.EnsuredArtifact type","url":"/docs/api/bxl/bxl.EnsuredArtifact/#bxlensuredartifactrel_path","content":"def bxl.EnsuredArtifact.rel_path()  Converts this artifact to be printed by its path relative to the project root. Note that this will only print out the relative path via ctx.output.print(). Starlark's print() will print out the display info for an ensured artifact. Sample usage: def _impl_rel_path(ctx): actions = ctx.bxl_actions().actions output = actions.write(&quot;my_output&quot;, &quot;my_content&quot;) ensured = ctx.output.ensure(output) # currently defaults to creating an EnsuredArtifact with a relative path ensured_with_rel_path = ensured.rel_path() # create a new EnsuredArtifact with relative path to reuse print(ensured_with_rel_path) # should return something like &lt;ensured artifact ... &gt; ctx.output.print(ensured_with_rel_path) # should return the relative path of the artifact  "},{"title":"bxl.FileNode type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.FileNode/","content":"","keywords":""},{"title":"bxl.FileNode.cell​","type":1,"pageTitle":"bxl.FileNode type","url":"/docs/api/bxl/bxl.FileNode/#bxlfilenodecell","content":"bxl.FileNode.cell: str  The cell name for the file_node.  "},{"title":"bxl.FileNode.path​","type":1,"pageTitle":"bxl.FileNode type","url":"/docs/api/bxl/bxl.FileNode/#bxlfilenodepath","content":"bxl.FileNode.path: str  The cell relative path as a string. "},{"title":"bxl.LazyResolvedAttrs type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.LazyResolvedAttrs/","content":"","keywords":""},{"title":"bxl.LazyResolvedAttrs.get​","type":1,"pageTitle":"bxl.LazyResolvedAttrs type","url":"/docs/api/bxl/bxl.LazyResolvedAttrs/#bxllazyresolvedattrsget","content":"def bxl.LazyResolvedAttrs.get(attr: str)  Gets a single resolved attribute. Returns an optional configured attribute. Gets a single attribute. def _impl_resolved_attrs_lazy(ctx): node = ctx.cquery().owner(&quot;cell//path/to/TARGETS&quot;)[0] attrs = node.resolved_attrs_lazy(ctx) # cache once ctx.output.print(attrs.get(&quot;some_attribute&quot;).value()) ctx.output.print(attrs.get(&quot;some_attribute&quot;).label)  "},{"title":"bxl.Filesystem type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.Filesystem/","content":"","keywords":""},{"title":"bxl.Filesystem.abs_path_unsafe​","type":1,"pageTitle":"bxl.Filesystem type","url":"/docs/api/bxl/bxl.Filesystem/#bxlfilesystemabs_path_unsafe","content":"def bxl.Filesystem.abs_path_unsafe(expr: artifact | bxl.FileNode | str) -&gt; str  Returns the absolute path, given the file expression. Use at your own risk, as the current working directory may have been changed when this function is called. In addition, passing the absolute path into actions that are run remotely will most likely result in failures since the absolute path most likely differs locally vs remotely. Sample usage: def _impl_abs_path_unsafe(ctx): ctx.output.print(ctx.fs.abs_path_unsafe(&quot;bin&quot;))   "},{"title":"bxl.Filesystem.exists​","type":1,"pageTitle":"bxl.Filesystem type","url":"/docs/api/bxl/bxl.Filesystem/#bxlfilesystemexists","content":"def bxl.Filesystem.exists(expr: artifact | bxl.FileNode | str) -&gt; bool  Check if a path exists on disk, taking advantage of Buck's cached filesystem. Takes in a literal, a source artifact (via artifact), or a file_node. Sample usage: def _impl_exists(ctx): ctx.output.print(ctx.fs.exists(&quot;bin&quot;))   "},{"title":"bxl.Filesystem.is_dir​","type":1,"pageTitle":"bxl.Filesystem type","url":"/docs/api/bxl/bxl.Filesystem/#bxlfilesystemis_dir","content":"def bxl.Filesystem.is_dir(expr: artifact | bxl.FileNode | str) -&gt; bool  Returns whether the provided path is a dir. Returns false is the dir does not exist. The input is a either a literal, a source artifact (via artifact), or a file_node. Sample usage: def _impl_is_dir(ctx): ctx.output.print(ctx.fs.is_dir(&quot;bin&quot;))   "},{"title":"bxl.Filesystem.is_file​","type":1,"pageTitle":"bxl.Filesystem type","url":"/docs/api/bxl/bxl.Filesystem/#bxlfilesystemis_file","content":"def bxl.Filesystem.is_file(expr: artifact | bxl.FileNode | str) -&gt; bool  Returns whether the provided path is a file. Returns false is the file does not exist. The input is a either a literal, a source artifact (via artifact), or a file_node. Sample usage: def _impl_is_file(ctx): ctx.output.print(ctx.fs.is_dir(&quot;bin&quot;))   "},{"title":"bxl.Filesystem.list​","type":1,"pageTitle":"bxl.Filesystem type","url":"/docs/api/bxl/bxl.Filesystem/#bxlfilesystemlist","content":"def bxl.Filesystem.list( expr: artifact | bxl.FileNode | str, *, dirs_only: bool = False ) -&gt; read_dir_set  Returns all the contents of the given input that points to a directory. Errors if the given path is a file. Takes an optional boolean dirs_only to only return directories, defaults to false. The input is a either a literal, a source artifact (via artifact), or a file_node. Sample usage: def _impl_list(ctx): list_results = ctx.fs.list(&quot;bin&quot;) for result in list_results: ctx.output.print(result)   "},{"title":"bxl.Filesystem.project_rel_path​","type":1,"pageTitle":"bxl.Filesystem type","url":"/docs/api/bxl/bxl.Filesystem/#bxlfilesystemproject_rel_path","content":"def bxl.Filesystem.project_rel_path(expr: artifact | bxl.FileNode | str) -&gt; str  Returns the relative path to the project root, given the file expression. Sample usage: def project_rel_path(ctx): ctx.output.print(ctx.fs.project_rel_path(&quot;bin&quot;))   "},{"title":"bxl.Filesystem.source​","type":1,"pageTitle":"bxl.Filesystem type","url":"/docs/api/bxl/bxl.Filesystem/#bxlfilesystemsource","content":"def bxl.Filesystem.source( expr: artifact | bxl.FileNode | str, target_hint: None | bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] = None ) -&gt; artifact  Returns the source artifact for a path and an optional target hint (unconfigured target label or node) which points to the owning package. If no target hint is given, the nearest package will be used to guess the desired artifact. The path should be either an absolute path, or a project relative path. "},{"title":"bxl.CqueryContext type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.CqueryContext/","content":"","keywords":""},{"title":"bxl.CqueryContext.allpaths​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextallpaths","content":"def bxl.CqueryContext.allpaths( from: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label], to: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] ) -&gt; target_set  The allpaths query for computing all dependency paths.  "},{"title":"bxl.CqueryContext.attrfilter​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextattrfilter","content":"def bxl.CqueryContext.attrfilter( attr: str, value: str, targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] ) -&gt; target_set  The attrfilter query for rule attribute filtering.  "},{"title":"bxl.CqueryContext.attrregexfilter​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextattrregexfilter","content":"def bxl.CqueryContext.attrregexfilter( attribute: str, value: str, targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] ) -&gt; target_set  The attrregexfilter query for rule attribute filtering with regex. Sample usage: def _impl_attrregexfilter(ctx): filtered = ctx.cquery().attrregexfilter(&quot;foo&quot;, &quot;he.lo&quot;, &quot;bin/kind/...&quot;) ctx.output.print(filtered)   "},{"title":"bxl.CqueryContext.buildfile​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextbuildfile","content":"def bxl.CqueryContext.buildfile( targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] ) -&gt; file_set  Find the build file(s) that defines a target or a target set. Sample usage: def _buildfile_impl(ctx): owner = ctx.cquery().owner([&quot;bin/TARGET&quot;, &quot;bin/kind&quot;]) result = ctx.cquery().buildfile(owner) ctx.output.print(result)   "},{"title":"bxl.CqueryContext.deps​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextdeps","content":"def bxl.CqueryContext.deps( universe: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label], depth: None | int = None, filter: None | str = None ) -&gt; target_set  The deps query for finding the transitive closure of dependencies. Sample usage: def _impl_deps(ctx): result = ctx.cquery().deps(&quot;root//bin:the_binary&quot;, 1) ctx.output.print(result)   "},{"title":"bxl.CqueryContext.eval​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontexteval","content":"def bxl.CqueryContext.eval( query: str, query_args: None | target_set | list[str] = None, target_universe: None | list[str] | tuple[str, ...] = None )  Evaluates some general query string. query_args can be a target_set of unconfigured nodes, or a list of strings. Returns a dict of target labels mapped to their target_set results if query_args was passed in, otherwise returns a single target_set. Sample usage: def _impl_eval(ctx): result1 = ctx.cquery().eval(&quot;inputs(root//bin:the_binary)&quot;) ctx.output.print(result1) result2 = ctx.cquery().eval(&quot;inputs(%s)&quot;, query_args = [&quot;cell//path/to/file:target&quot;]) ctx.output.print(result2)   "},{"title":"bxl.CqueryContext.filter​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextfilter","content":"def bxl.CqueryContext.filter( regex: str, targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] ) -&gt; target_set  The filter query for filtering targets by name. Sample usage: def _impl_filter(ctx): result = ctx.cquery().filter(&quot;.*the_binary&quot;, &quot;root//...&quot;) ctx.output.print(result)   "},{"title":"bxl.CqueryContext.inputs​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextinputs","content":"def bxl.CqueryContext.inputs( targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] ) -&gt; file_set  The inputs query for finding input files. Sample usage: def _impl_inputs(ctx): result = ctx.cquery().inputs(&quot;root//bin:the_binary&quot;) ctx.output.print(result)   "},{"title":"bxl.CqueryContext.kind​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextkind","content":"def bxl.CqueryContext.kind( regex: str, targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] ) -&gt; target_set  The kind query for filtering targets by rule type. Sample usage: def _impl_kind(ctx): kind = ctx.cquery().kind(&quot;.*1&quot;, &quot;bin/kind/...&quot;) ctx.output.print(kind)   "},{"title":"bxl.CqueryContext.nattrfilter​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextnattrfilter","content":"def bxl.CqueryContext.nattrfilter( attr: str, value: str, targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] ) -&gt; target_set  The nattrfilter query for rule attribute filtering. It is the opposite of attrfilter, i.e. it filters targets by attribute but excludes those that match.  "},{"title":"bxl.CqueryContext.owner​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextowner","content":"def bxl.CqueryContext.owner( files: file_set | str | list[str] | tuple[str, ...], universe: None | bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] = None ) -&gt; target_set  The owner query for finding targets that own specified files. Note that if you do not pass in a cell path (where the format is &lt;cell&gt;//path/to/file), the path is resolved against the cell that the BXL script lives in. If you need to evaluate a file path that lives in a different cell, you must pass in the fully qualified cell path. Sample usage: def _owner_impl(ctx): owner = ctx.cquery().owner(&quot;bin/TARGETS.fixture&quot;, &quot;foo//target/universe/...&quot;) ctx.output.print(owner)   "},{"title":"bxl.CqueryContext.rdeps​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextrdeps","content":"def bxl.CqueryContext.rdeps( universe: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label], from: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label], depth: int = _ ) -&gt; target_set  The rdeps query for finding the transitive closure of reverse dependencies. Sample usage: def _impl_rdeps(ctx): result = ctx.cquery().rdeps(&quot;root//bin:the_binary&quot;, &quot;//lib:file1&quot;, 100) ctx.output.print(result)   "},{"title":"bxl.CqueryContext.somepath​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontextsomepath","content":"def bxl.CqueryContext.somepath( from: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label], to: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] ) -&gt; target_set   "},{"title":"bxl.CqueryContext.testsof​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontexttestsof","content":"def bxl.CqueryContext.testsof( targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] ) -&gt; target_set  The testsof query for listing the tests of the specified targets.  "},{"title":"bxl.CqueryContext.testsof_with_default_target_platform​","type":1,"pageTitle":"bxl.CqueryContext type","url":"/docs/api/bxl/bxl.CqueryContext/#bxlcquerycontexttestsof_with_default_target_platform","content":"def bxl.CqueryContext.testsof_with_default_target_platform( targets: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label] ) -&gt; target_set  The testsof query for listing the tests of the specified targets. Performs default target platform resolution under the hood for the tests found. "},{"title":"bxl.OutputStream type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.OutputStream/","content":"","keywords":""},{"title":"bxl.OutputStream.ensure​","type":1,"pageTitle":"bxl.OutputStream type","url":"/docs/api/bxl/bxl.OutputStream/#bxloutputstreamensure","content":"def bxl.OutputStream.ensure(artifact: artifact) -&gt; bxl.EnsuredArtifact  Marks the artifact as an artifact that should be available to the users at the end of the bxl invocation. Any artifacts that do not get registered via this call is not accessible by users at the end of bxl script. This function returns an ensured_artifact type that can be printed via ctx.output.print()to print its actual path on disk. Sample usage: def _impl_ensure(ctx): actions = ctx.bxl_actions().actions output = actions.write(&quot;my_output&quot;, &quot;my_content&quot;) ensured = ctx.output.ensure(output) ctx.output.print(ensured)   "},{"title":"bxl.OutputStream.ensure_multiple​","type":1,"pageTitle":"bxl.OutputStream type","url":"/docs/api/bxl/bxl.OutputStream/#bxloutputstreamensure_multiple","content":"def bxl.OutputStream.ensure_multiple( artifacts: None | artifact | bxl.BuildResult | bxl_built_artifacts_iterable | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[artifact] | dict[typing.Any, bxl.BuildResult] | RunInfo )  Same as ensure, but for multiple artifacts. Will preserve the shape of the inputs (i.e. if the resulting Dict of a ctx.build() is passed in, the output will be a Dict where the key is preserved, and the values are converted to ensured_artifacts). Note that is slower to loop through objects and ensure them one by one than it is to call ensure_multiple()on all the objects at once (if possible). So, it is suggested to use this method when you are only ensuring a few individual artifacts that are not stored in an iterable. Sample usage: def _impl_ensure_multiple(ctx): outputs = {} for target, value in ctx.build(ctx.cli_args.target).items(): outputs.update({target.raw_target(): ctx.output.ensure_multiple(value.artifacts())}) ctx.output.print_json(outputs)   "},{"title":"bxl.OutputStream.print​","type":1,"pageTitle":"bxl.OutputStream type","url":"/docs/api/bxl/bxl.OutputStream/#bxloutputstreamprint","content":"def bxl.OutputStream.print(*args, sep: str = &quot; &quot;) -&gt; None  Outputs results to the console via stdout. These outputs are considered to be the results of a bxl script, which will be displayed to stdout by buck2 even when the script is cached. Accepts an optional separator that defaults to &quot; &quot;. Prints that are not result of the bxl should be printed via stderr via the stdlib printand pprint. Note that ctx.output.print() is intended for simple outputs. For more complex outputs, the recommendation would be to write them to a file. Sample usage: def _impl_print(ctx): ctx.output.print(&quot;test&quot;)   "},{"title":"bxl.OutputStream.print_json​","type":1,"pageTitle":"bxl.OutputStream type","url":"/docs/api/bxl/bxl.OutputStream/#bxloutputstreamprint_json","content":"def bxl.OutputStream.print_json(value, *, pretty: bool = True) -&gt; None  Outputs results to the console via stdout as pretty-printed json. Pretty printing can be turned off by the pretty keyword-only parameter. These outputs are considered to be the results of a bxl script, which will be displayed to stdout by buck2 even when the script is cached. Prints that are not result of the bxl should be printed via stderr via the stdlib printand pprint. Sample usage: def _impl_print_json(ctx): outputs = {} outputs.update({&quot;foo&quot;: bar}) ctx.output.print_json(&quot;test&quot;)  "},{"title":"bxl.Context type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.Context/","content":"","keywords":""},{"title":"bxl.Context.analysis​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextanalysis","content":"def bxl.Context.analysis( labels: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label], target_platform: None | str | target_label = _, *, skip_incompatible: bool = True ) -&gt; None | bxl.AnalysisResult | dict[label, bxl.AnalysisResult]  Runs analysis on the given labels, accepting an optional target_platform which is the target platform configuration used to resolve configurations of any unconfigured target nodes, and an optional skip_incompatible boolean that indicates whether to skip analysis of nodes that are incompatible with the target platform. The target_platform is either a string that can be parsed as a target label, or a target label. The given labels is a providers expression, which is either: - a single string that is a `target pattern`. - a single target node or label, configured or unconfigured - a single sub target label, configured or unconfigured - a list of the two options above.  This returns either a single analysis_result if the given labels argument is &quot;singular&quot;, or a dict keyed by sub target labels of analysis if the given labels argument is list-like  "},{"title":"bxl.Context.aquery​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextaquery","content":"def bxl.Context.aquery( target_platform: None | str | target_label = _ ) -&gt; bxl.AqueryContext  Returns the aqueryctx that holds all the aquery functions. This function takes an optional parameter target_platform, which is the target platform configuration used to configured any unconfigured target nodes. The target_platform is a target label, or a string that is a target label.  "},{"title":"bxl.Context.audit​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextaudit","content":"def bxl.Context.audit() -&gt; bxl.AuditContext  Returns the audit_ctx that holds all the audit functions.  "},{"title":"bxl.Context.build​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextbuild","content":"def bxl.Context.build( labels: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | label | providers_label | str | target_label], target_platform: None | str | target_label = _, *, materializations: str = &quot;default&quot; ) -&gt; dict[label, bxl.BuildResult]  Runs a build on the given labels, accepting an optional target_platform which is the target platform configuration used to resolve configurations. Note that when build() is called, the artifacts are materialized without needing to additionally call ensure() on them. The given labels is a providers expression, which is either: - a single string that is a `target pattern`. - a single target node or label, configured or unconfigured - a single provider label, configured or unconfigured - a list of the two options above.  This returns a dict keyed by sub target labels mapped to bxl_build_results if the given labels argument is list-like. This function is not available on the bxl_ctx when called from dynamic_output.  "},{"title":"bxl.Context.bxl_actions​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextbxl_actions","content":"def bxl.Context.bxl_actions( *, exec_deps: None | bxl.UnconfiguredTargetNode | providers_label | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | providers_label | str | target_label] = None, toolchains: None | bxl.UnconfiguredTargetNode | providers_label | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | providers_label | str | target_label] = None, target_platform: None | str | target_label = _, exec_compatible_with: None | bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] = None ) -&gt; bxl.Actions  Returns the bxl actions to create and register actions for this bxl function. This will have the execution platform resolved according to the execution deps and toolchains you pass into this function. You'll be able to access the analysis action factory of the correct execution platform, toolchains, and execution deps of the corresponding configuration via this context. Actions created by bxl will not be built by default. Instead, they are marked to be built by ctx.output.ensure(artifact) on the output module of the bxl_ctx. Only artifacts marked by ensure will be built. Sample usage: def _impl_write_action(ctx): bxl_actions = ctx.bxl_actions() output = bxl_actions.actions.write(&quot;my_output&quot;, &quot;my_content&quot;) ensured = ctx.output.ensure(output) ctx.output.print(ensured)  There are several optional named parameters: exec_deps - These are dependencies you wish to access as executables for creating the action. This is usually the same set of targets one would pass to rule's attr.exec_dep.toolchains - The set of toolchains needed for the actions you intend to create.target_platform - The intended target platform for your toolchainsexec_compatible_with - Explicit list of configuration nodes (like platforms or constraints) that these actions are compatible with. This is the 'exec_compatible_with' attribute of a target. If you passed in exec_deps or toolchains, you can access the resolved dependencies using the exec_depsand toolchains attributes on the bxl_actions, which both return a dict of unconfigured subtarget labels and their configured/resolved dependency objects. Note that the keys of exec_deps and toolchains must be unconfigured subtarget labels (providers_labels), and not unconfigured target labels. You can use ctx.unconfigured_sub_targets(...) or with_sub_target() ontarget_label to create the label. def _impl_run_action(ctx): my_exec_dep = ctx.unconfigured_sub_targets(&quot;foo//bar:baz&quot;) # has some provider that you would use in the action bxl_actions = ctx.bxl_actions(exec_deps = [my_exec_dep]) # call once, reuse wherever needed output = bxl_actions.actions.run( [ &quot;python3&quot;, bxl_actions.exec_deps[my_exec_dep][RunInfo], # access resolved exec_deps on the `bxl_actions` out.as_output(), ], category = &quot;command&quot;, local_only = True, ) ctx.output.ensure(output)  When called from a dynamic_output, bxl_actions() cannot be configured with a different execution platform resolution from the parent BXL.  "},{"title":"bxl.Context.cell_root​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextcell_root","content":"def bxl.Context.cell_root() -&gt; str  Returns the absolute path to the cell of the repository This function is not available on the bxl_ctx when called from dynamic_output.  "},{"title":"bxl.Context.cli_args​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextcli_args","content":"bxl.Context.cli_args: struct(..)  A struct of the command line args as declared using the [cli_args] module. These command lines are resolved per the users input on the cli when invoking the bxl script. If you wish to pass in a kebab-cased arg, the arg accessed from the BXL context's cli_argsattrbute will always be in snakecase. For example, if you passed in my-arg, accessing it within BXL would look like ctx.cli_args.my_arg. This attribute is not available on the bxl context within the a dynamic lambda.  "},{"title":"bxl.Context.configured_targets​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextconfigured_targets","content":"def bxl.Context.configured_targets( labels: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label], /, target_platform: None | str | target_label = _ ) -&gt; None | bxl.ConfiguredTargetNode | target_set  Gets the target nodes for the labels, accepting an optional target_platform which is the target platform configuration used to resolve configurations of any unconfigured target nodes. The target_platform is either a string that can be parsed as a target label, or a target label. The given labels is a [TargetListExpr], which is either: - a single string that is a `target pattern`. - a single target node or label, configured or unconfigured - a list of the two options above.  Note that this function does not accept Label (which is a configured provider label), since this is the label of a subtarget. You can get the underlying configured target label on the Labelusing configured_targets() (ex: my_label.configured_target()). This returns either a single target_node if the given labelsis &quot;singular&quot;, a dict keyed by target labels of target_node if the given labels is list-like  "},{"title":"bxl.Context.cquery​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextcquery","content":"def bxl.Context.cquery( target_platform: None | str | target_label = _ ) -&gt; bxl.CqueryContext  Returns the cqueryctx that holds all the cquery functions. This function takes an optional parameter target_platform, which is the target platform configuration used to configured any unconfigured target nodes. The target_platform is a target label, or a string that is a target label.  "},{"title":"bxl.Context.fs​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextfs","content":"bxl.Context.fs: bxl.Filesystem  Returns the bxl.Filesystem for performing a basic set of filesystem operations within bxl  "},{"title":"bxl.Context.instant_event​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextinstant_event","content":"def bxl.Context.instant_event(*, id: str, metadata) -&gt; None  Emits a user-defined instant event, taking in a required string id and a metadata dictionary where the keys are strings, and values are either strings, bools, or ints. The id is user-supplied, and used to identify the instant events in the event logs more easily. You may pass in an ensured artifact as a value in the metadata. The resulting output would be the ensured artifact's relative or absolute path as a string.  "},{"title":"bxl.Context.output​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextoutput","content":"bxl.Context.output: bxl.OutputStream  Gets the output stream to the console via stdout. Items written to the output stream are considered to be the results of a bxl script, which will be displayed to stdout by buck2 even when the script is cached. Prints that are not result of the bxl should be printed via stderr via the stdlib printand pprint. This function is not available on the bxl_ctx when called from dynamic_output.  "},{"title":"bxl.Context.resolve​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextresolve","content":"def bxl.Context.resolve(action_factory: actions, promise: promise)  Awaits a promise and returns an optional value of the promise. Sample usage: load(&quot;//path/to/rules:rules.bzl&quot;, &quot;my_anon_targets_rule&quot;, &quot;my_map_function&quot;) def _resolve_impl(ctx): actions = ctx.bxl_actions().actions my_attrs = { &quot;false&quot;: False, &quot;int&quot;: 42, &quot;list_string&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;string&quot;: &quot;a-string&quot;, &quot;true&quot;: True, } promise = actions.anon_target(my_anon_targets_rule, attrs).promise.map(my_map_function) providers_result = ctx.resolve(actions, promise) # result is `provider_collection` type, which is a collection of `provider`s ctx.output.print(providers_result[0].my_field)   "},{"title":"bxl.Context.root​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextroot","content":"def bxl.Context.root() -&gt; str  Returns the absolute path to the root of the repository This function is not available on the bxl_ctx when called from dynamic_output.  "},{"title":"bxl.Context.target_exists​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontexttarget_exists","content":"def bxl.Context.target_exists(label: str) -&gt; bool  Checks if a target label exists. Target label must be a string literal, and an exact target.  "},{"title":"bxl.Context.target_universe​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontexttarget_universe","content":"def bxl.Context.target_universe( labels: bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label | target_set | target_set | list[bxl.ConfiguredTargetNode | bxl.UnconfiguredTargetNode | configured_target_label | str | target_label], target_platform: None | str | target_label = _, *, keep_going: bool = False ) -&gt; bxl.TargetUniverse  Returns the target_universe that can lookup valid configured nodes in the universe. The given labels is a target expression, which is either: - a single string that is a `target pattern`. - a single target node or label, configured or unconfigured - a single subtarget label, configured or unconfigured - a list of the two options above.  Also takes in an optional target_platform param to configure the nodes with, and a keep_going`` flag to skip any loading or configuration errors. Note that keep_going` currently can only be used if the input labels is a single target pattern as a string literal.  "},{"title":"bxl.Context.unconfigured_sub_targets​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextunconfigured_sub_targets","content":"def bxl.Context.unconfigured_sub_targets( labels: bxl.UnconfiguredTargetNode | providers_label | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | providers_label | str | target_label] ) -&gt; providers_label | dict[str, providers_label]  Gets the unconfigured subtargets for the given labels The given labels is a providers expression, which is either: - a single string that is a `target pattern`. - a single target node or label, configured or unconfigured - a single subtarget label, configured or unconfigured - a list of the two options above.  This returns either a single providers_label if the given labels argument is &quot;singular&quot;, or dict of the subtarget string representation to theproviders_label if the given labels argument is list-like. Note that this function does not check that this subtarget exists in the repo.  "},{"title":"bxl.Context.unconfigured_targets​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextunconfigured_targets","content":"def bxl.Context.unconfigured_targets( labels: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] ) -&gt; bxl.UnconfiguredTargetNode | target_set  Gets the unconfigured target nodes for the labels The given labels is either: - a single string that is a `target pattern`. - a single unconfigured target node or label - a list of the two options above.  This returns either a single [StarlarkTargetNode] if the given labelsis &quot;singular&quot;, a dict keyed by target labels of [StarlarkTargetNode] if the given labels is list-like  "},{"title":"bxl.Context.uquery​","type":1,"pageTitle":"bxl.Context type","url":"/docs/api/bxl/bxl.Context/#bxlcontextuquery","content":"def bxl.Context.uquery() -&gt; bxl.UqueryContext  Returns the uqueryctx that holds all uquery functions. "},{"title":"bxl.UnconfiguredTargetNode type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.UnconfiguredTargetNode/","content":"","keywords":""},{"title":"bxl.UnconfiguredTargetNode.attrs​","type":1,"pageTitle":"bxl.UnconfiguredTargetNode type","url":"/docs/api/bxl/bxl.UnconfiguredTargetNode/#bxlunconfiguredtargetnodeattrs","content":"bxl.UnconfiguredTargetNode.attrs: typing.Any  Gets the coerced attributes from the unconfigured target node. Returns a struct. Sample usage: def _impl_attributes(ctx): target_node = ctx.uquery().eval(&quot;owner('path/to/file')&quot;)[0] ctx.output.print(target_node.attrs.my_attr)   "},{"title":"bxl.UnconfiguredTargetNode.buildfile_path​","type":1,"pageTitle":"bxl.UnconfiguredTargetNode type","url":"/docs/api/bxl/bxl.UnconfiguredTargetNode/#bxlunconfiguredtargetnodebuildfile_path","content":"bxl.UnconfiguredTargetNode.buildfile_path: bxl.FileNode  Gets the buildfile path from the unconfigured target node. Sample usage: def _impl_label(ctx): target_node = ctx.uquery().eval(&quot;owner('path/to/file')&quot;)[0] ctx.output.print(target_node.buildfile_path)   "},{"title":"bxl.UnconfiguredTargetNode.label​","type":1,"pageTitle":"bxl.UnconfiguredTargetNode type","url":"/docs/api/bxl/bxl.UnconfiguredTargetNode/#bxlunconfiguredtargetnodelabel","content":"bxl.UnconfiguredTargetNode.label: target_label  Gets the label from the unconfigured target node. Sample usage: def _impl_label(ctx): target_node = ctx.uquery().eval(&quot;owner('path/to/file')&quot;)[0] ctx.output.print(target_node.label)   "},{"title":"bxl.UnconfiguredTargetNode.rule_kind​","type":1,"pageTitle":"bxl.UnconfiguredTargetNode type","url":"/docs/api/bxl/bxl.UnconfiguredTargetNode/#bxlunconfiguredtargetnoderule_kind","content":"bxl.UnconfiguredTargetNode.rule_kind: str  Gets the targets' corresponding rule's kind which is one of - normal (with no special properties) - configured (usable in a configuration context) - toolchain (only usable as a toolchain dep) Sample usage: def _impl_rule_kind(ctx): target_node = ctx.uquery().owner('path/to/file')[0] ctx.output.print(target_node.rule_kind)   "},{"title":"bxl.UnconfiguredTargetNode.rule_type​","type":1,"pageTitle":"bxl.UnconfiguredTargetNode type","url":"/docs/api/bxl/bxl.UnconfiguredTargetNode/#bxlunconfiguredtargetnoderule_type","content":"bxl.UnconfiguredTargetNode.rule_type: str  Gets the fully qualified name of the rule for this unconfigured target node as a string. This includes the import path as well. Sample usage: def _impl_rule_type(ctx): target_node = ctx.uquery().owner('path/to/file')[0] ctx.output.print(target_node.rule_type)  "},{"title":"bxl.TargetUniverse type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.TargetUniverse/","content":"","keywords":""},{"title":"bxl.TargetUniverse.lookup​","type":1,"pageTitle":"bxl.TargetUniverse type","url":"/docs/api/bxl/bxl.TargetUniverse/#bxltargetuniverselookup","content":"def bxl.TargetUniverse.lookup( targets: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] ) -&gt; target_set  Looks up valid configured target nodes within the universe. The targets passed in are either string literals, unconfigured target nodes, or unconfigured target labels.  "},{"title":"bxl.TargetUniverse.target_set​","type":1,"pageTitle":"bxl.TargetUniverse type","url":"/docs/api/bxl/bxl.TargetUniverse/#bxltargetuniversetarget_set","content":"def bxl.TargetUniverse.target_set() -&gt; target_set  The target set of the nodes used to construct the target universe.  "},{"title":"bxl.TargetUniverse.universe_target_set​","type":1,"pageTitle":"bxl.TargetUniverse type","url":"/docs/api/bxl/bxl.TargetUniverse/#bxltargetuniverseuniverse_target_set","content":"def bxl.TargetUniverse.universe_target_set() -&gt; target_set  The target set of the entire target universe. "},{"title":"bxl.UqueryContext type","type":0,"sectionRef":"#","url":"/docs/api/bxl/bxl.UqueryContext/","content":"","keywords":""},{"title":"bxl.UqueryContext.allpaths​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontextallpaths","content":"def bxl.UqueryContext.allpaths( from: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label], to: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] ) -&gt; target_set  The allpaths query for computing all dependency paths.  "},{"title":"bxl.UqueryContext.attrfilter​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontextattrfilter","content":"def bxl.UqueryContext.attrfilter( attr: str, value: str, targets: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] ) -&gt; target_set  The attrfilter query for rule attribute filtering.  "},{"title":"bxl.UqueryContext.attrregexfilter​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontextattrregexfilter","content":"def bxl.UqueryContext.attrregexfilter( attribute: str, value: str, targets: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] ) -&gt; target_set  The attrregexfilter query for rule attribute filtering with regex. Sample usage: def _impl_attrregexfilter(ctx): filtered = ctx.uquery().attrregexfilter(&quot;foo&quot;, &quot;he.lo&quot;, &quot;bin/kind/...&quot;) ctx.output.print(filtered)   "},{"title":"bxl.UqueryContext.buildfile​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontextbuildfile","content":"def bxl.UqueryContext.buildfile( targets: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] ) -&gt; file_set  Find the build file(s) that defines a target or a target set. Sample usage: def _buildfile_impl(ctx): owner = ctx.uquery().owner([&quot;bin/TARGET&quot;, &quot;bin/kind&quot;]) result = ctx.uquery().buildfile(owner) ctx.output.print(result)   "},{"title":"bxl.UqueryContext.deps​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontextdeps","content":"def bxl.UqueryContext.deps( universe: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label], depth: None | int = None, filter: None | str = None ) -&gt; target_set  The deps query for finding the transitive closure of dependencies. Sample usage: def _impl_deps(ctx): result = ctx.uquery().deps(&quot;root//bin:the_binary&quot;, 1) ctx.output.print(result)   "},{"title":"bxl.UqueryContext.eval​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontexteval","content":"def bxl.UqueryContext.eval( query: str, query_args: None | target_set | list[str] = None )  Evaluates some general query string, query_args can be a target_set of unconfigured nodes, or a list of strings. Returns a dict of target labels mapped to their target_set results if query_args was passed in, otherwise returns a single target_set. Sample usage: def _impl_eval(ctx): result1 = ctx.uquery().eval(&quot;inputs(cell//path/to/file:target)&quot;) ctx.output.print(result1) result2 = ctx.uquery().eval(&quot;inputs(%s)&quot;, query_args = [&quot;cell//path/to/file:target&quot;]) ctx.output.print(result2)   "},{"title":"bxl.UqueryContext.filter​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontextfilter","content":"def bxl.UqueryContext.filter( regex: str, targets: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] ) -&gt; target_set  The filter query for filtering targets by name. Sample usage: def _impl_filter(ctx): result = ctx.uquery().filter(&quot;.*the_binary&quot;, &quot;root//...&quot;) ctx.output.print(result)   "},{"title":"bxl.UqueryContext.inputs​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontextinputs","content":"def bxl.UqueryContext.inputs( targets: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] ) -&gt; file_set  The inputs query for finding input files. Sample usage: def _impl_inputs(ctx): result = ctx.uquery().inputs(&quot;root//bin:the_binary&quot;) ctx.output.print(result)   "},{"title":"bxl.UqueryContext.kind​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontextkind","content":"def bxl.UqueryContext.kind( regex: str, targets: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] ) -&gt; target_set  The kind query for filtering targets by rule type. Sample usage: def _impl_kind(ctx): kind = ctx.uquery().kind(&quot;.*1&quot;, &quot;bin/kind/...&quot;) ctx.output.print(kind)   "},{"title":"bxl.UqueryContext.owner​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontextowner","content":"def bxl.UqueryContext.owner( files: file_set | str | list[str] | tuple[str, ...] ) -&gt; target_set  The owner query for finding targets that own specified files. Note that if you do not pass in a cell path (where the format is &lt;cell&gt;//path/to/file), the path is resolved against the cell that the BXL script lives in. If you need to evaluate a file path that lives in a different cell, you must pass in the fully qualified cell path. Sample usage: def _owner_impl(ctx): owner = ctx.uquery().owner(&quot;bin/TARGETS.fixture&quot;) ctx.output.print(owner)   "},{"title":"bxl.UqueryContext.rdeps​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontextrdeps","content":"def bxl.UqueryContext.rdeps( universe: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label], from: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label], depth: int = _ ) -&gt; target_set  The rdeps query for finding the transitive closure of reverse dependencies. Sample usage: def _impl_rdeps(ctx): result = ctx.uquery().rdeps(&quot;root//bin:the_binary&quot;, &quot;//lib:file1&quot;, 100) ctx.output.print(result)   "},{"title":"bxl.UqueryContext.somepath​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontextsomepath","content":"def bxl.UqueryContext.somepath( from: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label], to: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] ) -&gt; target_set  The somepaths query, which returns the graph of nodes on some arbitrary path from a start to destination target.  "},{"title":"bxl.UqueryContext.targets_in_buildfile​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontexttargets_in_buildfile","content":"def bxl.UqueryContext.targets_in_buildfile( files: file_set | str | list[str] | tuple[str, ...] ) -&gt; target_set  Given a set of buildfiles, return all targets within those buildfiles. Usage: def _targets_in_buildfile_impl(ctx): targets = ctx.uquery().targets_in_buildfile(&quot;bin/TARGETS.fixture&quot;) ctx.output.print(targets)  This is subject to be removed in future in favor of a more general targets_in_packages.  "},{"title":"bxl.UqueryContext.testsof​","type":1,"pageTitle":"bxl.UqueryContext type","url":"/docs/api/bxl/bxl.UqueryContext/#bxluquerycontexttestsof","content":"def bxl.UqueryContext.testsof( targets: bxl.UnconfiguredTargetNode | str | target_label | target_set | list[bxl.UnconfiguredTargetNode | str | target_label] ) -&gt; target_set  The testsof query for listing the tests of the specified targets. Sample usage: def _testsof_impl(ctx): result = ctx.uquery().testsof(&quot;//:foo_lib&quot;) ctx.output.print(result)  "},{"title":"cmd_args type","type":0,"sectionRef":"#","url":"/docs/api/bxl/cmd_args/","content":"","keywords":""},{"title":"cmd_args.add​","type":1,"pageTitle":"cmd_args type","url":"/docs/api/bxl/cmd_args/#cmd_argsadd","content":"def cmd_args.add(*args) -&gt; cmd_args  A list of arguments to be added to the command line, which may including cmd_args, artifacts, strings, RunInfo or lists thereof. Note that this operation mutates the input cmd_args.  "},{"title":"cmd_args.copy​","type":1,"pageTitle":"cmd_args type","url":"/docs/api/bxl/cmd_args/#cmd_argscopy","content":"def cmd_args.copy() -&gt; cmd_args  Returns a copy of the cmd_args such that any modifications to the original or the returned value will not impact each other. Note that this is a shallow copy, so any inner cmd_args can still be modified.  "},{"title":"cmd_args.inputs​","type":1,"pageTitle":"cmd_args type","url":"/docs/api/bxl/cmd_args/#cmd_argsinputs","content":"cmd_args.inputs: command_line_inputs  Collect all the inputs (including hidden) referenced by this command line. The output can be compared for equality and have its len requested to see whether there are any inputs, but is otherwise mostly opaque.  "},{"title":"cmd_args.outputs​","type":1,"pageTitle":"cmd_args type","url":"/docs/api/bxl/cmd_args/#cmd_argsoutputs","content":"cmd_args.outputs: list[output_artifact]  Collect all the outputs (including hidden) referenced by this command line.  "},{"title":"cmd_args.relative_to​","type":1,"pageTitle":"cmd_args type","url":"/docs/api/bxl/cmd_args/#cmd_argsrelative_to","content":"def cmd_args.relative_to( directory: artifact | cell_root | project_root, /, *, parent: int = _ ) -&gt; cmd_args  Make all artifact paths relative to a given location. Typically used when the command you are running changes directory. By default, the paths are relative to the artifacts themselves (equivalent toparent = 0). Use parent to make the paths relative to an ancestor directory. For example parent = 1 would make all paths relative to the containing dirs of any artifacts in the cmd_args. dir = symlinked_dir(...) script = [ cmd_args(cmd_args(dir, format = &quot;cd {}&quot;), original_script.relative_to(dir) ]  "},{"title":"coerced_attr type","type":0,"sectionRef":"#","url":"/docs/api/bxl/coerced_attr/","content":"","keywords":""},{"title":"coerced_attr.type​","type":1,"pageTitle":"coerced_attr type","url":"/docs/api/bxl/coerced_attr/#coerced_attrtype","content":"coerced_attr.type: str  Returns the type name of the attribute Sample usage: def _impl_type(ctx): node = ctx.uquery().owner(&quot;bin/TARGETS&quot;)[0] ctx.output.print(node.attrs.name.type)   "},{"title":"coerced_attr.value​","type":1,"pageTitle":"coerced_attr type","url":"/docs/api/bxl/coerced_attr/#coerced_attrvalue","content":"def coerced_attr.value()  Returns the value of this attribute. Limited support of selects, concats, and explicit configuration deps at this time. Sample usage: def _impl_value(ctx): node = ctx.uquery().owner(&quot;bin/TARGETS&quot;)[0] ctx.output.print(node.attrs.name.value())  "},{"title":"configured_attr type","type":0,"sectionRef":"#","url":"/docs/api/bxl/configured_attr/","content":"","keywords":""},{"title":"configured_attr.type​","type":1,"pageTitle":"configured_attr type","url":"/docs/api/bxl/configured_attr/#configured_attrtype","content":"configured_attr.type: str  Returns the type name of the attribute Sample usage: def _impl_type(ctx): node = ctx.cquery().owner(&quot;bin/TARGETS&quot;)[0] attrs = node.attrs_eager() ctx.output.print(attrs.name.type)   "},{"title":"configured_attr.value​","type":1,"pageTitle":"configured_attr type","url":"/docs/api/bxl/configured_attr/#configured_attrvalue","content":"def configured_attr.value()  Returns the value of this attribute. The value here is not fully resolved like in rules. Sample usage: def _impl_value(ctx): node = ctx.cquery().owner(&quot;bin/TARGETS&quot;)[0] attrs = node.attrs_eager() ctx.output.print(attrs.name.value())  "},{"title":"digest_config type","type":0,"sectionRef":"#","url":"/docs/api/bxl/digest_config/","content":"","keywords":""},{"title":"digest_config.allows_blake3​","type":1,"pageTitle":"digest_config type","url":"/docs/api/bxl/digest_config/#digest_configallows_blake3","content":"def digest_config.allows_blake3() -&gt; bool   "},{"title":"digest_config.allows_blake3_keyed​","type":1,"pageTitle":"digest_config type","url":"/docs/api/bxl/digest_config/#digest_configallows_blake3_keyed","content":"def digest_config.allows_blake3_keyed() -&gt; bool   "},{"title":"digest_config.allows_sha1​","type":1,"pageTitle":"digest_config type","url":"/docs/api/bxl/digest_config/#digest_configallows_sha1","content":"def digest_config.allows_sha1() -&gt; bool   "},{"title":"digest_config.allows_sha256​","type":1,"pageTitle":"digest_config type","url":"/docs/api/bxl/digest_config/#digest_configallows_sha256","content":"def digest_config.allows_sha256() -&gt; bool  "},{"title":"configured_target_label type","type":0,"sectionRef":"#","url":"/docs/api/bxl/configured_target_label/","content":"","keywords":""},{"title":"configured_target_label.cell​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/bxl/configured_target_label/#configured_target_labelcell","content":"configured_target_label.cell: str   "},{"title":"configured_target_label.config​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/bxl/configured_target_label/#configured_target_labelconfig","content":"def configured_target_label.config() -&gt; configuration   "},{"title":"configured_target_label.name​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/bxl/configured_target_label/#configured_target_labelname","content":"configured_target_label.name: str   "},{"title":"configured_target_label.package​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/bxl/configured_target_label/#configured_target_labelpackage","content":"configured_target_label.package: str   "},{"title":"configured_target_label.path​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/bxl/configured_target_label/#configured_target_labelpath","content":"configured_target_label.path: label_relative_path   "},{"title":"configured_target_label.raw_target​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/bxl/configured_target_label/#configured_target_labelraw_target","content":"def configured_target_label.raw_target() -&gt; target_label  Returns the unconfigured underlying target label.  "},{"title":"configured_target_label.with_sub_target​","type":1,"pageTitle":"configured_target_label type","url":"/docs/api/bxl/configured_target_label/#configured_target_labelwith_sub_target","content":"def configured_target_label.with_sub_target( subtarget_name: str | list[str] = _ ) -&gt; label  Converts a ConfiguredTargetLabel into its corresponding Label given the subtarget name which is a list for each layer of subtarget Sample usage: def _impl_sub_target(ctx): owners = ctx.cquery().owner(&quot;bin/TARGETS.fixture&quot;) for owner in owners: configured_label = owner.label ctx.output.print(configured_label.with_sub_target()) ctx.output.print(configured_label.with_sub_target(&quot;subtarget1&quot;)) ctx.output.print(configured_label.with_sub_target([&quot;subtarget1&quot;, &quot;subtarget2&quot;]))  "},{"title":"context type","type":0,"sectionRef":"#","url":"/docs/api/bxl/context/","content":"","keywords":""},{"title":"context.actions​","type":1,"pageTitle":"context type","url":"/docs/api/bxl/context/#contextactions","content":"context.actions: actions  Returns an actions value containing functions to define actual actions that are run. See the actions type for the operations that are available.  "},{"title":"context.attrs​","type":1,"pageTitle":"context type","url":"/docs/api/bxl/context/#contextattrs","content":"context.attrs: struct(..)  Returns the attributes of the target as a Starlark struct with a field for each attribute, which varies per rule. As an example, given a rule with the attrs argument of {&quot;foo&quot;: attrs.string()}, this field will be a struct containing a field foo of type string.  "},{"title":"context.label​","type":1,"pageTitle":"context type","url":"/docs/api/bxl/context/#contextlabel","content":"context.label: None | label  Returns a label representing the target, or None if being invoked from a dynamic_output in Bxl.  "},{"title":"context.plugins​","type":1,"pageTitle":"context type","url":"/docs/api/bxl/context/#contextplugins","content":"context.plugins: AnalysisPlugins  An opaque value that can be indexed with a plugin kind to get a list of the available plugin deps of that kind. The rule must set an appropriate value on uses_plugins in its declaration. "},{"title":"file_set type","type":0,"sectionRef":"#","url":"/docs/api/bxl/file_set/","content":"file_set type A set of file_nodes. Supports the operations such as set addition/subtraction, length, iteration, equality and indexing.","keywords":""},{"title":"dependency type","type":0,"sectionRef":"#","url":"/docs/api/bxl/dependency/","content":"","keywords":""},{"title":"dependency.get​","type":1,"pageTitle":"dependency type","url":"/docs/api/bxl/dependency/#dependencyget","content":"def dependency.get(index) -&gt; None | provider  Gets a provider by indexing on a ProviderCallable object. e.g. FooInfo = provider(fields=[&quot;bar&quot;]) .... collection.get(FooInfo) # None if absent, a FooInfo instance if present   "},{"title":"dependency.label​","type":1,"pageTitle":"dependency type","url":"/docs/api/bxl/dependency/#dependencylabel","content":"dependency.label: label   "},{"title":"dependency.providers​","type":1,"pageTitle":"dependency type","url":"/docs/api/bxl/dependency/#dependencyproviders","content":"dependency.providers: list[typing.Any]   "},{"title":"dependency.sub_target​","type":1,"pageTitle":"dependency type","url":"/docs/api/bxl/dependency/#dependencysub_target","content":"def dependency.sub_target(subtarget: str, /) -&gt; dependency  Obtain the dependency representing a subtarget. In most cases you will want to use x[DefaultInfo].sub_targets[&quot;foo&quot;] to get the providers of the subtarget, but if you need a real Dependency type (e.g. for use with ctx.action.anon_target) then use this method. "},{"title":"ensured_artifact_group type","type":0,"sectionRef":"#","url":"/docs/api/bxl/ensured_artifact_group/","content":"","keywords":""},{"title":"ensured_artifact_group.abs_path​","type":1,"pageTitle":"ensured_artifact_group type","url":"/docs/api/bxl/ensured_artifact_group/#ensured_artifact_groupabs_path","content":"def ensured_artifact_group.abs_path()  Converts each artifact in this artifact group to be printed by its absolute path. Note that this will only print out the absolute path via ctx.output.print(). Starlark's print() will print out the display info for an ensured artifact group. Sample usage: def _impl_abs_path(ctx): # some target with RunInfo outputs result = ctx.analysis(&quot;root//bin/kind:target_with_outputs&quot;) ensured = ctx.output.ensure_multiple(result.providers()[RunInfo]) # currently defaults to creating an EnsuredArtifactGroup with a relative path ensured_with_abs_path = ensured.abs_path() # create a new EnsuredArtifactGroup with absolute path to reuse print(ensured_with_abs_path) # should return something like &lt;ensured group ... &gt; ctx.output.print(ensured_with_abs_path) # should return the absolute path of the artifact   "},{"title":"ensured_artifact_group.rel_path​","type":1,"pageTitle":"ensured_artifact_group type","url":"/docs/api/bxl/ensured_artifact_group/#ensured_artifact_grouprel_path","content":"def ensured_artifact_group.rel_path()  Converts each artifact in this artifact group to be printed by its path relative to the project root. Note that this will only print out the relative path via ctx.output.print(). Starlark's print() will print out the display info for an ensured artifact group. Sample usage: def _impl_rel_path(ctx): # some target with RunInfo outputs result = ctx.analysis(&quot;root//bin/kind:target_with_outputs&quot;) ensured = ctx.output.ensure_multiple(result.providers()[RunInfo]) # currently defaults to creating an EnsuredArtifactGroup with a relative path ensured_with_rel_path = ensured.rel_path() # create a new EnsuredArtifact with relative path to reuse print(ensured_with_rel_path) # should return something like &lt;ensured group ... &gt; ctx.output.print(ensured_with_rel_path) # should return the relative path of the artifact  "},{"title":"instant type","type":0,"sectionRef":"#","url":"/docs/api/bxl/instant/","content":"","keywords":""},{"title":"instant.elapsed_millis​","type":1,"pageTitle":"instant type","url":"/docs/api/bxl/instant/#instantelapsed_millis","content":"def instant.elapsed_millis() -&gt; float  Elapsed time in millis as a float Sample usage: def _impl_elapsed_millis(ctx): now = now() time_a = now.elapsed_millis() # do something that takes a long time time_b = now.elapsed_millis() ctx.output.print(time_a) ctx.output.print(time_b)   "},{"title":"instant.elapsed_secs​","type":1,"pageTitle":"instant type","url":"/docs/api/bxl/instant/#instantelapsed_secs","content":"def instant.elapsed_secs() -&gt; float  Elapsed time in secs as a float Sample usage: def _impl_elapsed_secs(ctx): now = now() time_a = now.elapsed_secs() # do something that takes a long time time_b = now.elapsed_secs() ctx.output.print(time_a) ctx.output.print(time_b)  "},{"title":"label_relative_path type","type":0,"sectionRef":"#","url":"/docs/api/bxl/label_relative_path/","content":"","keywords":""},{"title":"label_relative_path.add​","type":1,"pageTitle":"label_relative_path type","url":"/docs/api/bxl/label_relative_path/#label_relative_pathadd","content":"def label_relative_path.add(arg: str) -&gt; label_relative_path  "},{"title":"label type","type":0,"sectionRef":"#","url":"/docs/api/bxl/label/","content":"","keywords":""},{"title":"label.cell​","type":1,"pageTitle":"label type","url":"/docs/api/bxl/label/#labelcell","content":"label.cell: str  For the label fbcode//buck2/hello:world (ovr_config//platform/linux:x86_64-fbcode-46b26edb4b80a905) this gives back fbcode  "},{"title":"label.cell_root​","type":1,"pageTitle":"label type","url":"/docs/api/bxl/label/#labelcell_root","content":"label.cell_root: cell_root  Obtain a reference to this target label's cell root. This can be used as if it were an artifact in places that expect one, such as cmd_args().relative_to.  "},{"title":"label.configured_target​","type":1,"pageTitle":"label type","url":"/docs/api/bxl/label/#labelconfigured_target","content":"def label.configured_target() -&gt; configured_target_label  Returns the underlying configured target label, dropping the sub target  "},{"title":"label.name​","type":1,"pageTitle":"label type","url":"/docs/api/bxl/label/#labelname","content":"label.name: str  For the label fbcode//buck2/hello:world (ovr_config//platform/linux:x86_64-fbcode-46b26edb4b80a905) this gives back world  "},{"title":"label.package​","type":1,"pageTitle":"label type","url":"/docs/api/bxl/label/#labelpackage","content":"label.package: str  For the label fbcode//buck2/hello:world (ovr_config//platform/linux:x86_64-fbcode-46b26edb4b80a905) this gives back buck2/hello  "},{"title":"label.path​","type":1,"pageTitle":"label type","url":"/docs/api/bxl/label/#labelpath","content":"label.path: label_relative_path  For the label fbcode//buck2/hello:world (ovr_config//platform/linux:x86_64-fbcode-46b26edb4b80a905) this gives back fbcode/buck2/hello  "},{"title":"label.project_root​","type":1,"pageTitle":"label type","url":"/docs/api/bxl/label/#labelproject_root","content":"label.project_root: project_root  Obtain a reference to the project's root. This can be used as if it were an artifact in places that expect one, such as cmd_args().relative_to.  "},{"title":"label.raw_target​","type":1,"pageTitle":"label type","url":"/docs/api/bxl/label/#labelraw_target","content":"def label.raw_target() -&gt; target_label  For the label fbcode//buck2/hello:world (ovr_config//platform/linux:x86_64-fbcode-46b26edb4b80a905) this returns the unconfigured underlying target label (fbcode//buck2/hello:world)  "},{"title":"label.sub_target​","type":1,"pageTitle":"label type","url":"/docs/api/bxl/label/#labelsub_target","content":"label.sub_target: None | list[str]  "},{"title":"lazy_attrs type","type":0,"sectionRef":"#","url":"/docs/api/bxl/lazy_attrs/","content":"","keywords":""},{"title":"lazy_attrs.get​","type":1,"pageTitle":"lazy_attrs type","url":"/docs/api/bxl/lazy_attrs/#lazy_attrsget","content":"def lazy_attrs.get(attr: str) -&gt; None | configured_attr  Gets a single attribute. Returns an optional [configured_attr]. def _impl_attrs_lazy(ctx): node = ctx.cquery().owner(&quot;cell//path/to/TARGETS&quot;)[0] attrs = node.attrs_lazy() # cache once ctx.output.print(attrs.get(&quot;some_attributes&quot;).value()) ctx.output.print(attrs.get(&quot;some_attribute&quot;).label)  "},{"title":"plugins type","type":0,"sectionRef":"#","url":"/docs/api/bxl/plugins/","content":"","keywords":""},{"title":"plugins.All​","type":1,"pageTitle":"plugins type","url":"/docs/api/bxl/plugins/#pluginsall","content":"plugins.All: all_plugins  A special value for use with pulls_and_pushes_plugins. This value can be passed to pulls_and_pushes_plugins on any attr.dep() to indicate that all plugin kinds from the dep should be pulled and pushed. This is useful for rules likealias. This value is not supported on uses_plugins at this time, and hence it is not useful onpulls_plugins either.  "},{"title":"plugins.PluginKind​","type":1,"pageTitle":"plugins type","url":"/docs/api/bxl/plugins/#pluginspluginkind","content":"plugins.PluginKind: type  Type symbol for PluginKind.  "},{"title":"plugins.kind​","type":1,"pageTitle":"plugins type","url":"/docs/api/bxl/plugins/#pluginskind","content":"def plugins.kind() -&gt; PluginKind  Create a new plugin kind. The value returned should always be immediately bound to a global, like MyPluginKind = plugins.kind() "},{"title":"promise type","type":0,"sectionRef":"#","url":"/docs/api/bxl/promise/","content":"","keywords":""},{"title":"promise.join​","type":1,"pageTitle":"promise type","url":"/docs/api/bxl/promise/#promisejoin","content":"def promise.join(*args) -&gt; promise  Join a set of promises together into a single promise. Given a series of promises, p4 = p1.join(p2, p3) will produce a promise where the value is promise that resolves to a tuple containing the three values, those from p1, p2 and p3 respectively.  "},{"title":"promise.map​","type":1,"pageTitle":"promise type","url":"/docs/api/bxl/promise/#promisemap","content":"def promise.map(func: typing.Callable[[typing.Any], typing.Any], /) -&gt; promise  Given a promise, apply a function to the value it contains, producing a promise with the resulting value. "},{"title":"provider_collection type","type":0,"sectionRef":"#","url":"/docs/api/bxl/provider_collection/","content":"","keywords":""},{"title":"provider_collection.get​","type":1,"pageTitle":"provider_collection type","url":"/docs/api/bxl/provider_collection/#provider_collectionget","content":"def provider_collection.get(index) -&gt; None | provider  "},{"title":"StackFrame type","type":0,"sectionRef":"#","url":"/docs/api/bxl/StackFrame/","content":"","keywords":""},{"title":"StackFrame.func_name​","type":1,"pageTitle":"StackFrame type","url":"/docs/api/bxl/StackFrame/#stackframefunc_name","content":"StackFrame.func_name: str  Returns the name of the entry on the call-stack.  "},{"title":"StackFrame.module_path​","type":1,"pageTitle":"StackFrame type","url":"/docs/api/bxl/StackFrame/#stackframemodule_path","content":"StackFrame.module_path: None | str  Returns a path of the module from which the entry was called, or [None] for native Rust functions. "},{"title":"providers_label type","type":0,"sectionRef":"#","url":"/docs/api/bxl/providers_label/","content":"","keywords":""},{"title":"providers_label.cell​","type":1,"pageTitle":"providers_label type","url":"/docs/api/bxl/providers_label/#providers_labelcell","content":"providers_label.cell: str   "},{"title":"providers_label.name​","type":1,"pageTitle":"providers_label type","url":"/docs/api/bxl/providers_label/#providers_labelname","content":"providers_label.name: str   "},{"title":"providers_label.path​","type":1,"pageTitle":"providers_label type","url":"/docs/api/bxl/providers_label/#providers_labelpath","content":"providers_label.path: label_relative_path   "},{"title":"providers_label.raw_target​","type":1,"pageTitle":"providers_label type","url":"/docs/api/bxl/providers_label/#providers_labelraw_target","content":"def providers_label.raw_target() -&gt; target_label  Returns the unconfigured underlying target label.  "},{"title":"providers_label.sub_target​","type":1,"pageTitle":"providers_label type","url":"/docs/api/bxl/providers_label/#providers_labelsub_target","content":"providers_label.sub_target: None | list[str]  "},{"title":"target_label type","type":0,"sectionRef":"#","url":"/docs/api/bxl/target_label/","content":"","keywords":""},{"title":"target_label.cell​","type":1,"pageTitle":"target_label type","url":"/docs/api/bxl/target_label/#target_labelcell","content":"target_label.cell: str   "},{"title":"target_label.name​","type":1,"pageTitle":"target_label type","url":"/docs/api/bxl/target_label/#target_labelname","content":"target_label.name: str   "},{"title":"target_label.package​","type":1,"pageTitle":"target_label type","url":"/docs/api/bxl/target_label/#target_labelpackage","content":"target_label.package: str   "},{"title":"target_label.with_sub_target​","type":1,"pageTitle":"target_label type","url":"/docs/api/bxl/target_label/#target_labelwith_sub_target","content":"def target_label.with_sub_target( subtarget_name: str | list[str] = _ ) -&gt; providers_label  Converts a TargetLabel into its corresponding ProvidersLabel given the subtarget names, which is a list for each layer of subtarget Sample usage: def _impl_sub_target(ctx): owners = ctx.uquery().owner(&quot;bin/TARGETS.fixture&quot;) for owner in owners: unconfigured_label = owner.label ctx.output.print(unconfigured_label.with_sub_target()) ctx.output.print(unconfigured_label.with_sub_target(&quot;subtarget1&quot;)) ctx.output.print(unconfigured_label.with_sub_target([&quot;subtarget1&quot;, &quot;subtarget2&quot;]))  "},{"title":"list type","type":0,"sectionRef":"#","url":"/docs/api/starlark/list/","content":"","keywords":""},{"title":"list.append​","type":1,"pageTitle":"list type","url":"/docs/api/starlark/list/#listappend","content":"def list.append(el, /) -&gt; None  list.append: append an element to a list. L.append(x) appends x to the list L, and returns None. append fails if the list is frozen or has active iterators. x = [] x.append(1) x.append(2) x.append(3) x == [1, 2, 3]   "},{"title":"list.clear​","type":1,"pageTitle":"list type","url":"/docs/api/starlark/list/#listclear","content":"def list.clear() -&gt; None  list.clear: clear a list L.clear() removes all the elements of the list L and returns None. It fails if the list is frozen or if there are active iterators. x = [1, 2, 3] x.clear() x == []   "},{"title":"list.extend​","type":1,"pageTitle":"list type","url":"/docs/api/starlark/list/#listextend","content":"def list.extend(other: typing.Iterable, /) -&gt; None  list.extend: extend a list with another iterable's content. L.extend(x) appends the elements of x, which must be iterable, to the list L, and returns None. extend fails if x is not iterable, or if the list L is frozen or has active iterators. x = [] x.extend([1, 2, 3]) x.extend([&quot;foo&quot;]) x == [1, 2, 3, &quot;foo&quot;]   "},{"title":"list.index​","type":1,"pageTitle":"list type","url":"/docs/api/starlark/list/#listindex","content":"def list.index( needle, start: None | int = None, end: None | int = None, / ) -&gt; int  list.index: get the index of an element in the list. L.index(x[, start[, end]]) finds x within the list L and returns its index. The optional start and end parameters restrict the portion of list L that is inspected. If provided and not None, they must be list indices of type int. If an index is negative, len(L) is effectively added to it, then if the index is outside the range [0:len(L)], the nearest value within that range is used; see Indexing. index fails if x is not found in L, or if start or endis not a valid index (int or None). x = [&quot;b&quot;, &quot;a&quot;, &quot;n&quot;, &quot;a&quot;, &quot;n&quot;, &quot;a&quot;] x.index(&quot;a&quot;) == 1 # bAnana x.index(&quot;a&quot;, 2) == 3 # banAna x.index(&quot;a&quot;, -2) == 5 # bananA   "},{"title":"list.insert​","type":1,"pageTitle":"list type","url":"/docs/api/starlark/list/#listinsert","content":"def list.insert(index: int, el, /) -&gt; None  list.insert: insert an element in a list. L.insert(i, x) inserts the value x in the list L at index i, moving higher-numbered elements along by one. It returns None. As usual, the index i must be an int. If its value is negative, the length of the list is added, then its value is clamped to the nearest value in the range [0:len(L)] to yield the effective index. insert fails if the list is frozen or has active iterators. x = [&quot;b&quot;, &quot;c&quot;, &quot;e&quot;] x.insert(0, &quot;a&quot;) x.insert(-1, &quot;d&quot;) x == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]   "},{"title":"list.pop​","type":1,"pageTitle":"list type","url":"/docs/api/starlark/list/#listpop","content":"def list.pop(index: int = _, /)  list.pop: removes and returns the last element of a list. L.pop([index]) removes and returns the last element of the list L, or, if the optional index is provided, at that index. pop fails if the index is negative or not less than the length of the list, of if the list is frozen or has active iterators. x = [1, 2, 3] x.pop() == 3 x.pop() == 2 x == [1]   "},{"title":"list.remove​","type":1,"pageTitle":"list type","url":"/docs/api/starlark/list/#listremove","content":"def list.remove(needle, /) -&gt; None  list.remove: remove a value from a list L.remove(x) removes the first occurrence of the value x from the list L, and returns None. remove fails if the list does not contain x, is frozen, or has active iterators. x = [1, 2, 3, 2] x.remove(2) x == [1, 3, 2] x.remove(2) x == [1, 3]  A subsequent call to x.remove(2) would yield an error because the element won't be found. x = [1, 2, 3, 2] x.remove(2) x.remove(2) x.remove(2) # error: not found  "},{"title":"dict type","type":0,"sectionRef":"#","url":"/docs/api/starlark/dict/","content":"","keywords":""},{"title":"dict.clear​","type":1,"pageTitle":"dict type","url":"/docs/api/starlark/dict/#dictclear","content":"def dict.clear() -&gt; None  dict.clear: clear a dictionary D.clear() removes all the entries of dictionary D and returns None. It fails if the dictionary is frozen or if there are active iterators. x = {&quot;one&quot;: 1, &quot;two&quot;: 2} x.clear() x == {}   "},{"title":"dict.get​","type":1,"pageTitle":"dict type","url":"/docs/api/starlark/dict/#dictget","content":"def dict.get(key, default = _, /)  dict.get: return an element from the dictionary. D.get(key[, default]) returns the dictionary value corresponding to the given key. If the dictionary contains no such value, getreturns None, or the value of the optional default parameter if present. get fails if key is unhashable. x = {&quot;one&quot;: 1, &quot;two&quot;: 2} x.get(&quot;one&quot;) == 1 x.get(&quot;three&quot;) == None x.get(&quot;three&quot;, 0) == 0   "},{"title":"dict.items​","type":1,"pageTitle":"dict type","url":"/docs/api/starlark/dict/#dictitems","content":"def dict.items() -&gt; list[(typing.Any, typing.Any)]  dict.items: get list of (key, value) pairs. D.items() returns a new list of key/value pairs, one per element in dictionary D, in the same order as they would be returned by a forloop. x = {&quot;one&quot;: 1, &quot;two&quot;: 2} x.items() == [(&quot;one&quot;, 1), (&quot;two&quot;, 2)]   "},{"title":"dict.keys​","type":1,"pageTitle":"dict type","url":"/docs/api/starlark/dict/#dictkeys","content":"def dict.keys() -&gt; list[typing.Any]  dict.keys: get the list of keys of the dictionary. D.keys() returns a new list containing the keys of dictionary D, in the same order as they would be returned by a for loop. x = {&quot;one&quot;: 1, &quot;two&quot;: 2} x.keys() == [&quot;one&quot;, &quot;two&quot;]   "},{"title":"dict.pop​","type":1,"pageTitle":"dict type","url":"/docs/api/starlark/dict/#dictpop","content":"def dict.pop(key, default = _, /)  dict.pop: return an element and remove it from a dictionary. D.pop(key[, default]) returns the value corresponding to the specified key, and removes it from the dictionary. If the dictionary contains no such value, and the optional default parameter is present, popreturns that value; otherwise, it fails. pop fails if key is unhashable, or the dictionary is frozen or has active iterators. x = {&quot;one&quot;: 1, &quot;two&quot;: 2} x.pop(&quot;one&quot;) == 1 x == {&quot;two&quot;: 2} x.pop(&quot;three&quot;, 0) == 0 x.pop(&quot;three&quot;, None) == None  Failure: {'one': 1}.pop('four') # error: not found   "},{"title":"dict.popitem​","type":1,"pageTitle":"dict type","url":"/docs/api/starlark/dict/#dictpopitem","content":"def dict.popitem() -&gt; (typing.Any, typing.Any)  dict.popitem: returns and removes the first key/value pair of a dictionary. D.popitem() returns the first key/value pair, removing it from the dictionary. popitem fails if the dictionary is empty, frozen, or has active iterators. x = {&quot;one&quot;: 1, &quot;two&quot;: 2} x.popitem() == (&quot;one&quot;, 1) x.popitem() == (&quot;two&quot;, 2) x == {}  Failure: {}.popitem() # error: empty dict   "},{"title":"dict.setdefault​","type":1,"pageTitle":"dict type","url":"/docs/api/starlark/dict/#dictsetdefault","content":"def dict.setdefault(key, default = _, /)  dict.setdefault: get a value from a dictionary, setting it to a new value if not present. D.setdefault(key[, default]) returns the dictionary value corresponding to the given key. If the dictionary contains no such value, setdefault, like get, returns None or the value of the optional default parameter if present; setdefault additionally inserts the new key/value entry into the dictionary. setdefault fails if the key is unhashable or if the dictionary is frozen. x = {&quot;one&quot;: 1, &quot;two&quot;: 2} x.setdefault(&quot;one&quot;) == 1 x.setdefault(&quot;three&quot;, 0) == 0 x == {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 0} x.setdefault(&quot;four&quot;) == None x == {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 0, &quot;four&quot;: None}   "},{"title":"dict.update​","type":1,"pageTitle":"dict type","url":"/docs/api/starlark/dict/#dictupdate","content":"def dict.update(pairs = _, /, **kwargs) -&gt; None  dict.update: update values in the dictionary. D.update([pairs][, name=value[, ...]) makes a sequence of key/value insertions into dictionary D, then returns None. If the positional argument pairs is present, it must be None, another dict, or some other iterable. If it is another dict, then its key/value pairs are inserted into D. If it is an iterable, it must provide a sequence of pairs (or other iterables of length 2), each of which is treated as a key/value pair to be inserted into D. For each name=value argument present, the name is converted to a string and used as the key for an insertion into D, with its corresponding value being value. update fails if the dictionary is frozen. x = {} x.update([(&quot;a&quot;, 1), (&quot;b&quot;, 2)], c=3) x.update({&quot;d&quot;: 4}) x.update(e=5) x == {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4, &quot;e&quot;: 5}   "},{"title":"dict.values​","type":1,"pageTitle":"dict type","url":"/docs/api/starlark/dict/#dictvalues","content":"def dict.values() -&gt; list[typing.Any]  dict.values: get the list of values of the dictionary. D.values() returns a new list containing the dictionary's values, in the same order as they would be returned by a for loop over the dictionary. x = {&quot;one&quot;: 1, &quot;two&quot;: 2} x.values() == [1, 2]  "},{"title":"buck-out","type":0,"sectionRef":"#","url":"/docs/concepts/buck_out/","content":"buck-out Buck2 stores build artifacts in a directory named buck-out in the root of yourproject. You should not make assumptions about where Buck2 places your build artifacts within the directory structure beneathbuck-out as these locations depend on Buck2's implementation and could potentially change over time. Instead, to obtain the location of the build artifact for a particular target, you can use one of the --show-*-outputoptions with the buck2 build orbuck2 targets commands, most commonly--show-output. For the full list of ways to show the output location, you can run buck2 build --help or buck2 targets --help. buck2 targets --show-output &lt;target&gt; buck2 build --show-output &lt;target&gt; ","keywords":""},{"title":".buckconfig","type":0,"sectionRef":"#","url":"/docs/concepts/buckconfig/","content":"","keywords":""},{"title":"Performance impact of Buck2 configuration changes​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#performance-impact-of-buck2-configuration-changes","content":"Because configuration settings are sometimes included in the cache keys that Buck2 uses in its caching system, changes to Buck's configuration can invalidate previously-built artifacts in Buck's caches. If this occurs, Buck2 rebuilds those artifacts, which can impact your build time. "},{"title":"The .buckconfig file uses the INI file format​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#the-buckconfig-file-uses-the-ini-file-format","content":"The .buckconfig file uses theINI file format. That is, it is divided into sections where each section contains a collection of key names and keyvalues. The .buckconfig implementation supports some modifications to the INI file format; these are discussed below. "},{"title":"Other INI file parsers​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#other-ini-file-parsers","content":"As mentioned previously, we have extended the INI file parser that Buck2 uses to parse configuration files. As a result, INI file parsers provided by other languages or libraries are often not able to parse Buck's configuration files successfully. "},{"title":"Dot character not supported in section names​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#dot-character-not-supported-in-section-names","content":"We do not support the use of the dot character (.) in section names within Buck2 configuration files. For example, the following is notsupported—although Buck2 does not issue a warning or error. [foo.bar] baz=1  Note that sometimes you might need to define your own custom sections, such as for platform flavors for C++ or Python. These scenarios are examples of when you should be careful not to introduce the dot character in section names. This constraint is because Buck2 uses the dot character to delimit section names and key names in other contexts such as the --config command-line parameter. "},{"title":"Character encoding​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#character-encoding","content":"To ensure that any character can be encoded in a .buckconfig key value, you can use escape sequences to encode characters that would otherwise be problematic. The following escape sequences are supported. \\\\\tbackslash\\&quot;\tdouble quote \\n\tnewline \\r\tcarriage return \\t\ttab \\x##\tUnicode character with code point ## (in hex) \\u####\tUnicode character with code point #### (in hex) \\U########\tUnicode character with code point ######## (in hex) "},{"title":"Key values as lists​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#key-values-as-lists","content":"Although the standard INI format supports only key values that represent a single item, Buck2 supports key values that represent a list of items. The syntax is to separate the items in the list using the space (0x20) character. For example, a key value for the list of command-line flags to be passed to a compiler could be represented as a list of the flags separated by spaces: flags = -foo -bar -baz -qux  When a key value is parsed as a list instead of a single item, the separator character is interpreted as a separator only when it occurs outside of double quotes. For example, if flags is a key value interpreted as a list of items separated by spaces, then flags = -foo &quot;-bar \\u0429&quot;  results in the two strings: foo and -bar Щ; the space character between-bar and \\u0429 is not interpreted as a separator. "},{"title":"Transclusion of values from one key to another​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#transclusion-of-values-from-one-key-to-another","content":"Values from other keys can be transcluded into the current key using the following syntax inside the current key value. $(config &lt;section&gt;.&lt;field&gt;)  For example, to use the [go].vendor_path in a custom setting: [custom_section]custom_value = $(config go.vendor_path)  "},{"title":"Comments​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#comments","content":"In addition to the semicolon (;), you can use the pound sign (#), as a comment character in .buckconfig. "},{"title":".buckconfig.local​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#buckconfiglocal","content":"The root of your project may contain a second configuration file named .buckconfig.local. Its format is the same as that of.buckconfig, but settings in .buckconfig.local override those in.buckconfig. In practice, .buckconfig is a version-controlled file that contains settings that are applicable to all team members, whereas.buckconfig.local is excluded from version control to allow users to define personal settings, such as personal aliases. "},{"title":"Other initialization files​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#other-initialization-files","content":"In addition to the .buckconfig and .buckconfig.local files in the project root, Buck2 reads configuration settings from the following additional locations, some of which are actually directories: Directory .buckconfig.d located in the project root directory.File .buckconfig and directory .buckconfig.d located in the current user's home directory which, on Unix-like systems, is available from theHOME environment variable or through the ~ symbol.File buckconfig and directory buckconfig.d located in system directory/etc/. Buck2 treats any file—irrespective of name—in a.buckconfig.d(buckconfig.d) directory (excluding files found in subdirectories) as a Buck2 configuration file, provided that it adheres to.buckconfig syntax. Note that a .buckconfig.d directory is distinct from the similarly-named .buckd directory which is used by theBuck2 Daemon (buckd) . For a description of how Buck2 resolves collisions between settings in these configuration files, see the sectionPrecedence of Buck2 configuration specificationsbelow. "},{"title":"Command-line control of configuration​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#command-line-control-of-configuration","content":"In addition to the above configuration files, Buck2 supports specifying additional configuration files from the Buck2 command line using the--config-file parameter. You can also specify configuration settingsindividually on the Buck2 command line using the --config (-c) parameter. Furthermore, you can aggregate these settings into flag files using the--flagfile parameter. A flag file provides similar functionality to a configuration file but uses a different syntax. Flag files are sometimes calledmode files or at (@) files. "},{"title":"Precedence of Buck2 configuration specifications​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#precedence-of-buck2-configuration-specifications","content":"The following list shows the order of precedence for how Buck2 interprets its configuration specifications. Settings specified using a method closer to the top of the list have higher precedence and will override those lower on the list. For example, the .buckconfig file in the repo overrides a .buckconfigfile in the user's HOME directory. Configuration specified on the command line using --config (-c),--config-file and --flagfile. Configuration specified later on the command line overrides configuration specified earlier..buckconfig.local in the repo..buckconfig in the repo.Files in a .buckconfig.d folder of the repo..buckconfig.local in user's HOME directory.Files in a .buckconfig.d folder in user's HOME directory.The global file /etc/buckconfigFiles in the global directory /etc/buckconfig.d Files in a .buckconfig.d (buckconfig.d) directory have precedence according to the lexicographical order of their file names. Files later in the lexicographical order have precedence over files earlier in that order. "},{"title":"Configuration files can include other files​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#configuration-files-can-include-other-files","content":"Any of the configuration files that we've discussed so far can also include by reference other files that contain configuration information. These included files can contain complete .buckconfig sections or they can contain a group of key name/value pairs that constitute part of a section. In this second use case, you'll need to ensure that the included file is referenced beneath the appropriate section in the including file. Because of this additional complexity, we recommend that you include only files that contain complete sections. Note: Inclusion of files is a Buck-specific extension to the INI file parser that Buck2 uses. Therefore, if you use this feature, your Buck2 configuration files will probably not be parsable by other more-generic INI file parsers. The syntax to include a file is &lt;file:*path-to-included-file*&gt;  where path-to-included-file is either a relative path from the including file (recommended) or an absolute path from the root of the file system. You can also specify that the file should be included only if it exists by prefixing with a question mark (?). &lt;?file:*path-to-included-file*&gt;  If you use this prefix, it is not an error condition if the file does not exist; Buck2 just silently continues to process the rest of the configuration file. In the following example, the .buckconfig file includes the filecxx-other-platform.include which exists in the subdirectorycxx-other-platform. The .buckconfig file will also include the filefuture-platform from the directory future-platform.include if that file exists. # # .buckconfig # [cxx] cxxppflags=&quot;-D MYMACRO=\\&quot;Buck\\&quot;&quot; &lt;file:cxx-other-platform/cxx-other-platform.include&gt; &lt;?file:future-platform/future-platform.include&gt; # # cxx-other-platform.include # [cxx#other_platform] cxxppflags=&quot;-D MYMACRO=\\&quot;Watchman\\&quot;&quot;  "},{"title":"Sections​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#sections","content":"Below is an incomplete list of supported buckconfigs. "},{"title":"[alias]​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#alias","content":"This section contains definitions of build target aliases. [alias]app = //apps/myapp:app apptest = //apps/myapp:test  These aliases can then be used from the command line: $ buck2 build app $ buck2 test apptest  "},{"title":"[cells]​","type":1,"pageTitle":".buckconfig","url":"/docs/concepts/buckconfig/#cells","content":"Lists the cells that constitute the Buck2 project. Buck2 builds that are part of this project—that is, which use this .buckconfig—can access the cells specified in this section. [cells] buck = . bazel_skylib = ./third-party/skylark/bazel-skylib  The string on the left-hand side of the equals sign is the alias for the cell. The string on the right-hand side of the equals sign is the path to the cell from the directory that contains this .buckconfig file. It is not necessary to include the current cell in this section, but we consider it a best practice to do so: buck = .  You can view the contents of this section using the buck2 audit cell command. [repositories] is additionally supported as a deprecated alternative name for this section. "},{"title":"globals","type":0,"sectionRef":"#","url":"/docs/api/starlark/globals/","content":"","keywords":""},{"title":"False​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#false","content":"False: bool   "},{"title":"None​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#none","content":"None: None   "},{"title":"True​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#true","content":"True: bool   "},{"title":"abs​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#abs","content":"def abs(x: float | int, /) -&gt; float | int  Take the absolute value of an int. abs(0) == 0 abs(-10) == 10 abs(10) == 10 abs(10.0) == 10.0 abs(-12.34) == 12.34   "},{"title":"all​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#all","content":"def all(x: typing.Iterable, /) -&gt; bool  all: returns true if all values in the iterable object have a truth value of true. all([1, True]) == True all([1, 1]) == True all([0, 1, True]) == False all([True, 1, True]) == True all([0, 0]) == False all([0, False]) == False all([True, 0]) == False all([1, False]) == False   "},{"title":"any​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#any","content":"def any(x: typing.Iterable, /) -&gt; bool  any: returns true if any value in the iterable object have a truth value of true. any([0, True]) == True any([0, 1]) == True any([0, 1, True]) == True any([0, 0]) == False any([0, False]) == False   "},{"title":"bool​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#bool","content":"def bool(x = _, /) -&gt; bool  bool: returns the truth value of any starlark value. .type attribute​ Produces &quot;bool&quot; Details​ bool() == False bool([]) == False bool([1]) == True bool(True) == True bool(False) == False bool(None) == False bool(bool) == True bool(1) == True bool(0) == False bool({}) == False bool({1:2}) == True bool(()) == False bool((1,)) == True bool(&quot;&quot;) == False bool(&quot;1&quot;) == True   "},{"title":"breakpoint​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#breakpoint","content":"def breakpoint() -&gt; None  When a debugger is available, breaks into the debugger.  "},{"title":"call_stack​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#call_stack","content":"def call_stack(*, strip_frames: int = 0) -&gt; str  Get a textual representation of the call stack. This is intended only for debugging purposes to display to a human and should not be considered stable or parseable. strip_frames will pop N frames from the top of the call stack, which can be useful to hide non-interesting lines - for example, strip_frames=1 will hide the call to and location of call_stack() itself.  "},{"title":"call_stack_frame​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#call_stack_frame","content":"def call_stack_frame(n: int, /) -&gt; None | StackFrame  Get a structural representation of the n-th call stack frame. With n=0 returns call_stack_frame itself. Returns None if n is greater than or equal to the stack size.  "},{"title":"chr​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#chr","content":"def chr(i: int, /) -&gt; str  chr: returns a string encoding a codepoint. chr(i) returns a string that encodes the single Unicode code point whose value is specified by the integer i. chr fails unless 0 ≤ i ≤ 0x10FFFF. chr(65) == 'A' chr(1049) == 'Й' chr(0x1F63F) == '😿'   "},{"title":"debug​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#debug","content":"def debug(val, /) -&gt; str  Print the value with full debug formatting. The result may not be stable over time. Intended for debugging purposes and guaranteed to produce verbose output not suitable for user display.  "},{"title":"dict​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#dict","content":"def dict(*args, **kwargs) -&gt; dict[typing.Any, typing.Any]  dict: creates a dictionary. .type attribute​ Produces &quot;dict&quot; Details​ dict creates a dictionary. It accepts up to one positional argument, which is interpreted as an iterable of two-element sequences (pairs), each specifying a key/value pair in the resulting dictionary. dict also accepts any number of keyword arguments, each of which specifies a key/value pair in the resulting dictionary; each keyword is treated as a string. dict() == {} dict(**{'a': 1}) == {'a': 1} dict({'a': 1}) == {'a': 1} dict([(1, 2), (3, 4)]) == {1: 2, 3: 4} dict([(1, 2), ['a', 'b']]) == {1: 2, 'a': 'b'} dict(one=1, two=2) == {'one': 1, 'two': 2} dict([(1, 2)], x=3) == {1: 2, 'x': 3} dict([('x', 2)], x=3) == {'x': 3} x = {'a': 1} y = dict([('x', 2)], **x) x == {'a': 1} and y == {'x': 2, 'a': 1}   "},{"title":"dir​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#dir","content":"def dir(x, /) -&gt; list[str]  dir: list attributes of a value. dir(x) returns a list of the names of the attributes (fields and methods) of its operand. The attributes of a value x are the namesf such that x.f is a valid expression. &quot;capitalize&quot; in dir(&quot;abc&quot;)   "},{"title":"enum​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#enum","content":"def enum(*args: str)  The enum type represents one value picked from a set of values. For example: MyEnum = enum(&quot;option1&quot;, &quot;option2&quot;, &quot;option3&quot;)  This statement defines an enumeration MyEnum that consists of the three values &quot;option1&quot;, &quot;option2&quot; and option3. Now MyEnum is defined, it's possible to do the following: Create values of this type with MyEnum(&quot;option2&quot;). It is a runtime error if the argument is not one of the predeclared values of the enumeration.Get the type of the enum suitable for a type annotation with MyEnum.Given a value of the enum (for example, v = MyEnum(&quot;option2&quot;)), get the underlying value v.value == &quot;option2&quot; or the index in the enumeration v.index == 1.Get a list of the values that make up the array with MyEnum.values() == [&quot;option1&quot;, &quot;option2&quot;, &quot;option3&quot;].Treat MyEnum a bit like an array, with len(MyEnum) == 3, MyEnum[1] == MyEnum(&quot;option2&quot;) and iteration over enums [x.value for x in MyEnum] == [&quot;option1&quot;, &quot;option2&quot;, &quot;option3&quot;]. Enumeration types store each value once, which are then efficiently referenced by enumeration values.  "},{"title":"enumerate​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#enumerate","content":"def enumerate(it: typing.Iterable, /, start: int = 0) -&gt; list[(int, typing.Any)]  enumerate: return a list of (index, element) from an iterable. enumerate(x) returns a list of (index, value) pairs, each containing successive values of the iterable sequence and the index of the value within the sequence. The optional second parameter, start, specifies an integer value to add to each index. enumerate([&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]) == [(0, &quot;zero&quot;), (1, &quot;one&quot;), (2, &quot;two&quot;)] enumerate([&quot;one&quot;, &quot;two&quot;], 1) == [(1, &quot;one&quot;), (2, &quot;two&quot;)]   "},{"title":"eval_type​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#eval_type","content":"def eval_type(ty: type, /) -&gt; type  Create a runtime type object which can be used to check if a value matches the given type.  "},{"title":"fail​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#fail","content":"def fail(*args) -&gt; typing.Never  fail: fail the execution fail(&quot;this is an error&quot;) # fail: this is an error fail(&quot;oops&quot;, 1, False) # fail: oops 1 False   "},{"title":"field​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#field","content":"def field(typ, /, default = _) -&gt; field  Creates a field record. Used as an argument to the record function. rec_type = record(host=field(str), port=field(int), mask=field(int, default=255)) rec = rec_type(host=&quot;localhost&quot;, port=80) rec.port == 80 rec.mask == 255   "},{"title":"filter​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#filter","content":"def filter( func: None | typing.Callable, seq: typing.Iterable, / ) -&gt; list[typing.Any]  Apply a predicate to each element of the iterable, returning those that match. As a special case if the function is None then removes all the None values. filter(bool, [0, 1, False, True]) == [1, True] filter(lambda x: x &gt; 2, [1, 2, 3, 4]) == [3, 4] filter(None, [True, None, False]) == [True, False]   "},{"title":"float​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#float","content":"def float(a: bool | float | int | str = _, /) -&gt; float  float: interprets its argument as a floating-point number. .type attribute​ Produces &quot;float&quot; Details​ If x is a float, the result is x. if x is an int, the result is the nearest floating point value to x. If x is a string, the string is interpreted as a floating-point literal. With no arguments, float() returns 0.0. float() == 0.0 float(1) == 1.0 float('1') == 1.0 float('1.0') == 1.0 float('.25') == 0.25 float('1e2') == 100.0 float(False) == 0.0 float(True) == 1.0 float(&quot;hello&quot;) # error: not a valid number float([]) # error   "},{"title":"getattr​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#getattr","content":"def getattr( a, attr: str, default = _, / )  getattr: returns the value of an attribute getattr(x, name) returns the value of the attribute (field or method) of x named name. It is a dynamic error if x has no such attribute. getattr(x, &quot;f&quot;) is equivalent to x.f. getattr(x, &quot;f&quot;, d) is equivalent to x.f if hasattr(x, &quot;f&quot;) else dand will never raise an error. getattr(&quot;banana&quot;, &quot;split&quot;)(&quot;a&quot;) == [&quot;b&quot;, &quot;n&quot;, &quot;n&quot;, &quot;&quot;] # equivalent to &quot;banana&quot;.split(&quot;a&quot;)   "},{"title":"hasattr​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#hasattr","content":"def hasattr(a, attr: str, /) -&gt; bool  hasattr: test if an object has an attribute hasattr(x, name) reports whether x has an attribute (field or method) named name.  "},{"title":"hash​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#hash","content":"def hash(a: str, /) -&gt; int  hash: returns the hash number of a value. hash(x) returns an integer hash value for x such that x == yimplies hash(x) == hash(y). hash fails if x, or any value upon which its hash depends, is unhashable. hash(&quot;hello&quot;) != hash(&quot;world&quot;)   "},{"title":"int​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#int","content":"def int(a: bool | float | int | str = _, /, base: int = _) -&gt; int  int: convert a value to integer. .type attribute​ Produces &quot;int&quot; Details​ int(x[, base]) interprets its argument as an integer. If x is an int, the result is x. If x is a float, the result is the integer value nearest to x, truncating towards zero; it is an error if x is not finite (NaN,+Inf, -Inf). If x is a bool, the result is 0 for False or 1 for True. If x is a string, it is interpreted like a string literal; an optional base prefix (0, 0b, 0B, 0x, 0X) determines which base to use. The string may specify an arbitrarily large integer, whereas true integer literals are restricted to 64 bits. If a non-zero base argument is provided, the string is interpreted in that base and no base prefix is permitted; the base argument may specified by name. int() with no arguments returns 0. int() == 0 int(1) == 1 int(False) == 0 int(True) == 1 int('1') == 1 int('16') == 16 int('16', 10) == 16 int('16', 8) == 14 int('16', 16) == 22 int(0.0) == 0 int(3.14) == 3 int(-12345.6789) == -12345 int(2e9) == 2000000000 int(&quot;hello&quot;) # error: Cannot parse int(float(&quot;nan&quot;)) # error: cannot be represented as exact integer int(float(&quot;inf&quot;)) # error: cannot be represented as exact integer   "},{"title":"isinstance​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#isinstance","content":"def isinstance(value, ty: type, /) -&gt; bool  Check if a value matches the given type.  "},{"title":"json​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#json","content":"json: struct(decode = &quot;function&quot;, encode = &quot;function&quot;)   "},{"title":"len​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#len","content":"def len(a, /) -&gt; int  len: get the length of a sequence len(x) returns the number of elements in its argument. It is a dynamic error if its argument is not a sequence. len(()) == 0 len({}) == 0 len([]) == 0 len([1]) == 1 len([1,2]) == 2 len({'16': 10}) == 1 len(True) # error: not supported   "},{"title":"list​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#list","content":"def list(a: typing.Iterable = _, /) -&gt; list[typing.Any]  list: construct a list. .type attribute​ Produces &quot;list&quot; Details​ list(x) returns a new list containing the elements of the iterable sequence x. With no argument, list() returns a new empty list. list() == [] list((1,2,3)) == [1, 2, 3] list(&quot;strings are not iterable&quot;) # error: not supported   "},{"title":"map​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#map","content":"def map(func: typing.Callable, seq: typing.Iterable, /) -&gt; list[typing.Any]  Apply a function to each element of the iterable, returning the results. map(abs, [7, -5, -6]) == [7, 5, 6] map(lambda x: x * 2, [1, 2, 3, 4]) == [2, 4, 6, 8]   "},{"title":"max​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#max","content":"def max(*args, key = _)  max: returns the maximum of a sequence. max(x) returns the greatest element in the iterable sequence x. It is an error if any element does not support ordered comparison, or if the sequence is empty. The optional named parameter key specifies a function to be applied to each element prior to comparison. max([3, 1, 4, 1, 5, 9]) == 9 max(&quot;two&quot;, &quot;three&quot;, &quot;four&quot;) == &quot;two&quot; # the lexicographically greatest max(&quot;two&quot;, &quot;three&quot;, &quot;four&quot;, key=len) == &quot;three&quot; # the longest   "},{"title":"min​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#min","content":"def min(*args, key = _)  min: returns the minimum of a sequence. min(x) returns the least element in the iterable sequence x. It is an error if any element does not support ordered comparison, or if the sequence is empty. min([3, 1, 4, 1, 5, 9]) == 1 min(&quot;two&quot;, &quot;three&quot;, &quot;four&quot;) == &quot;four&quot; # the lexicographically least min(&quot;two&quot;, &quot;three&quot;, &quot;four&quot;, key=len) == &quot;two&quot; # the shortest   "},{"title":"ord​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#ord","content":"def ord(a: str, /) -&gt; int  ord: returns the codepoint of a character ord(s) returns the integer value of the sole Unicode code point encoded by the string s. If s does not encode exactly one Unicode code point, ord fails. Each invalid code within the string is treated as if it encodes the Unicode replacement character, U+FFFD. Example: ord(&quot;A&quot;) == 65 ord(&quot;Й&quot;) == 1049 ord(&quot;😿&quot;) == 0x1F63F   "},{"title":"partial​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#partial","content":"def partial( func, /, *args, **kwargs ) -&gt; function  Construct a partial application. In almost all cases it is simpler to use a lamdba.  "},{"title":"pprint​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#pprint","content":"def pprint(*args) -&gt; None   "},{"title":"prepr​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#prepr","content":"def prepr(a, /) -&gt; str  Like repr, but produces more verbose pretty-printed output  "},{"title":"print​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#print","content":"def print(*args) -&gt; None  Print some values to the output.  "},{"title":"pstr​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#pstr","content":"def pstr(a, /) -&gt; str  Like str, but produces more verbose pretty-printed output  "},{"title":"range​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#range","content":"def range( a1: int, a2: int = _, step: int = 1, / ) -&gt; range  range: return a range of integers .type attribute​ Produces &quot;range&quot; Details​ range returns a tuple of integers defined by the specified interval and stride. range(stop) # equivalent to range(0, stop) range(start, stop) # equivalent to range(start, stop, 1) range(start, stop, step)  range requires between one and three integer arguments. With one argument, range(stop) returns the ascending sequence of non-negative integers less than stop. With two arguments, range(start, stop) returns only integers not less than start. With three arguments, range(start, stop, step) returns integers formed by successively adding step to start until the value meets or passes stop. A call to range fails if the value of step is zero. list(range(10)) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] list(range(3, 10)) == [3, 4, 5, 6, 7, 8, 9] list(range(3, 10, 2)) == [3, 5, 7, 9] list(range(10, 3, -2)) == [10, 8, 6, 4]   "},{"title":"record​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#record","content":"def record(**kwargs) -&gt; function  A record type represents a set of named values, each with their own type. For example: MyRecord = record(host=str, port=int)  This above statement defines a record MyRecord with 2 fields, the first named host that must be of type str, and the second named port that must be of type int. Now MyRecord is defined, it's possible to do the following: Create values of this type with MyRecord(host=&quot;localhost&quot;, port=80). It is a runtime error if any arguments are missed, of the wrong type, or if any unexpected arguments are given.Get the type of the record suitable for a type annotation with MyRecord.type.Get the fields of the record. For example, v = MyRecord(host=&quot;localhost&quot;, port=80) will provide v.host == &quot;localhost&quot; and v.port == 80. Similarly, dir(v) == [&quot;host&quot;, &quot;port&quot;]. It is also possible to specify default values for parameters using the field function. For example: MyRecord = record(host=str, port=field(int, 80))  Now the port field can be omitted, defaulting to 80 is not present (for example, MyRecord(host=&quot;localhost&quot;).port == 80). Records are stored deduplicating their field names, making them more memory efficient than dictionaries.  "},{"title":"repr​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#repr","content":"def repr(a, /) -&gt; str  repr: formats its argument as a string. All strings in the result are double-quoted. repr(1) == '1' repr(&quot;x&quot;) == &quot;\\&quot;x\\&quot;&quot; repr([1, &quot;x&quot;]) == &quot;[1, \\&quot;x\\&quot;]&quot; repr(&quot;test \\&quot;'&quot;) == &quot;\\&quot;test \\\\\\&quot;'\\&quot;&quot; repr(&quot;x\\&quot;y😿 \\\\'&quot;) == &quot;\\&quot;x\\\\\\&quot;y\\\\U0001f63f \\\\\\\\'\\&quot;&quot;   "},{"title":"reversed​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#reversed","content":"def reversed(a: typing.Iterable, /) -&gt; list[typing.Any]  reversed: reverse a sequence reversed(x) returns a new list containing the elements of the iterable sequence x in reverse order. reversed(['a', 'b', 'c']) == ['c', 'b', 'a'] reversed(range(5)) == [4, 3, 2, 1, 0] reversed(&quot;stressed&quot;.elems()) == [&quot;d&quot;, &quot;e&quot;, &quot;s&quot;, &quot;s&quot;, &quot;e&quot;, &quot;r&quot;, &quot;t&quot;, &quot;s&quot;] reversed({&quot;one&quot;: 1, &quot;two&quot;: 2}.keys()) == [&quot;two&quot;, &quot;one&quot;]   "},{"title":"sorted​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#sorted","content":"def sorted( x, /, *, key = _, reverse: bool = False ) -&gt; list[typing.Any]  sorted: sort a sequence sorted(x) returns a new list containing the elements of the iterable sequence x, in sorted order. The sort algorithm is stable. The optional named parameter reverse, if true, causes sorted to return results in reverse sorted order. The optional named parameter key specifies a function of one argument to apply to obtain the value's sort key. The default behavior is the identity function. sorted([3, 1, 4, 1, 5, 9]) == [1, 1, 3, 4, 5, 9] sorted([3, 1, 4, 1, 5, 9], reverse=True) == [9, 5, 4, 3, 1, 1] sorted([&quot;two&quot;, &quot;three&quot;, &quot;four&quot;], key=len) == [&quot;two&quot;, &quot;four&quot;, &quot;three&quot;] # shortest to longest sorted([&quot;two&quot;, &quot;three&quot;, &quot;four&quot;], key=len, reverse=True) == [&quot;three&quot;, &quot;four&quot;, &quot;two&quot;] # longest to shortest   "},{"title":"starlark_rust_internal​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#starlark_rust_internal","content":"starlark_rust_internal: struct(ty_of_value_debug = &quot;function&quot;)   "},{"title":"str​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#str","content":"def str(a, /) -&gt; str  str: formats its argument as a string. .type attribute​ Produces &quot;string&quot; Details​ If x is a string, the result is x (without quotation). All other strings, such as elements of a list of strings, are double-quoted. str(1) == '1' str(&quot;x&quot;) == 'x' str([1, &quot;x&quot;]) == &quot;[1, \\&quot;x\\&quot;]&quot;   "},{"title":"struct​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#struct","content":"def struct(*args, **kwargs) -&gt; struct(..)  .type attribute​ Produces &quot;struct&quot;  "},{"title":"tuple​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#tuple","content":"def tuple(a: typing.Iterable = _, /) -&gt; tuple  tuple: returns a tuple containing the elements of the iterable x. .type attribute​ Produces &quot;tuple&quot; Details​ With no arguments, tuple() returns the empty tuple. tuple() == () tuple([1,2,3]) == (1, 2, 3)   "},{"title":"type​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#type","content":"def type(a, /) -&gt; str  type: returns a string describing the type of its operand. .type attribute​ Produces &quot;type&quot; Details​ type(None) == &quot;NoneType&quot; type(0) == &quot;int&quot; type(1) == &quot;int&quot; type(()) == &quot;tuple&quot; type(&quot;hello&quot;) == &quot;string&quot;   "},{"title":"typing​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#typing","content":"typing: struct(Any = typing.Any, Callable = typing.Callable, Iterable = typing.Iterable, Never = typing.Never)   "},{"title":"zip​","type":1,"pageTitle":"globals","url":"/docs/api/starlark/globals/#zip","content":"def zip(*args: typing.Iterable) -&gt; list[typing.Any]  zip: zip several iterables together zip() returns a new list of n-tuples formed from corresponding elements of each of the n iterable sequences provided as arguments tozip. That is, the first tuple contains the first element of each of the sequences, the second element contains the second element of each of the sequences, and so on. The result list is only as long as the shortest of the input sequences. zip() == [] zip(range(5)) == [(0,), (1,), (2,), (3,), (4,)] zip(range(5), &quot;abc&quot;.elems()) == [(0, &quot;a&quot;), (1, &quot;b&quot;), (2, &quot;c&quot;)]  "},{"title":"Build File","type":0,"sectionRef":"#","url":"/docs/concepts/build_file/","content":"Build File A build file is a file, typically named BUCK, that defines one or morebuild rules. Note that you can change the name that Buck2 uses for the build file in the buildfile section of .buckconfig. A source file in your project can only be referenced by rules in its &quot;nearest&quot; build file, where &quot;nearest&quot; means its closest direct ancestor in your project's file tree. (If a source file has a build file as a sibling, then that is its nearest ancestor.) For example, if your project had the following BUCK files: java/com/facebook/base/BUCK java/com/facebook/common/BUCK java/com/facebook/common/collect/BUCK Then your build rules would have the following constraints: Rules in java/com/facebook/base/BUCK can reference any file underjava/com/facebook/base/.Rules in java/com/facebook/common/ can reference any files under that directory, except for those under java/com/facebook/common/collect/, as those &quot;belong&quot; to the BUCK file in the collect directory. The set of source files accessible to a build file is also known as its build package. The way to refer to code across build packages is to create build rules and use deps to refer to that code. Going back to the previous example, suppose code in java/com/facebook/common/concurrent/ wants to depend on code in java/com/facebook/common/collect/. Presumablyjava/com/facebook/common/collect/BUCK has a build rule like: java_library( name = 'collect', srcs = glob(['*.java']), deps = ['//java/com/facebook/base:base',],) Then java/com/facebook/common/BUCK could have a rule like: java_library( name = 'concurrent', srcs = glob(['concurrent/*.java']), deps = ['//java/com/facebook/base:base','//java/com/facebook/common/collect:collect',],) whereas the following would be invalid becausejava/com/facebook/common/collect/ has its own build file, so//java/com/facebook/common/collect:concurrent cannot listjava/com/facebook/common/collect/*.java in its srcs. java_library( name = 'concurrent', srcs = glob(['collect/*.java', 'concurrent/*.java']), deps = ['//java/com/facebook/base:base',],) ","keywords":""},{"title":"string type","type":0,"sectionRef":"#","url":"/docs/api/starlark/string/","content":"","keywords":""},{"title":"string.capitalize​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringcapitalize","content":"def string.capitalize() -&gt; str  string.capitalize: returns a copy of string S, where the first character (if any) is converted to uppercase; all other characters are converted to lowercase. &quot;hello, world!&quot;.capitalize() == &quot;Hello, world!&quot; &quot;Hello, World!&quot;.capitalize() == &quot;Hello, world!&quot; &quot;&quot;.capitalize() == &quot;&quot;   "},{"title":"string.codepoints​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringcodepoints","content":"def string.codepoints() -&gt; typing.Iterable[str]  string.codepoints: returns an iterable of the unicode codepoint of a string. S.codepoints() returns an iterable value containing the sequence of integer Unicode code points encoded by the string S. Each invalid code within the string is treated as if it encodes the Unicode replacement character, U+FFFD. By returning an iterable, not a list, the cost of decoding the string is deferred until actually needed; apply list(...) to the result to materialize the entire sequence. list(&quot;Hello, 世界&quot;.codepoints()) == [72, 101, 108, 108, 111, 44, 32, 19990, 30028]   "},{"title":"string.count​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringcount","content":"def string.count( needle: str, start: None | int = None, end: None | int = None, / ) -&gt; int  string.count: count the number of occurrences of a string in another string. S.count(sub[, start[, end]]) returns the number of occurrences ofsub within the string S, or, if the optional substring indicesstart and end are provided, within the designated substring of S. They are interpreted according to Skylark's indexing conventions. This implementation does not count occurrence of sub in the string Sthat overlap other occurrence of S (which can happen if some suffix of S is a prefix of S). For instance, &quot;abababa&quot;.count(&quot;aba&quot;) returns 2 for [aba]a[aba], not counting the middle occurrence: ab[aba]ba(this is following Python behavior). &quot;hello, world!&quot;.count(&quot;o&quot;) == 2 &quot;abababa&quot;.count(&quot;aba&quot;) == 2 &quot;hello, world!&quot;.count(&quot;o&quot;, 7, 12) == 1 # in &quot;world&quot;   "},{"title":"string.elems​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringelems","content":"def string.elems() -&gt; typing.Iterable[str]  string.elems: returns an iterable of the bytes values of a string. S.elems() returns an iterable value containing the sequence of numeric bytes values in the string S. To materialize the entire sequence of bytes, apply list(...) to the result. list(&quot;Hello, 世界&quot;.elems()) == [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;,&quot;, &quot; &quot;, &quot;世&quot;, &quot;界&quot;]   "},{"title":"string.endswith​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringendswith","content":"def string.endswith(suffix: str | tuple[str, ...], /) -&gt; bool  string.endswith: determine if a string ends with a given suffix. S.endswith(suffix) reports whether the string S has the specified suffix. &quot;filename.sky&quot;.endswith(&quot;.sky&quot;) == True   "},{"title":"string.find​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringfind","content":"def string.find( needle: str, start: None | int = None, end: None | int = None, / ) -&gt; int  string.find: find a substring in a string. S.find(sub[, start[, end]]) returns the index of the first occurrence of the substring sub within S. If either or both of start or end are specified, they specify a subrange of S to which the search should be restricted. They are interpreted according to Skylark's indexing conventions. If no occurrence is found, found returns -1. &quot;bonbon&quot;.find(&quot;on&quot;) == 1 &quot;bonbon&quot;.find(&quot;on&quot;, 2) == 4 &quot;bonbon&quot;.find(&quot;on&quot;, 2, 5) == -1   "},{"title":"string.format​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringformat","content":"def string.format(*args, **kwargs) -&gt; str  string.format: format a string. S.format(*args, **kwargs) returns a version of the format string S in which bracketed portions {...} are replaced by arguments from args and kwargs. Within the format string, a pair of braces {{ or }} is treated as a literal open or close brace. Each unpaired open brace must be matched by a close brace }. The optional text between corresponding open and close braces specifies which argument to use and how to format it, and consists of three components, all optional: a field name, a conversion preceded by '!', and a format specifier preceded by ':'. {field} {field:spec} {field!conv} {field!conv:spec}  The field name may be either a decimal number or a keyword. A number is interpreted as the index of a positional argument; a keyword specifies the value of a keyword argument. If all the numeric field names form the sequence 0, 1, 2, and so on, they may be omitted and those values will be implied; however, the explicit and implicit forms may not be mixed. The conversion specifies how to convert an argument value x to a string. It may be either !r, which converts the value usingrepr(x), or !s, which converts the value using str(x) and is the default. The format specifier, after a colon, specifies field width, alignment, padding, and numeric precision. Currently it must be empty, but it is reserved for future use. &quot;a {} c&quot;.format(3) == &quot;a 3 c&quot; &quot;a{x}b{y}c{}&quot;.format(1, x=2, y=3) == &quot;a2b3c1&quot; &quot;a{}b{}c&quot;.format(1, 2) == &quot;a1b2c&quot; &quot;({1}, {0})&quot;.format(&quot;zero&quot;, &quot;one&quot;) == &quot;(one, zero)&quot; &quot;Is {0!r} {0!s}?&quot;.format(&quot;heterological&quot;) == &quot;Is \\&quot;heterological\\&quot; heterological?&quot;   "},{"title":"string.index​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringindex","content":"def string.index( needle: str, start: None | int = None, end: None | int = None, / ) -&gt; int  string.index: search a substring inside a string, failing on not found. S.index(sub[, start[, end]]) returns the index of the first occurrence of the substring sub within S, like S.find, except that if the substring is not found, the operation fails. &quot;bonbon&quot;.index(&quot;on&quot;) == 1 &quot;bonbon&quot;.index(&quot;on&quot;, 2) == 4 &quot;bonbon&quot;.index(&quot;on&quot;, 2, 5) # error: not found   "},{"title":"string.isalnum​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringisalnum","content":"def string.isalnum() -&gt; bool  string.isalnum: test if a string is composed only of letters and digits. S.isalnum() reports whether the string S is non-empty and consists only Unicode letters and digits. &quot;base64&quot;.isalnum() == True &quot;Catch-22&quot;.isalnum() == False   "},{"title":"string.isalpha​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringisalpha","content":"def string.isalpha() -&gt; bool  string.isalpha: test if a string is composed only of letters. S.isalpha() reports whether the string S is non-empty and consists only of Unicode letters. &quot;ABC&quot;.isalpha() == True &quot;Catch-22&quot;.isalpha() == False &quot;&quot;.isalpha() == False   "},{"title":"string.isdigit​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringisdigit","content":"def string.isdigit() -&gt; bool  string.isdigit: test if a string is composed only of digits. S.isdigit() reports whether the string S is non-empty and consists only of Unicode digits. &quot;123&quot;.isdigit() == True &quot;Catch-22&quot;.isdigit() == False &quot;&quot;.isdigit() == False   "},{"title":"string.islower​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringislower","content":"def string.islower() -&gt; bool  string.islower: test if all letters of a string are lowercase. S.islower() reports whether the string S contains at least one cased Unicode letter, and all such letters are lowercase. &quot;hello, world&quot;.islower() == True &quot;Catch-22&quot;.islower() == False &quot;123&quot;.islower() == False   "},{"title":"string.isspace​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringisspace","content":"def string.isspace() -&gt; bool  string.isspace: test if all characters of a string are whitespaces. S.isspace() reports whether the string S is non-empty and consists only of Unicode spaces. &quot; &quot;.isspace() == True &quot;\\r\\t\\n&quot;.isspace() == True &quot;&quot;.isspace() == False   "},{"title":"string.istitle​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringistitle","content":"def string.istitle() -&gt; bool  string.istitle: test if the string is title cased. S.istitle() reports whether the string S contains at least one cased Unicode letter, and all such letters that begin a word are in title case. &quot;Hello, World!&quot;.istitle() == True &quot;Catch-22&quot;.istitle() == True &quot;HAL-9000&quot;.istitle() == False &quot;123&quot;.istitle() == False   "},{"title":"string.isupper​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringisupper","content":"def string.isupper() -&gt; bool  string.isupper: test if all letters of a string are uppercase. S.isupper() reports whether the string S contains at least one cased Unicode letter, and all such letters are uppercase. &quot;HAL-9000&quot;.isupper() == True &quot;Catch-22&quot;.isupper() == False &quot;123&quot;.isupper() == False   "},{"title":"string.join​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringjoin","content":"def string.join(to_join: typing.Iterable[str], /) -&gt; str  string.join: join elements with a separator. S.join(iterable) returns the string formed by concatenating each element of its argument, with a copy of the string S between successive elements. The argument must be an iterable whose elements are strings. &quot;, &quot;.join([]) == &quot;&quot; &quot;, &quot;.join((&quot;x&quot;, )) == &quot;x&quot; &quot;, &quot;.join([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]) == &quot;one, two, three&quot; &quot;a&quot;.join(&quot;ctmrn&quot;.elems()) == &quot;catamaran&quot;   "},{"title":"string.lower​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringlower","content":"def string.lower() -&gt; str  string.lower: convert a string to all lowercase. S.lower() returns a copy of the string S with letters converted to lowercase. &quot;Hello, World!&quot;.lower() == &quot;hello, world!&quot;   "},{"title":"string.lstrip​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringlstrip","content":"def string.lstrip(chars: str = _, /) -&gt; str  string.lstrip: trim leading whitespaces. S.lstrip() returns a copy of the string S with leading whitespace removed. In most cases instead of passing an argument you should use removeprefix. &quot; hello &quot;.lstrip() == &quot;hello &quot; &quot;x!hello &quot;.lstrip(&quot;!x &quot;) == &quot;hello &quot;   "},{"title":"string.partition​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringpartition","content":"def string.partition(needle: str, /) -&gt; (str, str, str)  string.partition: partition a string in 3 components S.partition(x = &quot; &quot;) splits string S into three parts and returns them as a tuple: the portion before the first occurrence of string x,x itself, and the portion following it. If S does not contain x, partition returns (S, &quot;&quot;, &quot;&quot;). partition fails if x is not a string, or is the empty string. &quot;one/two/three&quot;.partition(&quot;/&quot;) == (&quot;one&quot;, &quot;/&quot;, &quot;two/three&quot;) &quot;one&quot;.partition(&quot;/&quot;) == (&quot;one&quot;, &quot;&quot;, &quot;&quot;)   "},{"title":"string.removeprefix​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringremoveprefix","content":"def string.removeprefix(prefix: str, /) -&gt; str  string.removeprefix: remove a prefix from a string. Not part of standard Starlark. If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: &quot;Hello, World!&quot;.removeprefix(&quot;Hello&quot;) == &quot;, World!&quot; &quot;Hello, World!&quot;.removeprefix(&quot;Goodbye&quot;) == &quot;Hello, World!&quot; &quot;Hello&quot;.removeprefix(&quot;Hello&quot;) == &quot;&quot;   "},{"title":"string.removesuffix​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringremovesuffix","content":"def string.removesuffix(suffix: str, /) -&gt; str  string.removesuffix: remove a prefix from a string. Not part of standard Starlark. If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: &quot;Hello, World!&quot;.removesuffix(&quot;World!&quot;) == &quot;Hello, &quot; &quot;Hello, World!&quot;.removesuffix(&quot;World&quot;) == &quot;Hello, World!&quot; &quot;Hello&quot;.removesuffix(&quot;Hello&quot;) == &quot;&quot;   "},{"title":"string.replace​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringreplace","content":"def string.replace( old: str, new: str, count: int = _, / ) -&gt; str  string.replace: replace all occurrences of a substring. S.replace(old, new[, count]) returns a copy of string S with all occurrences of substring old replaced by new. If the optional argument count, which must be an int, is non-negative, it specifies a maximum number of occurrences to replace. &quot;banana&quot;.replace(&quot;a&quot;, &quot;o&quot;) == &quot;bonono&quot; &quot;banana&quot;.replace(&quot;a&quot;, &quot;o&quot;, 2) == &quot;bonona&quot; &quot;banana&quot;.replace(&quot;z&quot;, &quot;x&quot;) == &quot;banana&quot; &quot;banana&quot;.replace(&quot;&quot;, &quot;x&quot;) == &quot;xbxaxnxaxnxax&quot; &quot;banana&quot;.replace(&quot;&quot;, &quot;x&quot;, 2) == &quot;xbxanana&quot; &quot;&quot;.replace(&quot;&quot;, &quot;x&quot;) == &quot;x&quot; &quot;banana&quot;.replace(&quot;a&quot;, &quot;o&quot;, -2) # error: argument was negative   "},{"title":"string.rfind​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringrfind","content":"def string.rfind( needle: str, start: None | int = None, end: None | int = None, / ) -&gt; int  string.rfind: find the last index of a substring. S.rfind(sub[, start[, end]]) returns the index of the substring subwithin S, like S.find, except that rfind returns the index of the substring's last occurrence. &quot;bonbon&quot;.rfind(&quot;on&quot;) == 4 &quot;bonbon&quot;.rfind(&quot;on&quot;, None, 5) == 1 &quot;bonbon&quot;.rfind(&quot;on&quot;, 2, 5) == -1   "},{"title":"string.rindex​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringrindex","content":"def string.rindex( needle: str, start: None | int = None, end: None | int = None, / ) -&gt; int  string.rindex: find the last index of a substring, failing on not found. S.rindex(sub[, start[, end]]) returns the index of the substring subwithin S, like S.index, except that rindex returns the index of the substring's last occurrence. &quot;bonbon&quot;.rindex(&quot;on&quot;) == 4 &quot;bonbon&quot;.rindex(&quot;on&quot;, None, 5) == 1 # in &quot;bonbo&quot; &quot;bonbon&quot;.rindex(&quot;on&quot;, 2, 5) # error: not found   "},{"title":"string.rpartition​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringrpartition","content":"def string.rpartition(needle: str, /) -&gt; (str, str, str)  string.rpartition: partition a string in 3 elements. S.rpartition([x = ' ']) is like partition, but splits S at the last occurrence of x. &quot;one/two/three&quot;.rpartition(&quot;/&quot;) == (&quot;one/two&quot;, &quot;/&quot;, &quot;three&quot;) &quot;one&quot;.rpartition(&quot;/&quot;) == (&quot;&quot;, &quot;&quot;, &quot;one&quot;)   "},{"title":"string.rsplit​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringrsplit","content":"def string.rsplit( sep: None | str = None, maxsplit: None | int = None, / ) -&gt; list[str]  string.rsplit: splits a string into substrings. S.rsplit([sep[, maxsplit]]) splits a string into substrings likeS.split, except that when a maximum number of splits is specified,rsplit chooses the rightmost splits. &quot;banana&quot;.rsplit(&quot;n&quot;) == [&quot;ba&quot;, &quot;a&quot;, &quot;a&quot;] &quot;banana&quot;.rsplit(&quot;n&quot;, 1) == [&quot;bana&quot;, &quot;a&quot;] &quot;one two three&quot;.rsplit(None, 1) == [&quot;one two&quot;, &quot;three&quot;]   "},{"title":"string.rstrip​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringrstrip","content":"def string.rstrip(chars: str = _, /) -&gt; str  string.rstrip: trim trailing whitespace. S.rstrip() returns a copy of the string S with trailing whitespace removed. In most cases instead of passing an argument you should use removesuffix. &quot; hello &quot;.rstrip() == &quot; hello&quot; &quot; hello!x&quot;.rstrip(&quot; x!&quot;) == &quot; hello&quot;   "},{"title":"string.split​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringsplit","content":"def string.split( sep: None | str = None, maxsplit: None | int = None, / ) -&gt; list[str]  string.split: split a string in substrings. S.split([sep [, maxsplit]]) returns the list of substrings of S, splitting at occurrences of the delimiter string sep. Consecutive occurrences of sep are considered to delimit empty strings, so 'food'.split('o') returns ['f', '', 'd']. Splitting an empty string with a specified separator returns ['']. If sep is the empty string, split fails. If sep is not specified or is None, split uses a different algorithm: it removes all leading spaces from S (or trailing spaces in the case of rsplit), then splits the string around each consecutive non-empty sequence of Unicode white space characters. If S consists only of white space, split returns the empty list. If maxsplit is given and non-negative, it specifies a maximum number of splits. &quot;one two three&quot;.split() == [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] &quot;one two three&quot;.split(&quot; &quot;) == [&quot;one&quot;, &quot;two&quot;, &quot;&quot;, &quot;three&quot;] &quot;one two three&quot;.split(None, 1) == [&quot;one&quot;, &quot;two three&quot;] &quot;banana&quot;.split(&quot;n&quot;) == [&quot;ba&quot;, &quot;a&quot;, &quot;a&quot;] &quot;banana&quot;.split(&quot;n&quot;, 1) == [&quot;ba&quot;, &quot;ana&quot;]   "},{"title":"string.splitlines​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringsplitlines","content":"def string.splitlines(keepends: bool = False, /) -&gt; list[str]  string.splitlines: return the list of lines of a string. S.splitlines([keepends]) returns a list whose elements are the successive lines of S, that is, the strings formed by splitting S at line terminators ('\\n', '\\r' or '\\r\\n'). The optional argument, keepends, is interpreted as a Boolean. If true, line terminators are preserved in the result, though the final element does not necessarily end with a line terminator. &quot;one\\n\\ntwo&quot;.splitlines() == [&quot;one&quot;, &quot;&quot;, &quot;two&quot;] &quot;one\\n\\ntwo&quot;.splitlines(True) == [&quot;one\\n&quot;, &quot;\\n&quot;, &quot;two&quot;] &quot;a\\nb&quot;.splitlines() == [&quot;a&quot;, &quot;b&quot;]   "},{"title":"string.startswith​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringstartswith","content":"def string.startswith(prefix: str | tuple[str, ...], /) -&gt; bool  string.startswith: test whether a string starts with a given prefix. S.startswith(suffix) reports whether the string S has the specified prefix. &quot;filename.sky&quot;.startswith(&quot;filename&quot;) == True &quot;filename.sky&quot;.startswith(&quot;sky&quot;) == False 'abc'.startswith(('a', 'A')) == True 'ABC'.startswith(('a', 'A')) == True 'def'.startswith(('a', 'A')) == False   "},{"title":"string.strip​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringstrip","content":"def string.strip(chars: str = _, /) -&gt; str  string.strip: trim leading and trailing whitespaces. S.strip() returns a copy of the string S with leading and trailing whitespace removed. &quot; hello &quot;.strip() == &quot;hello&quot; &quot;xxhello!!&quot;.strip(&quot;x!&quot;) == &quot;hello&quot;   "},{"title":"string.title​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringtitle","content":"def string.title() -&gt; str  string.title: convert a string to title case. S.title() returns a copy of the string S with letters converted to titlecase. Letters are converted to uppercase at the start of words, lowercase elsewhere. &quot;hElLo, WoRlD!&quot;.title() == &quot;Hello, World!&quot;   "},{"title":"string.upper​","type":1,"pageTitle":"string type","url":"/docs/api/starlark/string/#stringupper","content":"def string.upper() -&gt; str  string.upper: convert a string to all uppercase. S.upper() returns a copy of the string S with letters converted to uppercase. &quot;Hello, World!&quot;.upper() == &quot;HELLO, WORLD!&quot;  "},{"title":"Concept Map","type":0,"sectionRef":"#","url":"/docs/concepts/concept_map/","content":"Concept Map The Concept Map provides an at-a-glance overview of the relationships between widely used Buck2 concepts. It is meant to be a tool to help those onboarding to Buck2 to quickly gain an understanding of the Buck2 environment. note The Concept Map is for reference only and is not intended to be 100% accurate nor complete.","keywords":""},{"title":"globals","type":0,"sectionRef":"#","url":"/docs/api/bxl/globals/","content":"","keywords":""},{"title":"ActionErrorCtx​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#actionerrorctx","content":"ActionErrorCtx: type   "},{"title":"ActionErrorLocation​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#actionerrorlocation","content":"ActionErrorLocation: type   "},{"title":"ActionSubError​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#actionsuberror","content":"ActionSubError: type   "},{"title":"AnalysisActions​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#analysisactions","content":"AnalysisActions: type   "},{"title":"AnalysisContext​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#analysiscontext","content":"AnalysisContext: type   "},{"title":"AnonTarget​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#anontarget","content":"AnonTarget: type   "},{"title":"AnonTargets​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#anontargets","content":"AnonTargets: type   "},{"title":"Artifact​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#artifact","content":"Artifact: type   "},{"title":"ArtifactTag​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#artifacttag","content":"ArtifactTag: type   "},{"title":"ArtifactValue​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#artifactvalue","content":"ArtifactValue: type   "},{"title":"Attr​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#attr","content":"Attr: type   "},{"title":"CellPath​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#cellpath","content":"CellPath: type   "},{"title":"CellRoot​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#cellroot","content":"CellRoot: type   "},{"title":"CommandExecutorConfig​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#commandexecutorconfig","content":"def CommandExecutorConfig( *, local_enabled: bool, remote_enabled: bool, remote_cache_enabled: None | bool = None, remote_dep_file_cache_enabled: bool = False, remote_execution_properties = None, remote_execution_action_key = None, remote_execution_max_input_files_mebibytes: None | int = None, remote_execution_queue_time_threshold_s: None | int = None, remote_execution_use_case = None, use_limited_hybrid: bool = False, allow_limited_hybrid_fallbacks: bool = False, allow_hybrid_fallbacks_on_failure: bool = False, use_windows_path_separators: bool = False, use_persistent_workers: bool = False, allow_cache_uploads: bool = False, max_cache_upload_mebibytes: None | int = None, experimental_low_pass_filter: bool = False, remote_output_paths: None | str = None, remote_execution_resource_units: None | int = None, remote_execution_dependencies: list[dict[str, str]] = [] ) -&gt; command_executor_config  Contains configurations for how actions should be executed .type attribute​ Produces &quot;command_executor_config&quot; Details​ local_enabled : Whether to use local execution for this execution platform. If both remote_enabled and local_enabled are True, we will use the hybrid executorremote_enabled: Whether to use remote execution for this execution platformremote_cache_enabled: Whether to query RE cachesremote_execution_properties: Properties for remote execution for this platformremote_execution_action_key: A component to inject into the action key This should typically used to inject variability into the action key so that it's different across e.g. build modes (RE uses the action key for things like expected memory utilization)remote_execution_max_input_files_mebibytes: The maximum input file size (in bytes) that remote execution can supportremote_execution_queue_time_threshold_s: The maximum time in seconds we are willing to wait in the RE queue for remote execution to start running our actionremote_execution_use_case: The use case to use when communicating with REuse_limited_hybrid: Whether to use the limited hybrid executorallow_limited_hybrid_fallbacks: Whether to allow fallbacksallow_hybrid_fallbacks_on_failure: Whether to allow fallbacks when the result is failure (i.e. the command failed on the primary, but the infra worked)use_windows_path_separators: Whether to use Windows path separators in command line argumentsuse_persistent workers: Whether to use persistent workers for local execution if they are availableallow_cache_uploads: Whether to upload local actions to the RE cachemax_cache_upload_mebibytes: Maximum size to upload in cache uploadsexperimental_low_pass_filter: Whether to use the experimental low pass filterremote_output_paths: How to express output paths to REremote_execution_resource_units: The resources (eg. GPUs) to use for remote executionremote_execution_dependencies: Dependencies for remote execution for this platform  "},{"title":"ConfigurationInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#configurationinfo","content":"def ConfigurationInfo( *, constraints: dict[target_label, ConstraintValueInfo], values: dict[str, str] ) -&gt; ConfigurationInfo  Provider that signals that a rule contains configuration info. This is used both as part of defining configurations (platform(), constraint_value()) and defining whether a target &quot;matches&quot; a configuration or not (config_setting(), constraint_value()) .type attribute​ Produces &quot;ConfigurationInfo&quot; Details​ Provides a number of fields that can be accessed: constraints: dict[target_label, ConstraintValueInfo] - field values: dict[str, str] - field  "},{"title":"ConfiguredProvidersLabel​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#configuredproviderslabel","content":"ConfiguredProvidersLabel: type   "},{"title":"ConfiguredTargetLabel​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#configuredtargetlabel","content":"ConfiguredTargetLabel: type   "},{"title":"ConstraintSettingInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#constraintsettinginfo","content":"def ConstraintSettingInfo(*, label: target_label) -&gt; ConstraintSettingInfo  Provider that signals that a target can be used as a constraint key. This is the only provider returned by a constraint_setting() target. .type attribute​ Produces &quot;ConstraintSettingInfo&quot; Details​ Provides a number of fields that can be accessed: label: target_label - field  "},{"title":"ConstraintValueInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#constraintvalueinfo","content":"def ConstraintValueInfo( *, setting: ConstraintSettingInfo, label: target_label ) -&gt; ConstraintValueInfo  Provider that signals that a target can be used as a constraint key. This is the only provider returned by a constraint_value() target. .type attribute​ Produces &quot;ConstraintValueInfo&quot; Details​ Provides a number of fields that can be accessed: setting: ConstraintSettingInfo - field label: target_label - field  "},{"title":"DefaultInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#defaultinfo","content":"def DefaultInfo( default_output: None | artifact = None, default_outputs: None | list[artifact] = None, other_outputs: list[artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | RunInfo] = _, sub_targets: dict[str, typing.Any] = _ ) -&gt; DefaultInfo  A provider that all rules' implementations must return .type attribute​ Produces &quot;DefaultInfo&quot; Details​ In many simple cases, this can be inferred for the user. Example of a rule's implementation function and how these fields are used by the framework: # //foo_binary.bzl def impl(ctx): ctx.action.run([ctx.attrs._cc[RunInfo], &quot;-o&quot;, ctx.attrs.out.as_output()] + ctx.attrs.srcs) ctx.action.run([ ctx.attrs._strip[RunInfo], &quot;--binary&quot;, ctx.attrs.out, &quot;--stripped-out&quot;, ctx.attrs.stripped.as_output(), &quot;--debug-symbols-out&quot;, ctx.attrs.debug_info.as_output(), ]) return [ DefaultInfo( sub_targets = { &quot;stripped&quot;: [ DefaultInfo(default_outputs = [ctx.attrs.stripped, ctx.attrs.debug_info]), ], }, default_output = ctx.attrs.out, ] foo_binary = rule( impl=impl, attrs={ &quot;srcs&quot;: attrs.list(attrs.source()), &quot;out&quot;: attrs.output(), &quot;stripped&quot;: attrs.output(), &quot;debug_info&quot;: attrs.output(), &quot;_cc&quot;: attrs.dep(default=&quot;//tools:cc&quot;, providers=[RunInfo]), &quot;_strip_script&quot;: attrs.dep(default=&quot;//tools:strip&quot;, providers=[RunInfo]) ) def foo_binary_wrapper(name, srcs): foo_binary( name = name, srcs = src, out = name, stripped = name + &quot;.stripped&quot;, debug_info = name + &quot;.debug_info&quot;, ) # //subdir/BUCK load(&quot;//:foo_binary.bzl&quot;, &quot;foo_binary_wrapper&quot;) genrule(name = &quot;gen_stuff&quot;, ...., default_outs = [&quot;foo.cpp&quot;]) # &quot;:gen_stuff&quot; pulls the default_outputs for //subdir:gen_stuff foo_binary_wrapper(name = &quot;foo&quot;, srcs = glob([&quot;*.cpp&quot;]) + [&quot;:gen_stuff&quot;]) # Builds just 'foo' binary. The strip command is never invoked. $ buck build //subdir:foo # builds the 'foo' binary, because it is needed by the 'strip' command. Ensures that # both the stripped binary and the debug symbols are built. $ buck build //subdir:foo[stripped]  Provides a number of fields that can be accessed: sub_targets: dict[str, provider_collection] - A mapping of names to ProviderCollections. The keys are used when resolving the ProviderName portion of a ProvidersLabel in order to access the providers for a subtarget, such as when doing buck2 build cell//foo:bar[baz]. Just like any ProviderCollection, this collection must include at least a DefaultInfo provider. The subtargets can have their own subtargets as well, which can be accessed by chaining them, e.g.: buck2 build cell//foo:bar[baz][qux]. default_outputs: list[artifact] - A list of Artifacts that are built by default if this rule is requested explicitly (via CLI or $(location) etc), or depended on as as a &quot;source&quot; (i.e., attrs.source()). other_outputs: list[artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | RunInfo] - A list of ArtifactTraversable. The underlying Artifacts they define will be built by default if this rule is requested (via CLI or $(location) etc), but not when it's depended on as as a &quot;source&quot; (i.e., attrs.source()). ArtifactTraversable can be an Artifact (which yields itself), or cmd_args, which expand to all their inputs.  "},{"title":"Dependency​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#dependency","content":"Dependency: type   "},{"title":"DynamicActions​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#dynamicactions","content":"DynamicActions: type   "},{"title":"DynamicActionsCallable​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#dynamicactionscallable","content":"DynamicActionsCallable: type   "},{"title":"DynamicValue​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#dynamicvalue","content":"DynamicValue: type   "},{"title":"ExecutionPlatformInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#executionplatforminfo","content":"def ExecutionPlatformInfo( *, label: target_label, configuration: ConfigurationInfo, executor_config: command_executor_config ) -&gt; ExecutionPlatformInfo  Provider that signals that a target represents an execution platform. Provides a number of fields that can be accessed: label: target_label - label of the defining rule, used in informative messages configuration: ConfigurationInfo - The configuration of the execution platform executor_config: command_executor_config - The executor config  "},{"title":"ExecutionPlatformRegistrationInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#executionplatformregistrationinfo","content":"def ExecutionPlatformRegistrationInfo( *, platforms: list[ExecutionPlatformInfo], fallback = None ) -&gt; ExecutionPlatformRegistrationInfo  Provider that gives the list of all execution platforms available for this build. Provides a number of fields that can be accessed: platforms: list[ExecutionPlatformInfo] - field fallback: typing.Any - field  "},{"title":"ExternalRunnerTestInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#externalrunnertestinfo","content":"def ExternalRunnerTestInfo( type, command = None, env = None, labels = None, contacts = None, use_project_relative_paths = None, run_from_project_root = None, default_executor = None, executor_overrides = None, local_resources = None, worker = None ) -&gt; ExternalRunnerTestInfo  Provider that signals that a rule can be tested using an external runner. This is the Buck1-compatible API for tests. .type attribute​ Produces &quot;ExternalRunnerTestInfo&quot; Details​ Provides a number of fields that can be accessed: test_type: str - A Starlark value representing the type of this test. command: list[typing.Any] - A Starlark value representing the command for this test. The external test runner is what gives meaning to this command. env: dict[str, typing.Any] - A Starlark value representing the environment for this test. Here again, the external test runner is what will this meaning. This is of type dict[str, ArgLike]. labels: list[str] - A starlark value representing the labels for this test. contacts: list[str] - A starlark value representing the contacts for this test. This is largely expected to be an oncall, though it's not validated in any way. use_project_relative_paths: bool - Whether this test should use relative paths run_from_project_root: bool - Whether this test should run from the project root, as opposed to the cell rootDefaults to True. default_executor: command_executor_config - Default executor to use to run tests. If none is passed we will default to the execution platform. executor_overrides: dict[str, command_executor_config] - Executors that Tpx can use to override the default executor. local_resources: dict[str, None | label] - Mapping from a local resource type to a target with a corresponding provider. Required types are passed from test runner. If the value for a corresponding type is omitted it means local resource should be ignored when executing tests even if those are passed as required from test runner. worker: WorkerInfo - Configuration needed to spawn a new worker. This worker will be used to run every single command related to test execution, including listing.  "},{"title":"InstallInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#installinfo","content":"def InstallInfo(installer: label, files: dict[str, artifact]) -&gt; InstallInfo  A provider that can be constructed and have its fields accessed. Returned by rules. Provides a number of fields that can be accessed: installer: label - field files: dict[str, artifact] - field  "},{"title":"Label​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#label","content":"Label: type   "},{"title":"LocalResourceInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#localresourceinfo","content":"def LocalResourceInfo( *, setup: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo, resource_env_vars: dict[str, str], setup_timeout_seconds: None | float | int = None ) -&gt; LocalResourceInfo  A provider that can be constructed and have its fields accessed. Returned by rules. .type attribute​ Produces &quot;LocalResourceInfo&quot; Details​ Provides a number of fields that can be accessed: setup: cmd_args - Command to run to initialize a local resource. Running this command writes a JSON to stdout. This JSON represents a pool of local resources which are ready to be used. Example JSON would be: { &quot;pid&quot;: 42, &quot;resources&quot;: [ {&quot;socket_address&quot;: &quot;foo:1&quot;}, {&quot;socket_address&quot;: &quot;bar:2&quot;} ] } Where '&quot;pid&quot;maps to a PID of a process which should be sent SIGTERM to release the pool of resources when they are no longer needed.&quot;resources&quot;maps to the pool of resources. When a local resource from this particular pool is needed for an execution command, single entity will be reserved from the pool, for example{&quot;socket_address&quot;: &quot;bar:2&quot;}and environment variable with name resolved using mapping inresource_env_varsfield and&quot;socket_address&quot;` key will be added to execution command. resource_env_vars: dict[str, str] - Mapping from environment variable (appended to an execution command which is dependent on this local resource) to keys in setup command JSON output. setup_timeout_seconds: None | float | int - Timeout in seconds for setup command.  "},{"title":"OutputArtifact​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#outputartifact","content":"OutputArtifact: type   "},{"title":"PlatformInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#platforminfo","content":"def PlatformInfo( *, label: str, configuration: ConfigurationInfo ) -&gt; PlatformInfo  A provider that can be constructed and have its fields accessed. Returned by rules. .type attribute​ Produces &quot;PlatformInfo&quot; Details​ Provides a number of fields that can be accessed: label: str - field configuration: ConfigurationInfo - field  "},{"title":"ProjectRoot​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#projectroot","content":"ProjectRoot: type   "},{"title":"Promise​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#promise","content":"Promise: type   "},{"title":"Provider​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#provider","content":"Provider: type   "},{"title":"ProviderCollection​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#providercollection","content":"ProviderCollection: type   "},{"title":"ProvidersLabel​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#providerslabel","content":"ProvidersLabel: type   "},{"title":"ResolvedDynamicValue​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#resolveddynamicvalue","content":"ResolvedDynamicValue: type   "},{"title":"ResolvedStringWithMacros​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#resolvedstringwithmacros","content":"ResolvedStringWithMacros: type   "},{"title":"RunInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#runinfo","content":"def RunInfo( args: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo = _ ) -&gt; RunInfo  Provider that signals that a rule is runnable .type attribute​ Produces &quot;RunInfo&quot; Details​ Provides a number of fields that can be accessed: args: cmd_args - The command to run, stored as CommandLine  "},{"title":"Select​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#select","content":"Select: type   "},{"title":"TargetLabel​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#targetlabel","content":"TargetLabel: type   "},{"title":"TemplatePlaceholderInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#templateplaceholderinfo","content":"def TemplatePlaceholderInfo( unkeyed_variables = {}, keyed_variables = {} ) -&gt; TemplatePlaceholderInfo  A provider that is used for expansions in string attribute templates .type attribute​ Produces &quot;TemplatePlaceholderInfo&quot; Details​ String attribute templates allow two types of user-defined placeholders, &quot;unkeyed placeholders&quot; like $(CXX) or $(aapt) and &quot;keyed placeholders&quot; that include a target key like$(cxxppflags //some:target). The expansion of each of these types is based on theTemplatePlaceholderInfo providers. &quot;keyed placeholders&quot; are used for the form $(&lt;key&gt; &lt;target&gt;) or $(&lt;key&gt; &lt;target&gt; &lt;arg&gt;). In both cases the lookup will expect a TemplatePlaceholderInfo in the providers of &lt;target&gt;. It will then lookup&lt;key&gt; in the keyed_variables (call this the value). There are then four valid possibilities: no-arg placeholder, an arg-like value: resolve to valueno-arg placeholder, a dictionary value: resolve to value[&quot;DEFAULT&quot;]arg placeholder, a non-dictionary value: this is an errorarg placeholder, a dictionary value: resolve to value[&lt;arg&gt;] &quot;unkeyed placeholders&quot; are resolved by matching to any of the deps of the target. $(CXX) will resolve to the &quot;CXX&quot; value in any dep's TemplateProviderInfo.unkeyed_variables Fields: unkeyed_variables: A mapping of names to arg-like values. These are used for &quot;unkeyed placeholder&quot; expansion.keyed_variables: A mapping of names to arg-like values or dictionary of string to arg-like values. These are used for &quot;keyed placeholder&quot; expansion. Provides a number of fields that can be accessed: unkeyed_variables: dict[str, typing.Any] - field keyed_variables: dict[str, typing.Any] - field  "},{"title":"TransitiveSet​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#transitiveset","content":"TransitiveSet: type   "},{"title":"TransitiveSetArgsProjection​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#transitivesetargsprojection","content":"TransitiveSetArgsProjection: type   "},{"title":"TransitiveSetArgsProjectionIterator​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#transitivesetargsprojectioniterator","content":"TransitiveSetArgsProjectionIterator: type   "},{"title":"TransitiveSetDefinition​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#transitivesetdefinition","content":"TransitiveSetDefinition: type   "},{"title":"TransitiveSetIterator​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#transitivesetiterator","content":"TransitiveSetIterator: type   "},{"title":"TransitiveSetJsonProjection​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#transitivesetjsonprojection","content":"TransitiveSetJsonProjection: type   "},{"title":"ValidationInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#validationinfo","content":"def ValidationInfo(*, validations: list[ValidationSpec]) -&gt; ValidationInfo  Provider describing how a given target node should be validated. Validations are run when target with ValidationInfo provider is a transitive dependency of a requested target. .type attribute​ Produces &quot;ValidationInfo&quot; Details​ Provides a number of fields that can be accessed: validations: list[ValidationSpec] - List of ValidationSpec values each representing a single validation.  "},{"title":"ValidationSpec​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#validationspec","content":"def ValidationSpec( *, name: str, validation_result: artifact, optional: bool = False ) -&gt; ValidationSpec  .type attribute​ Produces &quot;ValidationSpec&quot;  "},{"title":"WorkerInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#workerinfo","content":"def WorkerInfo(exe = [], *, concurrency: None | int = None) -&gt; WorkerInfo  Provider that signals that a rule is a worker tool .type attribute​ Produces &quot;WorkerInfo&quot; Details​ Provides a number of fields that can be accessed: exe: cmd_args - field concurrency: None | int - field  "},{"title":"WorkerRunInfo​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#workerruninfo","content":"def WorkerRunInfo(*, worker: WorkerInfo, exe = []) -&gt; WorkerRunInfo  Provider that signals that a rule can run using a worker .type attribute​ Produces &quot;WorkerRunInfo&quot; Details​ Provides a number of fields that can be accessed: worker: WorkerInfo - field exe: cmd_args - field  "},{"title":"anon_rule​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#anon_rule","content":"def anon_rule( *, impl: typing.Callable[[typing.Any], list[typing.Any]], attrs: dict[str, attribute], doc: str = &quot;&quot;, artifact_promise_mappings: dict[str, typing.Callable[[typing.Any], list[typing.Any]]] ) -&gt; &quot;function&quot;  Define an anon rule, similar to how a normal rule is defined, except with an extra artifact_promise_mappings field. This is a dict where the keys are the string name of the artifact, and the values are the callable functions that produce the artifact. This is only intended to be used with anon targets.  "},{"title":"attrs​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#attrs","content":"attrs: attrs   "},{"title":"bxl​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#bxl","content":"bxl: struct(ActionQueryNode = type, Actions = type, AnalysisResult = type, AqueryContext = type, AuditContext = type, BuildResult = type, CliArgs = type, ConfiguredTargetNode = type, ConfiguredTargetSet = type, Context = type, CqueryContext = type, EnsuredArtifact = type, FileNode = type, Filesystem = type, LazyResolvedAttrs = type, OutputStream = type, TargetUniverse = type, UnconfiguredTargetNode = type, UnconfiguredTargetSet = type, UqueryContext = type, cli_args = struct(bool = &quot;function&quot;, enum = &quot;function&quot;, float = &quot;function&quot;, int = &quot;function&quot;, json = &quot;function&quot;, list = &quot;function&quot;, option = &quot;function&quot;, string = &quot;function&quot;, sub_target = &quot;function&quot;, sub_target_expr = &quot;function&quot;, target_expr = &quot;function&quot;, target_label = &quot;function&quot;), ctarget_set = &quot;function&quot;, fail_no_stacktrace = &quot;function&quot;, file_set = &quot;function&quot;, get_path_without_materialization = &quot;function&quot;, get_paths_without_materialization = &quot;function&quot;, now = &quot;function&quot;, utarget_set = &quot;function&quot;)   "},{"title":"bxl_main​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#bxl_main","content":"def bxl_main( *, impl: typing.Callable, cli_args: dict[str, bxl.CliArgs], doc: str = &quot;&quot; )   "},{"title":"cli_args​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#cli_args","content":"cli_args: struct(bool = &quot;function&quot;, enum = &quot;function&quot;, float = &quot;function&quot;, int = &quot;function&quot;, json = &quot;function&quot;, list = &quot;function&quot;, option = &quot;function&quot;, string = &quot;function&quot;, sub_target = &quot;function&quot;, sub_target_expr = &quot;function&quot;, target_expr = &quot;function&quot;, target_label = &quot;function&quot;)   "},{"title":"cmd_args​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#cmd_args","content":"def cmd_args( *args: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo, hidden: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | list[typing.Any] | RunInfo = _, delimiter: str = _, format: str = _, prepend: str = _, quote: str = _, ignore_artifacts: bool = False, absolute_prefix: str = _, absolute_suffix: str = _, parent: int = 0, relative_to: artifact | cell_root | project_root | (artifact | cell_root | project_root, int) = _, replace_regex: list[(buck_regex | str, str)] | (buck_regex | str, str) = _ ) -&gt; cmd_args  The cmd_args type is created by this function and is consumed by ctx.actions.run. The type is a mutable collection of strings and artifact values. In general, command lines, artifacts, strings, RunInfo and lists thereof can be added to or used to construct a cmd_args value. .type attribute​ Produces &quot;cmd_args&quot; Details​ The arguments are: *args - a list of things to add to the command line, each of which must be coercible to a command line. Further items can be added with cmd.add.format - a string that provides a format to apply to the argument. for example, cmd_args(x, format=&quot;--args={}&quot;) would prepend --args= before x, or if x was a list, before each element in x.delimiter - added between arguments to join them together. For example, cmd_args([&quot;--args=&quot;,x], delimiter=&quot;&quot;) would produce a single argument to the underlying tool.prepend - added as a separate argument before each argument.quote - indicates whether quoting is to be applied to each argument. The only current valid value is &quot;shell&quot;.ignore_artifacts - if True, artifacts paths are used, but artifacts are not pulled.hidden - artifacts not present on the command line, but added as dependencies.absolute_prefix and absolute_suffix - added to the start and end of each artifact.parent - for all the artifacts use their parentth directory (e.g. parent = 1 for the directory the artifact is located, parent = 2 for that directory's parent, etc.).relative_to - make all artifact paths relative to a given location.replace_regex - replaces arguments with a regular expression. "},{"title":"ignore_artifacts​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#ignore_artifacts","content":"ignore_artifacts=True makes cmd_args to have no declared dependencies. Allows you to reference the path of an artifact without introducing dependencies on it. As an example where this can be useful, consider passing a dependency that is only accessed at runtime, but whose path must be baked into the binary. As an example: resources = cmd_args(resource_file, format = &quot;-DFOO={}&quot;).ignore_artifacts() ctx.actions.run(cmd_args(&quot;gcc&quot;, &quot;-c&quot;, source_file, resources))  Note that ignore_artifacts sets all artifacts referenced by this cmd_args to be ignored, including those added afterwards, so generally create a special cmd_args and scope it quite tightly. If you actually do use the inputs referenced by this command, you will either error out due to missing dependencies (if running actions remotely) or have untracked dependencies that will fail to rebuild when it should. "},{"title":"hidden​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#hidden","content":"Things to add to the command line which do not show up but are added as dependencies. The values can be anything normally permissible to pass to add. Typically used if the command you are running implicitly depends on files that are not passed on the command line, e.g. headers in the case of a C compilation. "},{"title":"absolute_prefix and absolute_suffix​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#absolute_prefix-and-absolute_suffix","content":"Adds a prefix to the start or end of every artifact. Prefix is often used if you have a $ROOT variable in a shell script and want to use it to make files absolute. Suffix is often used in conjunction with absolute_prefixto wrap artifacts in function calls. cmd_args(script, absolute_prefix = &quot;$ROOT/&quot;) cmd_args(script, absolute_prefix = &quot;call&quot;, absolute_suffix = &quot;)&quot;)  `parent ` For all the artifacts use their parent directory. Typically used when the file name is passed one way, and the directory another, e.g. cmd_args(artifact, format=&quot;-L{}&quot;, parent=1). relative_to=dir or relative_to=(dir, parent) Make all artifact paths relative to a given location. Typically used when the command you are running changes directory. By default, the paths are relative to the artifacts themselves (equivalent to parent equals to 0). Use parent to make the paths relative to an ancestor directory. For example parent equals to 1 would make all paths relative to the containing dirs of any artifacts in the cmd_args. dir = symlinked_dir(...) script = [ cmd_args(dir, format = &quot;cd {}&quot;, relative_to=dir), ]  replace_regex Replaces all parts matching pattern regular expression (or regular expressions) in each argument with replacement strings.  "},{"title":"ctarget_set​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#ctarget_set","content":"def ctarget_set(nodes: list[bxl.ConfiguredTargetNode] = _) -&gt; target_set  Creates a target set from a list of configured nodes. Sample usage: def _impl_ctarget_set(ctx): targets = bxl.ctarget_set([cnode_a, cnode_b]) ctx.output.print(type(targets)) ctx.output.print(len(targets))   "},{"title":"dedupe​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#dedupe","content":"def dedupe(val, /)  Remove duplicates in a list. Uses identity of value (pointer), rather than by equality. In many cases you should use a transitive set instead.  "},{"title":"dynamic_actions​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#dynamic_actions","content":"def dynamic_actions( *, impl: typing.Callable[&quot;actions: actions, artifacts: dict[artifact, artifact_value], dynamic_values: dict[typing.Any, typing.Any], outputs: dict[artifact, artifact], arg: typing.Any&quot;, list[typing.Any]] ) -&gt; DynamicActionCallable  Create new dynamic action callable. Returned object will be callable, and the result of calling it can be passed to ctx.actions.dynamic_output_new.  "},{"title":"fail_no_stacktrace​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#fail_no_stacktrace","content":"def fail_no_stacktrace(*args) -&gt; None   "},{"title":"file_set​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#file_set","content":"def file_set() -&gt; file_set  Creates an empty file set for configured nodes. Sample usage: def _impl_file_set(ctx): files = file_set() ctx.output.print(type(files)) ctx.output.print(len(files))   "},{"title":"get_base_path​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#get_base_path","content":"def get_base_path() -&gt; str  get_base_path() can only be called in buildfiles (e.g. BUCK files) or PACKAGE files, and returns the name of the package. E.g. inside foo//bar/baz/BUCK the output will be bar/baz. E.g. inside foo//bar/PACKAGE the output will be bar. This function is identical to package_name.  "},{"title":"get_cell_name​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#get_cell_name","content":"def get_cell_name() -&gt; str  get_cell_name() can be called from either a BUCK file or a .bzl file, and returns the name of the cell where the BUCK file that started the call lives. For example, inside foo//bar/baz/BUCK the output will be foo. If that BUCK file does a load(&quot;hello//world.bzl&quot;, &quot;something&quot;) then the result in that .bzl file will also be foo.  "},{"title":"get_path_without_materialization​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#get_path_without_materialization","content":"def get_path_without_materialization( this: artifact, ctx: bxl.Context, /, *, abs: bool = False ) -&gt; str  The output path of an artifact-like (source, build, declared). Takes an optional boolean to print the absolute or relative path. Note that this method returns an artifact path without asking for the artifact to be materialized (i.e. it may not actually exist on the disk yet). This is a risky function to call because you may accidentally pass this path to further BXL actions that expect the artifact to be materialized. If this happens, the BXL script will error out. If you want the path without materialization for other uses that don’t involve passing them into further actions, then it’s safe. Sample usage: def _impl_get_path_without_materialization(ctx): owner = ctx.cquery().owner(&quot;cell//path/to/file&quot;)[0] artifact = owner.get_source(&quot;cell//path/to/file&quot;, ctx) source_artifact_project_rel_path = get_path_without_materialization(artifact, ctx) ctx.output.print(source_artifact_project_rel_path) # Note this artifact is NOT ensured or materialized   "},{"title":"get_paths_without_materialization​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#get_paths_without_materialization","content":"def get_paths_without_materialization( cmd_line: artifact | cell_root | cmd_args | label | label_relative_path | output_artifact | project_root | resolved_macro | str | tagged_command_line | target_label | transitive_set_args_projection | write_json_cli_args | RunInfo, ctx: bxl.Context, /, *, abs: bool = False )  The output paths of a cmd_args() inputs. The output paths will be returned as a list. Takes an optional boolean to print the absolute or relative path. Note that this method returns an artifact path without asking for the artifact to be materialized, (i.e. it may not actually exist on the disk yet). This is a risky function to call because you may accidentally pass this path to further BXL actions that expect the artifact to be materialized. If this happens, the BXL script will error out. If you want the path without materialization for other uses that don’t involve passing them into further actions, then it’s safe. Sample usage: def _impl_get_paths_without_materialization(ctx): node = ctx.configured_targets(&quot;root//bin:the_binary&quot;) providers = ctx.analysis(node).providers() path = get_paths_without_materialization(providers[RunInfo], abs=True) # Note this artifact is NOT ensured or materialized ctx.output.print(path)   "},{"title":"glob​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#glob","content":"def glob( include: list[str] | tuple[str, ...], *, exclude: list[str] | tuple[str, ...] = [] ) -&gt; list[str]  The glob() function specifies a set of files using patterns. Only available from BUCK files. A typical glob call looks like: glob([&quot;foo/**/*.h&quot;])  This call will match all header files in the foo directory, recursively. You can also pass a named exclude parameter to remove files matching a pattern: glob([&quot;foo/**/*.h&quot;], exclude = [&quot;**/config.h&quot;])  This call will remove all config.h files from the initial match. The glob() call is evaluated against the list of files owned by this BUCK file. A file is owned by whichever BUCK file is closest above it - so given foo/BUCK andfoo/bar/BUCK the file foo/file.txt would be owned by foo/BUCK (and available from its glob results) but the file foo/bar/file.txt would be owned by foo/bar/BUCkand not appear in the glob result of foo/BUCK, even if you write glob([&quot;bar/file.txt&quot;]). As a consequence of this rule, glob([&quot;../foo.txt&quot;]) will always return an empty list of files. Currently glob is evaluated case-insensitively on all file systems, but we expect that to change to case sensitive in the near future.  "},{"title":"host_info​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#host_info","content":"def host_info() -&gt; struct(..)  The host_info() function is used to get the current OS and processor architecture on the host. The structure returned is laid out thusly: struct( os=struct( is_linux=True|False, is_macos=True|False, is_windows=True|False, is_freebsd=True|False, is_unknown=True|False, ), arch=struct( is_aarch64=True|False, is_arm=True|False, is_armeb=True|False, is_i386=True|False, is_mips=True|False, is_mips64=True|False, is_mipsel=True|False, is_mipsel64=True|False, is_powerpc=True|False, is_ppc64=True|False, is_x86_64=True|False, is_unknown=True|False, ), )   "},{"title":"implicit_package_symbol​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#implicit_package_symbol","content":"def implicit_package_symbol(name: str, default = _)   "},{"title":"load_symbols​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#load_symbols","content":"def load_symbols(symbols: dict[str, typing.Any]) -&gt; None  Used in a .bzl file to set exported symbols. In most cases just defining the symbol as a top-level binding is sufficient, but sometimes the names might be programatically generated. It is undefined behaviour if you try and use any of the symbols exported here later in the same module, or if they overlap with existing definitions. This function should be used rarely.  "},{"title":"now​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#now","content":"def now() -&gt; instant  Creates an Instant at the current time. Sample usage: def _impl_elapsed_millis(ctx): instant = now() time_a = instant.elapsed_millis() # do something that takes a long time time_b = instant.elapsed_millis() ctx.output.print(time_a) ctx.output.print(time_b)  This function is only accessible through Bxl.  "},{"title":"oncall​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#oncall","content":"def oncall(name: str, /) -&gt; None  Called in a BUCK file to declare the oncall contact details for all the targets defined. Must be called at most once, before any targets have been declared. Errors if called from a .bzl file.  "},{"title":"package​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#package","content":"def package( *, inherit: bool = False, visibility: list[str] | tuple[str, ...] = [], within_view: list[str] | tuple[str, ...] = [] ) -&gt; None   "},{"title":"package_name​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#package_name","content":"def package_name() -&gt; str  package_name() can only be called in buildfiles (e.g. BUCK files) or PACKAGE files, and returns the name of the package. E.g. inside foo//bar/baz/BUCK the output will be bar/baz. E.g. inside foo//bar/PACKAGE the output will be bar.  "},{"title":"plugins​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#plugins","content":"plugins: plugins   "},{"title":"provider​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#provider-1","content":"def provider( *, doc: str = &quot;&quot;, fields: list[str] | tuple[str, ...] | dict[str, typing.Any] ) -&gt; provider_callable  Create a &quot;provider&quot; type that can be returned from rule implementations. Used to pass information from a rule to the things that depend on it. Typically named with an Info suffix. GroovyLibraryInfo(fields = [ &quot;objects&quot;, # a list of artifacts &quot;options&quot;, # a string containing compiler options ])  Given a dependency you can obtain the provider with my_dep[GroovyLibraryInfo]which returns either None or a value of type GroovyLibraryInfo. For providers that accumulate upwards a transitive set is often a good choice.  "},{"title":"provider_field​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#provider_field","content":"def provider_field( ty, /, *, default = _ ) -&gt; ProviderField  Create a field definition object which can be passed to provider type constructor.  "},{"title":"read_config​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#read_config","content":"def read_config(section: str, key: str, default = _)  Read a configuration from the nearest enclosing .buckconfig of the BUCK file that started evaluation of this code. As an example, if you have a .buckconfig of: [package_options] compile = super_fast  Then you would get the following results: read_config(&quot;package_options&quot;, &quot;compile&quot;) == &quot;super_fast&quot; read_config(&quot;package_options&quot;, &quot;linker&quot;) == None read_config(&quot;package_options&quot;, &quot;linker&quot;, &quot;a_default&quot;) == &quot;a_default&quot;  In general the use of .buckconfig is discouraged in favour of select, but it can still be useful.  "},{"title":"read_oncall​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#read_oncall","content":"def read_oncall() -&gt; None | str  Called in a BUCK file to retrieve the previously set oncall, or None if none has been set. It is an error to call oncall after calling this function.  "},{"title":"read_package_value​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#read_package_value","content":"def read_package_value(key: str, /)  Read value specified in the PACKAGE file. Returns None if value is not set.  "},{"title":"read_parent_package_value​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#read_parent_package_value","content":"def read_parent_package_value(key: str, /)  Read a package value defined in a parent PACKAGE file. This function can only be called in a Package context. Returns None if value is not set.  "},{"title":"read_root_config​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#read_root_config","content":"def read_root_config( section: str, key: str, default: None | str = None, / ) -&gt; None | str  Like read_config but the project root .buckconfig is always consulted, regardless of the cell of the originating BUCK file.  "},{"title":"regex​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#regex","content":"def regex( regex: str, /, *, fancy: bool = False ) -&gt; buck_regex  .type attribute​ Produces &quot;buck_regex&quot;  "},{"title":"regex_match​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#regex_match","content":"def regex_match(regex: str, str: str, /) -&gt; bool  Test if a regular expression matches a string. Fails if the regular expression is malformed. As an example: regex_match(&quot;^[a-z]*$&quot;, &quot;hello&quot;) == True regex_match(&quot;^[a-z]*$&quot;, &quot;1234&quot;) == False   "},{"title":"repository_name​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#repository_name","content":"def repository_name() -&gt; str  Like get_cell_name() but prepends a leading @ for compatibility with Buck1. You should call get_cell_name() instead, and if you really want the @, prepend it yourself.  "},{"title":"rule​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#rule","content":"def rule( *, impl: typing.Callable[[typing.Any], list[typing.Any]], attrs: dict[str, attribute], cfg = _, doc: str = &quot;&quot;, is_configuration_rule: bool = False, is_toolchain_rule: bool = False, uses_plugins: list[typing.Any] | tuple = [] ) -&gt; &quot;function&quot;  Define a rule. As a simple example: def _my_rule(ctx: AnalysisContext) -&gt; list[Provider]: output = ctx.actions.write(&quot;hello.txt&quot;, ctx.attrs.contents, executable = ctx.attrs.exe) return [DefaultInfo(outputs = [output])] MyRule = rule(impl = _my_rule, attrs = { &quot;contents&quot;: attrs.string(), &quot;exe&quot;: attrs.option(attrs.bool(), default = False), })   "},{"title":"rule_exists​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#rule_exists","content":"def rule_exists(name: str) -&gt; bool  Check if the target with name has already been defined, returns True if it has. Note that this function checks for the existence of a target rather than a rule. In general use of this function is discouraged, as it makes definitions of rules not compose.  "},{"title":"select​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#select-1","content":"def select(d, /) -&gt; selector   "},{"title":"select_equal_internal​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#select_equal_internal","content":"def select_equal_internal(left, right, /) -&gt; bool  Tests that two selects are equal to each other. For testing use only. We simply compare their string representations.  "},{"title":"select_map​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#select_map","content":"def select_map(d, func, /)  Maps a selector. Each value within a selector map and on each side of an addition will be passed to the mapping function. The returned selector will have the same structure as this one. Ex: def increment_items(a): return [v + 1 for v in a] select_map([1, 2] + select({&quot;c&quot;: [2]}), increment_items) == [2, 3] + select({&quot;c&quot;: [3]})   "},{"title":"select_test​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#select_test","content":"def select_test(d, func, /) -&gt; bool  Test values in the select expression using the given function. Returns True, if any value in the select passes, else False. Ex: select_test([1] + select({&quot;c&quot;: [1]}), lambda a: len(a) &gt; 1) == False select_test([1, 2] + select({&quot;c&quot;: [1]}), lambda a: len(a) &gt; 1) == True select_test([1] + select({&quot;c&quot;: [1, 2]}), lambda a: len(a) &gt; 1) == True   "},{"title":"set_cfg_constructor​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#set_cfg_constructor","content":"def set_cfg_constructor( *, stage0, stage1, key: str, aliases = None, extra_data = None ) -&gt; None  Register global cfg constructor. This function can only be called from the repository root PACKAGE file. Parameters: stage0: The first cfg constructor that will be invoked before configuration rules are analyzed. stage1: The second cfg constructor that will be invoked after configuration rules are analyzed. key: The key for cfg modifiers on PACKAGE values and metadata. aliases: The aliases map to use for input modifiers. extra_data: Some extra data that may be used by set_cfg_constructor implementation that is custom to our implementation and may not be used in other context like open-source.  "},{"title":"set_starlark_peak_allocated_byte_limit​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#set_starlark_peak_allocated_byte_limit","content":"def set_starlark_peak_allocated_byte_limit(value: int, /) -&gt; None  Set the peak allocated bytes during evaluation of build ctx. Err if it has already been set  "},{"title":"sha256​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#sha256","content":"def sha256(val: str, /) -&gt; str  Computes a sha256 digest for a string. Returns the hex representation of the digest. sha256(&quot;Buck2 is the best build system&quot;) == &quot;bb99a3f19ecba6c4d2c7cd321b63b669684c713881baae21a6b1d759b3ec6ac9&quot;   "},{"title":"soft_error​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#soft_error","content":"def soft_error( category: str, message: str, /, *, quiet: bool = _, stack: bool = _ ) -&gt; None  Produce an error that will become a hard error at some point in the future, but for now is a warning which is logged to the server. In the open source version of Buck2 this function always results in an error. Called passing a stable key (must be snake_case and start with starlark_, used for consistent reporting) and an arbitrary message (used for debugging). As an example: soft_error( &quot;starlark_rule_is_too_long&quot;, &quot;Length of property exceeds 100 characters in &quot; + repr(ctx.label), )   "},{"title":"transition​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#transition","content":"def transition( *, impl: typing.Callable, refs: dict[str, str], attrs: list[str] | tuple[str, ...] = _, split: bool = False ) -&gt; transition   "},{"title":"transitive_set​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#transitive_set","content":"def transitive_set( *, args_projections: dict[str, typing.Any] = _, json_projections: dict[str, typing.Any] = _, reductions: dict[str, typing.Any] = _ ) -&gt; transitive_set_definition   "},{"title":"utarget_set​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#utarget_set","content":"def utarget_set(nodes: list[bxl.UnconfiguredTargetNode] = _) -&gt; target_set  Creates a target set from a list of unconfigured nodes. Sample usage: def _impl_utarget_set(ctx): targets = bxl.utarget_set([unode_a, unode_b]) ctx.output.print(type(targets)) ctx.output.print(len(targets))   "},{"title":"warning​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#warning","content":"def warning(x: str, /) -&gt; None  Print a warning. The line will be decorated with the timestamp and other details, including the word WARN (colored, if the console supports it). If you are not writing a warning, use print instead. Be aware that printing lots of output (warnings or not) can be cause all information to be ignored by the user.  "},{"title":"write_package_value​","type":1,"pageTitle":"globals","url":"/docs/api/bxl/globals/#write_package_value","content":"def write_package_value( key: str, value, /, *, overwrite: bool = False ) -&gt; None  Set the value to be accessible in the nested PACKAGE files. If any parent PACKAGE value has already set the same key, it will raise an error unless you pass overwrite = True, in which case it will replace the parent value. "},{"title":"Build Rule","type":0,"sectionRef":"#","url":"/docs/concepts/build_rule/","content":"","keywords":""},{"title":"Buck2's collection of build rules​","type":1,"pageTitle":"Build Rule","url":"/docs/concepts/build_rule/#buck2s-collection-of-build-rules","content":"Buck2 comes with a collection of built-in build rules for many common build procedures. For example, compiling Java code against the Android SDK is a common procedure, so Buck2 provides the build ruleandroid_library to do that. Similarly, the final product of most Android development is an APK, so you can use the build rule android_binary to create an APK. "},{"title":"Source files as inputs to build rules​","type":1,"pageTitle":"Build Rule","url":"/docs/concepts/build_rule/#source-files-as-inputs-to-build-rules","content":"Most build rules specify source files as inputs. For example, acxx_library rule would specify .cppfiles as inputs. To support specifying these files, a cxx_library rule provides the srcs argument. Some languages, such as C++, use header files as well. To specify these, cxx_library provides a headers argument. In addition to srcs and headers, some rules provide variants of these arguments, such asplatform_srcs and platform_headers. These arguments support groups of source files that should be used as inputs only when building for specific platforms. "},{"title":"Package boundaries and access to source files​","type":1,"pageTitle":"Build Rule","url":"/docs/concepts/build_rule/#package-boundaries-and-access-to-source-files","content":"In Buck2, a BUCK file defines a package, which corresponds roughly to the directory that contains the BUCK file and those subdirectories that do not themselves contain BUCK files. (To learn more, see theKey Concepts topic.) A rule in a BUCK file cannot specify a source file as an input unless that source file is in that BUCK file's package. An exception to this restriction exists for header files, but only if a rule in the package that contains the header file exports that header file using theexported_headers argument. For more details, see the description forexported_headers in, for example, thecxx_library topic. More commonly though, the package for a BUCK file contains all the source files required for the rules defined in that BUCK file. Functionality in source files from other packages is made available through the artifacts produced by the rules in the BUCK files for those packages. For example, a cxx_binarymight use the functionality in a cxx_library that is defined in another package. To access that functionality, the cxx_binary would take thatcxx_library as a dependency. Symlinks: Use with caution if at all​ We recommend that you do not use symlinks—either absolute or relative—to specify input files to build rules. Although using symlinks in this context does sometimes work, it can lead to unexpected behavior and errors. "},{"title":"Dependencies: Output from one rule as input to another rule​","type":1,"pageTitle":"Build Rule","url":"/docs/concepts/build_rule/#dependencies-output-from-one-rule-as-input-to-another-rule","content":"A build rule can use the output from another build rule as one of its inputs by specifying that rule as a dependency. Typically, a build rule specifies its dependencies as a list of build targets in its depsargument. However, the rule can also specify dependencies—as build targets—in other arguments, such as srcs. Example: The output of ajava_library rule is a JAR file. If ajava_library rule specifies another java_library rule as a dependency, the JAR file produced by the specified rule is added to the classpath for thejava_library that depends on it. Example: If ajava_binary rule specifies ajava_library rule as a dependency, the JAR file for the specifiedjava_library is available on the classpath for the java_binary. In addition, in the case of java_binary, the JAR files for any dependencies of thejava_library rule are also made available to the java_binary rule—and if those dependencies have dependencies of their own, they are added as well. This exhaustive cascade of dependencies is referred to as the rule's transitive closure. "},{"title":"Required dependencies are always built first​","type":1,"pageTitle":"Build Rule","url":"/docs/concepts/build_rule/#required-dependencies-are-always-built-first","content":"Buck2 guarantees that any dependencies that a rule lists that are required in order to build that rule are built successfully before Buck2 builds the rule itself. Note though that there can be special cases—such asapple_bundle—where a rule's listed dependencies do not actually need to be built before the rule. "},{"title":"Visibility​","type":1,"pageTitle":"Build Rule","url":"/docs/concepts/build_rule/#visibility","content":"In order for a build rule to take a dependency on another build rule, the build rule on which the dependency is taken must be visible to the build rule taking the dependency. A build rule's visibility argument is a list ofbuild target patterns that specify the rules that can take that rule as a dependency. For more information about the concept of visibility in Buck2, see the Visibility topic. "},{"title":"Dependencies define a graph​","type":1,"pageTitle":"Build Rule","url":"/docs/concepts/build_rule/#dependencies-define-a-graph","content":"Build rules and their dependencies define a directed acyclic graph (DAG). Buck2 requires this graph to be acyclic to make it possible to build independent subgraphs in parallel. "},{"title":"How to handle special cases: genrules and macros​","type":1,"pageTitle":"Build Rule","url":"/docs/concepts/build_rule/#how-to-handle-special-cases-genrules-and-macros","content":"Although Buck2 provides a rich set of built-in build rules for developers, it is not able to address all possible needs. As an &quot;escape hatch,&quot; Buck2 provides a category of generic build rules called genrules. With genrules, you can perform arbitrary operations using shell scripts. The genrules supported by Buck2 are: genruleapk_genrulecxx_genrule "},{"title":"Multiple output files with genrules​","type":1,"pageTitle":"Build Rule","url":"/docs/concepts/build_rule/#multiple-output-files-with-genrules","content":"In most cases, a build rule produces exactly one output file. However, with genrules, you can specify an output directory and write arbitrary files to that directory. "},{"title":"Macros​","type":1,"pageTitle":"Build Rule","url":"/docs/concepts/build_rule/#macros","content":"Finally, note that you can define functions that generate build rules. In general, this should not be something that you need to do, but taking advantage of this option might help you add needed functionality to Buck2's without editing its source code. "},{"title":"String parameter macros​","type":1,"pageTitle":"Build Rule","url":"/docs/concepts/build_rule/#string-parameter-macros","content":"It is also possible to expand references to other rules within the cmd, using builtin string parameter macros. All build rules expanded in the command are automatically considered to be dependencies of the genrule(). Note that the paths returned by these macros are relative paths. Using relative paths ensures that your builds are hermetic, that is, they are reproducible across different machine environments. $(classpath //path/to:target) Expands to the transitive classpath of the specified build rule, provided that the rule has a Java classpath. If the rule does not have (or contribute to) a classpath, then an exception is thrown and the build breaks. $(exe //path/to:target) Expands a build rule that results in an executable to the commands necessary to run that executable. For example, a java_binary() might expand to a call tojava -jar path/to/target.jar . Files that are executable (perhaps generated by a genrule()) are also expanded. If the build rule does not generate an executable output, then an exception is thrown and the build breaks. If the $(exe my_dependency) dependency should actually be built with the target platform, use $(exe_target my_dependency) instead, which will stick to the same platform as the target. $(location //path/to:target) Expands to the location of the output of the specified build rule. This means that you can refer to the output without needing to be aware of how Buck is storing data on the disk mid-build.   "},{"title":"Build Target","type":0,"sectionRef":"#","url":"/docs/concepts/build_target/","content":"","keywords":""},{"title":"Command-line Pro Tips​","type":1,"pageTitle":"Build Target","url":"/docs/concepts/build_target/#command-line-pro-tips","content":"Here are some ways that you can reduce your typing when you specify build targets as command-line arguments to the buck2 build or buck2 run commands. Consider the following example of a fully-qualified build target used with thebuck2 build command: buck2 build //java/com/facebook/share:share  Although Buck2 is always strict when parsing build targets in build files, Buck2 is flexible when parsing build targets on the command-line. Specifically, the leading // is optional on the command line, so the above could be: buck2 build java/com/facebook/share:share  Also, if there is a forward slash before the colon, it is ignored, so this could also be written as: buck2 build java/com/facebook/share/:share  which enables you to produce the red text shown below using tab-completion, which dramatically reduces how much you need to type: buck2 build java/com/facebook/share/:share  Finally, if the final path element matches the value specified after the colon, it can be omitted: # This is treated as //java/com/facebook/share:share. buck2 build java/com/facebook/share/  which makes the build target even easier to tab-complete. For this reason, the name of the build target for the primary deliverable in a build file is often named the same as the parent directory. That way, it can be built from the command-line with less typing. "},{"title":"See also​","type":1,"pageTitle":"Build Target","url":"/docs/concepts/build_target/#see-also","content":"Buck2 supports the ability to define aliases for build targets; using aliases can improve brevity when specifying targets on the Buck2 command line. For more information, see the [alias] section in the documentation for .buckconfig. Abuild target pattern is a string that describes a set of one or more build targets. For example, the pattern //... is used to build an entire project. For more information, see the Build Target Pattern topic. "},{"title":"Configurations","type":0,"sectionRef":"#","url":"/docs/concepts/configurations/","content":"Configurations For rule authors see also: Configurations When building a target, buck always builds it in a particular &quot;configuration.&quot; The configuration typically includes information like the target os, target arch, sanitizers, opt level, etc. One way to understand the effect that a configuration has is via the cquery and uquery commands. The cquery command will compute the appropriate configuration for a target and display a version of that target's attributes with the configuration applied. The uquery command will not apply a configuration. Here is a heavily trimmed version of the outputs of invoking uquery andcquery on //buck2/app/buck2_core:buck2_core. &gt; buck2 uquery -A '&quot;//buck2/app/buck2_core:buck2_core&quot;' { &quot;fbcode//buck2/app/buck2_core:buck2_core&quot;: { &quot;buck.type&quot;: &quot;rust_library&quot;, &quot;buck.package&quot;: &quot;fbcode//buck2/app/buck2_core:TARGETS&quot;, &quot;name&quot;: &quot;buck2_core&quot;, &quot;visibility&quot;: [ &quot;PUBLIC&quot; ], &quot;deps&quot;: { &quot;fbsource//third-party/rust:anyhow&quot;, &quot;fbsource//third-party/rust:arc-swap&quot;, &quot;fbsource//third-party/rust:blake3&quot;, &quot;fbsource//third-party/rust:compact_str&quot;, &quot;fbsource//third-party/rust:dashmap&quot;, { &quot;__type&quot;: &quot;selector&quot;, &quot;entries&quot;: { &quot;DEFAULT&quot;: [], &quot;ovr_config//os:windows&quot;: [ &quot;fbsource//third-party/rust:common-path&quot; ] } }, { &quot;__type&quot;: &quot;selector&quot;, &quot;entries&quot;: { &quot;DEFAULT&quot;: [], &quot;ovr_config//os:linux&quot;: [ &quot;fbsource//third-party/rust:nix&quot; ] } }, }, } } &gt; buck2 cquery -A '&quot;//buck2/app/buck2_core:buck2_core&quot;' { &quot;fbcode//buck2/app/buck2_core:buck2_core (ovr_config//platform/linux:&lt;OMITTED&gt;)&quot;: { &quot;buck.type&quot;: &quot;rust_library&quot;, &quot;buck.package&quot;: &quot;fbcode//buck2/app/buck2_core:TARGETS&quot;, &quot;buck.target_configuration&quot;: &quot;ovr_config//platform/linux:&lt;OMITTED&gt;&quot;, &quot;buck.execution_platform&quot;: &quot;fbcode//buck2/platform/&lt;OMITTED&gt;&quot;, &quot;name&quot;: &quot;buck2_core&quot;, &quot;visibility&quot;: [ &quot;PUBLIC&quot; ], &quot;deps&quot;: [ &quot;fbsource//third-party/rust:anyhow (ovr_config//platform/linux:&lt;OMITTED&gt;)&quot;, &quot;fbsource//third-party/rust:arc-swap (ovr_config//platform/linux:&lt;OMITTED&gt;)&quot;, &quot;fbsource//third-party/rust:blake3 (ovr_config//platform/linux:&lt;OMITTED&gt;)&quot;, &quot;fbsource//third-party/rust:compact_str (ovr_config//platform/linux:&lt;OMITTED&gt;)&quot;, &quot;fbsource//third-party/rust:dashmap (ovr_config//platform/linux:&lt;OMITTED&gt;)&quot;, &quot;fbsource//third-party/rust:nix (ovr_config//platform/linux:&lt;OMITTED&gt;)&quot; ] } The cquery output has additional buck.target_configuration andbuck.execution_platform attributes which tell you what the target is being built for and what it's being built on, respectively. uquery doesn't have those. The deps in uquery also have a number of selects; these indicate that thecommon-path dependency should only be included when building for Windows, while the nix dependency is needed only for Linux. In cquery that distinction has been resolved; because the target has been configured for Linux, the nix dependency is present and indistinguishable from any other, while thecommon-path dependency is gone.","keywords":""},{"title":"Daemon (buckd)","type":0,"sectionRef":"#","url":"/docs/concepts/daemon/","content":"","keywords":""},{"title":"Killing or disabling the Buck daemon​","type":1,"pageTitle":"Daemon (buckd)","url":"/docs/concepts/daemon/#killing-or-disabling-the-buck-daemon","content":"The Buck daemon process is killed if buck2 clean or buck2 kill commands are run. Note that they won't kill the daemon associated with custom isolation dirs. To do that, run using the --isolation-dir option (buck2 --isolation-dir &lt;dir&gt; &lt;command&gt;) "},{"title":"Key concepts","type":0,"sectionRef":"#","url":"/docs/concepts/key_concepts/","content":"","keywords":""},{"title":"Buck2's dependency graph​","type":1,"pageTitle":"Key concepts","url":"/docs/concepts/key_concepts/#buck2s-dependency-graph","content":"Every build rule can have zero or more dependencies. You can specify these dependencies using, for example, the deps argument to the build rule. For more information about specifying dependencies, consult the reference page for the build rule you are using. These dependencies form a directed graph, called thetarget graph. Buck2 requires the graph to be acyclic. When building the output of a build rule, all of the rule's transitive dependencies are built first. This means that the graph is built in a &quot;bottom-up&quot; fashion. A build rule knows only which rules it depends on, not which rules depend on it. This makes the graph easier to reason about and enables Buck2 to identify independent subgraphs that can be built in parallel. It also enables Buck2 to determine the minimal set of build targets that need to be rebuilt. "},{"title":"Multiple Buck2 projects in a single repository​","type":1,"pageTitle":"Key concepts","url":"/docs/concepts/key_concepts/#multiple-buck2-projects-in-a-single-repository","content":"Buck2 is designed to build multiple deliverables from a single repository—that is, a monorepo—rather than from multiple repositories. Support for the monorepo design motivated Buck2's support for cells and projects. It is Facebook's experience that maintaining all dependencies in the same repository makes it easier to ensure that all developers have the correct version of the code and simplifies the process of making atomic commits. "},{"title":"See also​","type":1,"pageTitle":"Key concepts","url":"/docs/concepts/key_concepts/#see-also","content":"Take a look at the Concept Map for a visualization of how Buck2 concepts interact with each other. Also see the Glossary. "},{"title":"Glossary of Terms","type":0,"sectionRef":"#","url":"/docs/concepts/glossary/","content":"Glossary of Terms .buckconfig​ The root of your project must contain a configuration file named.buckconfig. Before executing, Buck2 reads this file to incorporate specified customizations. See .buckconfig for more info. Action​ An individual, cacheable, ideally hermetic command that's run during thebuild. It takes artifacts as inputs and produces other artifacts as outputs. An example command could be gcc -o main main.c, which takes the artifact main.c (a source file) and produces the artifact called main (the compiled binary). Action digest​ Encoded action representation. It is sent toremote execution. Used among other things to retrieve action inputs and to check for cache hits Action graph​ The dependency graph of all actions belonging to a target: it can be queried with buck2 aquery. Artifact​ A single input or output of an action. These are files that participate as inputs or outputs of a build and can be source files or build outputs. For more information, see theArtifact API. Attribute​ Declared by a rule and used to express the properties of a particular instance of a rule to create a target. For example, srcs, deps and copts, which declare a target's source files, dependencies, and custom compiler options, respectively. The available attributes for a target depend on its rule type. BUCK file​ A BUCK file (the name is configurable, some projects use TARGETS) is the main configuration file that tells Buck2 what to build, what their dependencies are, and how to build them. Buck2 takes a BUCK file as input and evaluates the file to declare targets, which are then used to create a graph of dependencies and to derive the actions that must be completed to build intermediate and final software outputs. A BUCK file marks a directory and any sub-directories not containing a BUCK file as a package. BXL​ BXL (Buck eXtension Language) scripts are written in Starlark (a restricted subset of Python) and give integrators the ability to inspect and interact directly with the buck2 graph. BXL scripts can query the action graph,configured graph, andunconfigured graph. They can also createactions and trigger builds. Cell​ The directory tree of one or more Buck2 packages. A Buck2 build can involve multiple cells. The cell root always contains a.buckconfig, although the presence of a .buckconfig file doesn't in itself define a cell. Rather, the cells involved in a build are defined at the time Buck2 is invoked; they are specified in the .buckconfig for the Buckproject. Configuration​ Configurations consist of a set of 'constraint values' that are used to resolveselect attributes prior to evaluating ruleimplementations: the attribute takes the value of the first branch in theselect that matches the configuration. Configurations are instantiated by rules that produce a PlatformInfoprovider. Once created, targets can receive their configuration through a variety of mechanisms, such as: Inheritance - by default, when following a dependency edge A -&gt; B, B inherits A's configuration.The default_target_platform attribute and --target-platforms command line flag.Transitions (see below). Configurations allow a single target to exist in multiple variants in the configured graph (for example, to build a given binary at differing optimization levels or targeting different CPU architectures). Configured graph​ The configured target graph is generated by configuring target nodes in theunconfigured target graph. That is, selects are fully resolved and configurations applied. The configured graph includes information about the configurations and transitionsinvolved in building targets. The same target may appear in multiple different configurations (when printed, the configuration is after the target in parentheses). Constraint​ A constraint represents a property that may differ across differenttarget or build contexts, such as CPU architecture, the version of a system-installed compiler, optimization level, which version of a particular library to use, etc. Daemon​ The Daemon process lives between invocations and is designed to allow for cache reuse between Buck2 invocations, which can considerably speed up builds. For more information, see Daemon (buckd). Dependency​ A directed edge between two targets. A target A can have a dependency on target B, for example, if any dep attribute of A mentionsB. A target's dependence on another target is determined by thevisibility of the latter. Execution platform​ A type of rule that includes information such as what execution types atarget supports, which can be remote, local, and hybrid execution. Also, whether it supports cache uploads, which allows users to get cache hits for things that executed locally. Hybrid execution​ Allows Buck2 to race local and remote execution and get whichever finishes first (unless there's a cache hit, then it will get output from cache). This can provide substantial speedup by eliminating the overhead of going toremote execution when there is enough capacity to service the build locally. Isolation dir​ Instances of Buck2 share a daemon if and only if their isolation directory is identical. The isolation directory also influences the output paths provided by Buck2. Modifiers​ It's a modification of a constraint from the existingconfiguration to obtain a new configuration. They provide a unified way to specify build settings on a project,target, and command line level. It is intended to replacetarget platforms and most use cases of.buckconfigs. Package​ A directory that contains a Buck2 BUCK file and all source files belonging to the same directory as the BUCK file, or any of its subdirectories that do not contain a BUCK file themselves. Prelude​ The prelude is a unique .bzl file located at prelude//prelude.bzl. Buck2 implicitly loads all the symbols defined in the prelude whenever it loads aBUCK file. Symbols defined outside the prelude can be imported via a load() statement. When you create a Buck2 project using buck2 init --git, it will contain the same prelude used internally at Meta by Buck2 users. It is viewable athttps://github.com/facebook/buck2/tree/main/prelude. Project​ The Outermost directory where there is a .buckconfig: also known as the root cell. The .buckconfig for the project specifies thecells that constitute the Buck2 project. Specifically, these cells are specified in the '[cells]' section of the .buckconfig. All command invocations are executed from the project root. Provider​ Data returned from a rule function. It's the only way that information from this rule is available to other rules that depend on it (seedependency). For more information, seeProviders. Platform​ A named set of constraints, defining a specific runtime environment. E.g. cpu=x86_64, os=windows Remote execution (RE)​ Distributed execution of actions on remote workers. It can speed up builds significantly by scaling the nodes available for parallel actions, and by caching action outputs across Buck2 users. Rule​ A rule consists of an attribute spec and an implementation, which is aStarlark function. The attribute spec declares what attributes the rule expects to receive. The rule implementation receives the attributes of a targetand the providers of its dependencies. It can declare new actions and artifacts and must returnproviders that can be used to pass data to its dependents or to Buck2 itself. Rules are instantiated in BUCK files to declare targets and set their attributes. The rule implementation is called when Buck2 needs its providers, which can happen when the target is built, or when one of its dependents is. As an example, the cxx_binary rule could be used to create a C++ binary, butandroid_binary rule would be used to create an Android APK Starlark​ Starlark is a dialect of Python originally developed by Google for theBazel build tool. It is the configuration language of the Buck2 build system and the language you use in .bzl andBUCK files to define and instantiate rules. There are many reasons why Meta has chosen Starlark, as detailed inThe Rust Starlark libraryarticle. The Buck2 project maintains and uses an open sourceStarlark interpreter in Rust. Subtarget​ Collection of providers that can be accesed by name. The subtargets can have their own subtargets as well, which can be accessed by chaining them, e.g.: buck2 build cell//foo:bar[baz][qux]. Target​ An object that is defined in a BUCK file. Targets represent the buildable units of a build from the perspective of the end user. Declared by instantiating a rule with attributes. A target hasdependencies, which are references to other targets. Target label​ The identifier for a target. Structured ascell_alias//path/to/package:target, where cell_alias// maps to acell root path (as defined in the ./buckconfig of the cell this target belongs to), path/to/package is the packagedirectory that contains the BUCK file declaring the target (relative to the mapped cell alias), and :target is the target's name. Target pattern​ A string that resolves to a set of targets. They can be used as arguments to commands such as buck2 build and buck2 uquery. They can also be used in the visibility argument of a rule. For more information, see Target pattern. Target platform​ Represents the platform that the final output is built for residing and executing. If buck2 is a chef, and the output is the meal, the target platform would be the people that eat the meal. Target universe​ A set of configured targets and their transitive deps. In the context of cquery and build in the Buck2 CLI, any literals are resolved to all matching targets within the universe. Target universe can be passed explicitly on the Buck2 CLI via --target-universe. If omitted, the target universe will be inferred by constructing a universe using all the target literals (and their transitive deps) within the query string for cquery. Transition​ Allows the configuration to change across adependency edge. That is, normally, if target A depends on target B, then if the configuration for A is X, then B is configured using X too. By using a transition, you can produce X to configure B instead. Unconfigured graph​ A graph of targets before configurations are applied. Can be queried via buck2 uquery. Visibility​ Determines whether a target can include another target as its dependency. For more information, seeVisibility.","keywords":""},{"title":"Target Pattern","type":0,"sectionRef":"#","url":"/docs/concepts/target_pattern/","content":"","keywords":""},{"title":"Build target patterns are not allowed in the deps argument​","type":1,"pageTitle":"Target Pattern","url":"/docs/concepts/target_pattern/#build-target-patterns-are-not-allowed-in-the-deps-argument","content":"Build target patterns cannot be used with the deps argument of a build rule. Buck requires that you specify all dependencies explicitly as either fully-qualified or relative build targets. "},{"title":"Target aliases​","type":1,"pageTitle":"Target Pattern","url":"/docs/concepts/target_pattern/#target-aliases","content":"Buck supports the ability to define aliases for build targets; using aliases can improve brevity when specifying targets on the Buck command line. To see which aliases exist, use buck2 audit config alias. "},{"title":"Visibility","type":0,"sectionRef":"#","url":"/docs/concepts/visibility/","content":"","keywords":""},{"title":"Examples​","type":1,"pageTitle":"Visibility","url":"/docs/concepts/visibility/#examples","content":"A common library like Guava should be able to be included by any build rule: prebuilt_jar( name = 'guava', binary_jar = 'guava-14.0.1.jar', visibility = ['PUBLIC'] )  It is common to restrict the visibility of Android resources to the Java code that uses it: android_resource( name = 'ui_res', res = 'res', package = 'com.example', visibility = ['//java/com/example/ui:ui'] )  Or it may be simpler to make it visible to the entire directory in case additional build rules are added to java/com/example/ui/BUCK: android_resource( name = 'ui_res', res = 'res', package = 'com.example', visibility = ['//java/com/example/ui:'] )  Also, it is common to limit code for testing to be visible only to tests. If you define all of your Java unit tests in a folder named javatests/ in the root of your project, then you could define the following rule to ensure that only build rules under javatests/ can depend on JUnit: prebuilt_jar( name = 'junit', binary_jar = 'junit-4.11.jar', visibility = ['//javatests/...'] )  Finally, restricting the view of a target can be useful for preventing dependency creep: java_library( name = 'example', visibility = ['PUBLIC',], within_view = ['//foo:bar','//hello:world'] )  "},{"title":"Buck2 Telemetry","type":0,"sectionRef":"#","url":"/docs/developers/architecture/buck2_telemetry/","content":"Buck2 Telemetry note 🚧 THIS PAGE IS UNDER CONSTRUCTION","keywords":""},{"title":"Buck1 vs Buck2","type":0,"sectionRef":"#","url":"/docs/developers/architecture/buck1_vs_buck2/","content":"","keywords":""},{"title":"At a glance​","type":1,"pageTitle":"Buck1 vs Buck2","url":"/docs/developers/architecture/buck1_vs_buck2/#at-a-glance","content":"The following table provides an at-a-glance comparison of Buck1 and Buck2. Buck1\tBuck2Build files in Starlark\tBuild files in Starlark Macros in Starlark\tMacros in Starlark Rules in Java\tRules in Starlark Rules and Macros are logically similar\tRules and Macros are logically similar Rules and Core are not well abstracted\tRules and Core are strongly separated Core in Java\tCore in Rust Remote Execution (RE) not well supported\tAll rules support remote execution by default Varying degrees of incrementality / parallelism\tUnified incrementality / parallelism "},{"title":"Top-down vs Bottom-up - understanding the implications of the difference in execution models between Buck1 and Buck2​","type":1,"pageTitle":"Buck1 vs Buck2","url":"/docs/developers/architecture/buck1_vs_buck2/#top-down-vs-bottom-up---understanding-the-implications-of-the-difference-in-execution-models-between-buck1-and-buck2","content":"It is often said that Buck1 does 'top down' and Buck2 does 'bottom up' building. This results in cases where some topics that seem conceptually trivial in Buck1 are hard problems in Buck2, or vice versa. "},{"title":"What are the differences?​","type":1,"pageTitle":"Buck1 vs Buck2","url":"/docs/developers/architecture/buck1_vs_buck2/#what-are-the-differences","content":"Scenario: Imagine you are building A, which depends on both B and C, but where neither B nor C have any dependencies. For the sake of simplicity, imagine B and C are C++ compilations (that produce object files), and A is a link (that consumes them and produces a shared library). Building A with Buck1​ Following is an oversimplified view of what happens: Buck1 computes the 'rulekey' for B. This consists of mixing together the hashes of the C++ file being compiled, as well as all C++ compiler flags, and so on. Buck1 then does the same for C.Buck1 then computes the rulekey for A. This consist of mixing together the rulekeys of B and C, as well as linker flags used by A. for example. Buck1 then looks up the rulekey for A in the cache. If there's a hit, then Buck1 downloads the output and its job done.If there's a cache miss, continue. Buck1 then queries the cache for the rulekeys of B and C: If there's a hit, then the output is downloaded.If there's a miss, then Buck1 runs the commands needed to produce the object file that was missed. Regardless of whether those commands run locally or on RE, Buck1 downloads the output of B and C. Buck1 then runs the command for A to produce the shared library. At this point, Buck1 may actually do another cache lookup with a different rulekey, which is called an input based rulekey. This rulekey is derived from the inputs of the action that needs executing, which at this point of the build are known (since they were just built)! Building A with Buck2​ In contrast, if you ask Buck2 to build A, here is what happens: Buck2 produce the action to compile B and computes the hash of the action. This is the 'action digest', which consists of mixing the hashes of all the inputs (such as the C++ file), as well as the command line (so, implicitly, the compiler flags). Buck2 queries the action cache for the action digest hash. If there's a hit, Buck2 obtains the hash of the resulting object file (that is, the output of B).If there's a miss, Buck2 runs the action on RE (or potentially locally) and obtains the hash of the object file. If the action runs remotely, Buck2 will not download the output. Buck2 does the same thing for C.Buck2 produces the action to link A. This consists of mixing together all the hashes of the input files (which were retrieved earlier) and the command line to produce an action digest, then querying the cache and potentially running the action. Once Buck2 produces A (again, on RE), then, since this output was requested by the user (unlike the intermediary outputs B and C), Buck2 downloads A. "},{"title":"Some implications​","type":1,"pageTitle":"Buck1 vs Buck2","url":"/docs/developers/architecture/buck1_vs_buck2/#some-implications","content":"Rulekeys vs Action digests​ The closest thing to Buck1’s rulekey in Buck2 is the action digest, but they are very different! Since it’s a product of the (transitive) inputs of an action, the (default) rulekey can be computed without running anything or querying any caches. However, the action digest cannot: it requires the actual inputs of an action, which means you need to build all the dependencies first. This means that: In Buck1, you can ask for rulekeys for a target.In Buck2, you’d have to run the build first then ask for the action digests (this is what the buck2 log what-ran would show you). Buck2 queries many more caches​ Buck1 will not descend further down a tree of dependency when it gets a cache hit.Buck2 will always walk up all your dependencies, regardless of whether you get cache hits or not. Materialization​ When Buck1 gets a cache miss, it downloads the outputs.Buck2, by contract, does not download outputs as part of a build (this is called 'deferred materialization'). Note that Buck2 does download the outputs if the user asked for them (that is, they were the targets the user put on the command line). "},{"title":"Second-order implications​","type":1,"pageTitle":"Buck1 vs Buck2","url":"/docs/developers/architecture/buck1_vs_buck2/#second-order-implications","content":"Non-determinism​ Non-determinism in a build affects Buck2 and Buck1 differently. One scenario that often works fine in Buck1 but can work catastrophically bad in Buck2 is a codegen step, driven by a Python binary. In certain configurations/modes, Python binaries are non-deterministic, because they are XARs ([https://engineering.fb.com/2018/07/13/data-infrastructure/xars-a-more-efficient-open-source-system-for-self-contained-executables/](eXecutable ARchives)) and that is always non-deterministic, which is bad! In Buck1, that doesn’t really matter, because you can get a cache hit on the codegen output without ever visiting the XAR (as long as the input files haven’t changed).In Buck2, you need the XAR to check the action cache for the codegen step. However, binaries are often not cached in certain configurations/modes, so your XAR isn’t cached.Therefore, since your XAR build is non-deterministic, you’ll always miss in the action cache and the codegen step will always have to run in every build. It can get worse! If the Python binary produces non-deterministic codegen, then the entire build might become uncacheable. Cache misses don’t necessarily propagate​ Say that, in Buck2, you’re trying to build a chain of actions like codegen -&gt; compile -&gt; link. Even if your codegen step isn’t cached (say, because its action inputs are non-deterministic as mentioned above), as long as the codegen output is deterministic, you can still get cache hits from compile and link steps. Hybrid execution​ If you squint, you’ll note that Buck1’s build could be viewed as 'local first', whereas Buck2’s would be better viewed as 'remote first': When Buck1 builds something remotely or gets a cache hit, the outputs are always downloaded.When Buck2 builds something remotely or gets a cache hit, the outputs are never downloaded. In turn, this has some important implications: When Buck1 builds something locally, the inputs are always already present.When Buck2 builds something locally, the inputs have to be downloaded, unless they were built locally (which if you’re doing any RE, is usually not the case), or if another command caused them to be downloaded. This means that, in Buck1, running something locally when you have spare resources is usually a no-brainer, because it’s always ready to go, and you’ll save on not having to download the output from RE (though you might have to upload the output if you need to run actions depending on it later). On the flip side, with Buck2, that’s not necessarily the case. To run an action locally, you need to download inputs that you might otherwise not have needed, which will tax your network connection. "},{"title":"BXL and Anonymous Targets","type":0,"sectionRef":"#","url":"/docs/developers/anon_targets/","content":"","keywords":""},{"title":"Anonymous targets​","type":1,"pageTitle":"BXL and Anonymous Targets","url":"/docs/developers/anon_targets/#anonymous-targets","content":"Anonymous targets are supported in BXL. Anonymous targets are keyed by the attributes, and allow you to share/cache work more effectively. You might want to use anonymous targets if there is some heavy Starlark evaluation which can be cached, or if you want to cache local actions. Note: The context object within the anon target rule is not a BXL context, but a normal rule analysis context. "},{"title":"APIs​","type":1,"pageTitle":"BXL and Anonymous Targets","url":"/docs/developers/anon_targets/#apis","content":"The actions object returned from ctx.bxl_actions().actions (equivalent ofctx.actions in normal rules) has the following functions for anonymous targets: anon_target(rule: &quot;rule&quot;, attrs: Dict[str, Any]) -&gt; &quot;promise&quot;: generates a single anonymous target. Return type is an unresolved promise.anon_targets(rules: [(&quot;rule&quot;, Dict[str, Any])]) -&gt; &quot;promise&quot;: generates a list of anonymous targets. Return type is an unresolved promise representing the list of anonymous targets.artifact_promise(promise: &quot;promise&quot;) -&gt; &quot;promise_artifact&quot;: turns an unresolved promise into a kind of artifact. SeeConvert promise to artifactfor more info on why you might want to use this. The resulting promise also has map() and join() functions. map() applies a function to the promise's results, and join() turns multiple promises into a single promise. To resolve promises in BXL, bxl_ctx has a resolve() function, which takes in the analysis actions instance (actions object returned fromctx.bxl_actions().actions) and a single promise and returns an optional promise value, if there is one. If you intend to create multiple promises, usingjoin() to produce a single promise will allow you to resolve them concurently with a single resolve() call. Small example: def _my_impl(ctx): bxl_actions = ctx.bxl_actions() # pass in relevant params to configure the execution platform resolution actions = bxl_actions.actions promise1 = actions.anon_target(my_anon_rule1, my_attrs1).promise promise2 = actions.anon_target(my_anon_rule2, my_attrs2).promise.map(my_map_function) joined = promise1.join(promise2) resolved = ctx.resolve(actions, joined) # do some more stuff ...  "},{"title":"Complete Example​","type":1,"pageTitle":"BXL and Anonymous Targets","url":"/docs/developers/anon_targets/#complete-example","content":"## anon_bxl_rules.bzl ############ # Define an anonymous rule. MirrorInfo = provider(fields = [&quot;mirrored_attrs&quot;]) # Anonymous rule which writes some silly output, and also mirrors all attributes received def _mirror_impl(ctx: &quot;context&quot;) -&gt; [&quot;provider&quot;]: out = ctx.actions.declare_output(&quot;my_output&quot;) ctx.actions.write(out, &quot;my_content&quot;) return [DefaultInfo(default_outputs = [out]), MirrorInfo(mirrored_attrs = ctx.attrs)] my_mirror_rule = rule(impl = _mirror_impl, attrs = { &quot;false&quot;: attrs.bool(), &quot;int&quot;: attrs.int(), &quot;list_string&quot;: attrs.list(attrs.string()), &quot;string&quot;: attrs.string(), &quot;true&quot;: attrs.bool(), }) # Will be used in a map function in my_script.bxl below StringInfo = provider(fields = [&quot;my_string&quot;]) ## my_script.bxl ############ load(&quot;:anon_bxl_rules.bzl&quot;, &quot;MirrorInfo&quot;, &quot;StringInfo&quot;, &quot;my_mirror_rule&quot;) def _anon_target_example(ctx): bxl_actions = ctx.bxl_actions() actions = bxl_actions.actions # Attrs to pass into the anonymous target. An anonymous target is defined by the hash of its attributes my_attrs = { &quot;false&quot;: False, &quot;int&quot;: 42, &quot;list_string&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;string&quot;: &quot;foo-bar-string&quot;, &quot;true&quot;: True, } # A function to be applied to the promise (result of anon target), producing a promise with the resulting value. def my_function(providers): # Do something with the attrs. In this example, we are validating that the attrs are what we expect. mirrored_fields = providers[MirrorInfo].mirrored_attrs assert_eq(mirrored_fields.true, True) assert_eq(mirrored_fields.false, False) assert_eq(mirrored_fields.int, 42) assert_eq(mirrored_fields.string, &quot;foo-bar-string&quot;) assert_eq(mirrored_fields.list_string, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) outputs = providers[DefaultInfo].default_outputs # These are the providers this target returns return [DefaultInfo(default_outputs = outputs), StringInfo(my_string = &quot;map function succeeded!&quot;)] # Create an anonymous target by passing in &quot;my_attrs&quot; into &quot;my_mirror_rule&quot;, and returns providers. # Specifically, it returns &quot;DefaultInfo&quot; and &quot;MirrorInfo&quot;, as defined in &quot;my_mirror_rule&quot; # Then, we map the result to &quot;my_function&quot;, which does some validation promise = actions.anon_target(my_mirror_rule, my_attrs).promise.map(my_function) # Resolving the promise returns a &quot;provider_collection&quot;, which was defined by &quot;my_function&quot; above. # `DefaultInfo` is at index 0, `StringInfo` is at index 1 promise_result = ctx.resolve(actions, promise) ensured = ctx.output.ensure(promise_result[0].default_outputs[0]) # should print out location of the output, which contains the &quot;my_content&quot; string as defined in anon_bxl_rules.bzl above ctx.output.print(ensured) # should print out &quot;map function succeeded!&quot; ctx.output.print(promise_result[1].my_string) def assert_eq(a, b): if a != b: fail(&quot;Expected {} == {}&quot;.format(a, b)) anon_target_example = bxl_main( impl = _anon_target_example, cli_args = { }, )  "},{"title":"BXL Basics","type":0,"sectionRef":"#","url":"/docs/developers/bxl_basics/","content":"","keywords":""},{"title":"Common BXL functionalities​","type":1,"pageTitle":"BXL Basics","url":"/docs/developers/bxl_basics/#common-bxl-functionalities","content":""},{"title":"Build​","type":1,"pageTitle":"BXL Basics","url":"/docs/developers/bxl_basics/#build","content":"You can build targets within BXL withctx.build(). The result is abxl.BuildResult, which has artifacts() andfailures() functions that provide iterators to the artifacts or failures, respectively. You can pass in a single target or target pattern to build. "},{"title":"Analysis​","type":1,"pageTitle":"BXL Basics","url":"/docs/developers/bxl_basics/#analysis","content":"You can run analysis on targets within BXL viactx.analysis(). Analysis means to evaluate the underlying rule implementation for the inputted targets, and produce the providers that the rule defined for the target. A common workflow is to inspect the resulting providers, and perhaps ensure parts of these providers or run actions using information from the providers (see Actionsbelow). "},{"title":"Query​","type":1,"pageTitle":"BXL Basics","url":"/docs/developers/bxl_basics/#query","content":"Buck2 supports a couple different query types: querying the unconfigured graph (buck2 uquery), the configured graph (buck2 cquery), or the action graph (buck2 aquery). These queries are all available in BXL as well: ctx.uquery() returns abxl.UqueryContextctx.cquery() returns abxl.CqueryContextctx.aquery() returns abxl.AqueryContext You can read more about the individual queries in the API docs. There are many queries that are common between uquery, cquery, and aquery, but cquery and aquery will have extra queries unique to the configured graph or the action graph. One more thing to call out is the eval() query, which is a special query that takes in the entire query as a string literal. A common use foreval() is to migrate a complex query from Buck2 CLI to BXL by dropping the entire query string directly into eval(). The query results are target sets (iterable container) ofbxl.UnconfiguredTargetNodes for uquery, bxl.ConfiguredTargetNodesfor cquery, and bxl.ActionQueryNodes for aquery. Each of these node types have accessors on their attributes. A common workflow is to run some query in BXL, and iterate through the resulting nodes to inspect their attributes, and use those attributes to inform further computations in BXL. Uquery​ Querying the unconfigured graph means that no configurations (such as platforms and transitions) have been applied to the target graph yet. This means that it's very possible that some parts of the target graph is broken due to lack of configurations. Generally to avoid this problem, cquery may be preferred instead. Cquery​ Querying the configured graph means that configurations have been applied to the target graph. For cquery, we require that users use atarget universe for their query inputs. Aquery​ Aquery is a quite different from uquery and cquery. It is used to query the action graph, which is constructed after Buck2 runs analysis on the targets and produces the list of providers and actions needed to build the target. "},{"title":"Actions​","type":1,"pageTitle":"BXL Basics","url":"/docs/developers/bxl_basics/#actions","content":"You can create actions directly within the BXL API. The available action APIs are equivalent to the ones found on the actions type for normal rules, with the caveat thatdynamic actions use thebxl.Context (which provides richer functionalities). A common workflow would be to run analysis on a target, and use some interesting bits found in the analysis result to construct an augmentedcmd_args to run, and then ensure the action's output (see below for ensuring). Also seeRunning actions. "},{"title":"Ensure​","type":1,"pageTitle":"BXL Basics","url":"/docs/developers/bxl_basics/#ensure","content":"Ensuring an artifact means that you want the artifact to be materialized (meaning, downloaded to your machine) at the end of the BXL execution. There are two APIs for ensuring: ctx.output.ensure() and ctx.output.ensure_multiple()(see bxl.OutputStream). As the naming indicates, the former is for ensuring a single artifact, and the latter is for ensuring multiple artifact-like inputs. Artifact-like inputs includecmd_args (can be found when inspecting providers),bxl.BuildResult (produced when building something in BXL), or artifact (can be found when inspecting providers, or creating your own actions). A common workflow is to ensure an artifact that you created via some custom actions defined in your script, or ensuring some artifacts found in the providers after running analysis. Also seeWhat do I need to know about ensured artifacts. "},{"title":"Architectural Model","type":0,"sectionRef":"#","url":"/docs/developers/architecture/buck2/","content":"","keywords":""},{"title":"High-level Overview​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#high-level-overview","content":"Buck2 is a build system whose core is written in Rust. Starlark, which is a deterministic, immutable version of Python, is used to extend the Buck2 build system, enabling Buck2 to be language-agnostic. The high-level flow starts with a user creating a build file (a BUCK file) containing one or more targets, which is specified by the target label, its inputs (sources, attributes, configurations, and dependencies), and the type of macro or rule to use. Briefly, a macro is a wrapper around a rule, which runs necessary commands to generate what’s needed for a target (for example, for a cxx_binary target, generate the header map and run necessary clang commands). Macros can be used to reduce boilerplate code for users (such as to supply the same set of attributes for a rule for all targets). Macros and rules are both written in Starlark and are specified by input sources, attributes, and the implementation function. If the target type is a macro, then the macro will fill in some details (for example, for a cxx_binary target, these are the compilation, debug flags to use, this is the clang to use). If the target type is a rule, then the macro layer is skipped altogether. This is all orchestrated by the core, which performs operations such as executing Buck2 CLI args, generating/updating the dependency graph (which contains the configured target nodes, unconfigured target nodes, action nodes, among other types of nodes that all allow for incrementality and execution), and materializing the artifacts. The core is written in Rust. The following diagram shows the high-level overview.  The Buck2 CLI runs in a client process, which sends commands to the Buck2 daemon via gRPC. The daemon goes through several phases after receiving a request from the client: evaluation, configuration, analysis, execution, and materialization (see Execution Model, below). When usingbuck2 test, there is a final stage for testing. Note that these are the phases that a build goes through, but they are not always sequential. After finishing all phases, the daemon will send the response back to the client via gRPC. "},{"title":"Execution Model​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#execution-model","content":"The following diagram shows the Execution Model, which consists of 5 phases and states.  Each of the phases and states shown in the Execution Model, are detailed in the following sub-sections. "},{"title":"State 0 - Build Files​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#state-0---build-files","content":"Build files (commonly referred to as BUCK files, their default name) are the main input to Buck2 and are syntactically Python. Each build file is uniquely identified by the directory in which it's located. Since all build files have the same name, there cannot be two build files in the same directory. This is usually represented as the relative path from the root of the project (the directory where the .buckconfig file is). Each build file has a set of targets. These describe the things the user wants Buck2 to know about. Each target has a type and a set of named attributes, including at least a name (also known as the label) identifying it. Additional attributes depend on the type of the target. "},{"title":"Phase A: Evaluation​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#phase-a-evaluation","content":"First, Buck2 evaluates a build file, and then constructs an unconfigured target graph. Buck2 performs directory listings to discover packages, then evaluates the build files that were found, expands any macros detected into their underlying rules, and then will take rule attributes and convert them from Starlark to Rust types to construct a target node, and insert it into the unconfigured target graph, which is a smaller portion of Buck2’s larger dependency graph. The target node consists of a reference to rule implementation, and the set of attributes and sources. The result of evaluation is a list of targets read from the build file mapped to a target node in Buck2 unconfigured target graph. "},{"title":"State 1 - Unconfigured Target Graph is generated​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#state-1---unconfigured-target-graph-is-generated","content":"At this point, the unconfigured target graph is available for the next stage of transformation, which is to configure the target nodes within the graph. "},{"title":"Phase B: Configuration​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#phase-b-configuration","content":"At the end of evaluation, the target nodes are not yet configured. Configuration means applying a list of constraints (such as resolving selects to specify the right CPU) to make sure the target can be run where it needs to. This is also known as target platform resolution, and can be configured within the target, the buckconfig, propagated from dependencies, or passed into the CLI. After applying configurations, the target nodes are transformed into configured target nodes within the Buck2 configured target graph, which is a smaller portion of Buck2’s larger dependency graph. "},{"title":"State 2 - Configured Target Graph is generated​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#state-2---configured-target-graph-is-generated","content":"At this point, the configured target graph is available for the analysis stage to generate the action graph. "},{"title":"Phase C: Analysis​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#phase-c-analysis","content":"In the analysis phase, Buck2 constructs a context object (ctx) which contains relevant information (such as attributes pulled from the configuration stage), all converted into Starlark types and made available to the rule. For example, the target’s dependencies are turned into a ProviderCollection, source files are converted into StarlarkArtifacts, and String attributes are turned into aStarlarkString. This ctx object is backed by Buck2’s dependency graph for computation and rules use it to tell Buck2 to run actions, create dynamic actions, or create new files. The rule will return a list of providers, which is data that the rule wants to expose to its dependents (that is, can flow through the dependency graph), such as output artifact information (such as file paths and file hashes). Providers could be actions, source files, or attributes. Within the returned list, DefaultInfo always needs to be returned, which indicates what the default outputs are. Some other common built-in providers include RunInfo, TestInfo, and InstallInfo. The end result is a list of providers and actions (inserted into the action graph) that Buck2 needs to execute to produce the desired outputs, known as 'bound artifacts'. "},{"title":"State 3 - Action Graph and Providers are generated​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#state-3---action-graph-and-providers-are-generated","content":"At this point, the action graph and providers are available to be processed by the execution stage. "},{"title":"Phase D: Execute​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#phase-d-execute","content":"Execution is where Buck2 takes all the providers (input files from the targets, args from the command line), runs the actions, and then outputs the computed results. The critical path is the theoretical lower bound for the duration of a build, which are the slowest set of actions. Buck2 can be run locally or on remote execution, or in a hybrid manner. For each action, a digest is created which is a hash of an action's command and all its inputs. Buck2 then checks if there is a result cached within RE for an action with a given digest. If there is a cache hit, Buck2 does not need to run the command for the action. Instead, the RE returns the output action digest. This digest can be used to download the actual output artifacts at a later time. This is known as the RE action cache. If there is a cache miss, the action needs to be run either remotely or locally. If Buck2 decides to run the action remotely, it will first upload all of the action's inputs that are missing from the RE's content addressable storage. If Buck2 decides to run the action locally, it will first download and materialize in buck-out all of the action's inputs. These inputs might be outputs of other actions and are stored in RE's content addressable storage but are missing on the local machine.Only after those steps will Buck2 schedule the action for actual execution. Buck2 can also decide to run local and remote execution simultaneously (a process known as racing), and use the result of whichever action finishes first to speed up performance. This strategy is known as hybrid execution.&quot; Materialization of action outputs (which involves downloading and placing them in the correct location in buck-out) can be done immediately after the action has finished executing. Alternatively, it can be deferred until it is actually needed for the local execution of another action. There are various configurations that a user can set to control how this materialization is handled. "},{"title":"State 4 - Build outputs are generated​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#state-4---build-outputs-are-generated","content":"At this point, the build is complete. If a user ran buck2 test, then there is a final transformation for Buck2 to construct a command for TPX to execute the actual test. "},{"title":"Phase E: Execute tests​","type":1,"pageTitle":"Architectural Model","url":"/docs/developers/architecture/buck2/#phase-e-execute-tests","content":"For more detail on testing, reviewTest Execution. "},{"title":"FAQs","type":0,"sectionRef":"#","url":"/docs/developers/bxl_faqs/","content":"","keywords":""},{"title":"When is my BXL script cached?​","type":1,"pageTitle":"FAQs","url":"/docs/developers/bxl_faqs/#when-is-my-bxl-script-cached","content":"The entire BXL script is represented as a single node on the DICE graph (Buck2’s internal dependency graph). When the script’s input changes, the entire node is invalidated and needs to be recomputed. For example, if a BXL function calls uquery, then uses the result to do a cquery and then a build, if Buck2 detects that any of the recorded calls to uquery, cquery, and build changes, then the entire BXL script will be reran. The computations themselves (uquery, cquery, and build) will still be incrementally evaluated via DICE, so we are not rerunning every computation entirely within the BXL. When the BXL script creates artifacts and ensures them, those artifacts are cached separately in an action outside of the BXL execution. This means that the artifacts produced by BXL are cached separately from the BXL script itself, much like the computations within a BXL. During 2023, there is a plan to add finer grain incrementality to make better use of DICE’s existing incrementality support. "},{"title":"What’s the difference between ctx.output.print() and print()?​","type":1,"pageTitle":"FAQs","url":"/docs/developers/bxl_faqs/#whats-the-difference-between-ctxoutputprint-and-print","content":"ctx.output.print() writes items to stdout by buck2 even when the script is cached. Items written to the output stream are considered to be the results of a BXL script, which will be displayed to stdout by buck2 even when the script is cached.print() is offered by Starlark via the stdlib. This prints anything you want but won’t be provided to stdout at the end of a BXL script. These can be used to print to stderr. NOTE: print() statements don't show up if the script has been cached. "},{"title":"What do I need to know about ensured artifacts​","type":1,"pageTitle":"FAQs","url":"/docs/developers/bxl_faqs/#what-do-i-need-to-know-about-ensured-artifacts","content":"An ensured_artifact prints out the relative or absolute path viactx.output.print(), depending on if called with abs_path() or rel_path(), but will print out &lt;ensured artifact bound to &lt;some path&gt;&gt; via print(). This is intentional because when the ensured artifact is created within BXL, it has not been materialized yet. It will be materialized after the BXL script finishes executing, and Buck2 core performs some additional actions after the BXL script. This is a safeguard to prevent people from misusing the artifact path and passing it into an action without the artifact having been materialized or passing an absolute path into RE, which can actually mess up RE and render the action not shareable across users. In addition, it makes these actions separately cacheable from the BXL execution. "},{"title":"What is the difference between dynamic outputs and anon targets?​","type":1,"pageTitle":"FAQs","url":"/docs/developers/bxl_faqs/#what-is-the-difference-between-dynamic-outputs-and-anon-targets","content":"Dynamic outputs are meant fordynamic dependencies. The context type is a bxl_ctx. Dynamic outputs are ran asynchronously outside of the BXL execution. Anon targets are meant for sharing work betwen multiple BXLs. The context type is a normal rule analysis context. Anon targets are await-ed inline with your BXL function. "},{"title":"Can I mutate types returned by BXL APIs?​","type":1,"pageTitle":"FAQs","url":"/docs/developers/bxl_faqs/#can-i-mutate-types-returned-by-bxl-apis","content":"The data types produced by BXL API calls are always immutable. "},{"title":"What is run synchronously vs asynchronously?​","type":1,"pageTitle":"FAQs","url":"/docs/developers/bxl_faqs/#what-is-run-synchronously-vs-asynchronously","content":"Starlark itself is run synchronously. However, certain BXL APIs are evaluated asynchronously. If you pass in multiple inputs to builds, queries, or analyses, the execution of these API calls will be blocking, but the inputs themselves will be evaluated in parallel within the execution. Ensuring artifacts, dynamic outputs, anon targets, and resolving promises will happen after the Starlark script is executed. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/developers/bxl_getting_started/","content":"","keywords":""},{"title":"Navigating the docs​","type":1,"pageTitle":"Getting Started","url":"/docs/developers/bxl_getting_started/#navigating-the-docs","content":"All BXL APIs can be found here. A good place to start would be the bxl.Context, which contains all available BXL functionalities. All Build APIs are mirrored to the BXL APIs section. The Starlark specis also a good resource for general Starlark APIs. "},{"title":"Writing a BXL​","type":1,"pageTitle":"Getting Started","url":"/docs/developers/bxl_getting_started/#writing-a-bxl","content":"To create a BXL, first, create a script somewhere in the repository ending in.bxl. (Note that you can define a single bxl per file, or multiple BXLs per file like in Starlark rules). In it, define a BXL function as follows: def _your_implementation(ctx): # ... pass your_function_name = bxl_main( impl = _your_implementation, cli_args = { # cli args that you want to receive from the command line &quot;bool_arg&quot;: cli_args.bool(), &quot;list_type&quot;: cli_args.list(cli_args.int()), &quot;optional&quot;: cli_args.option(cli_args.string()), &quot;target&quot;: cli_args.target_label(), }, )  This exposes your_function_name as a function, with whatever arguments you defined it, so that on the command line you can invoke: buck2 bxl //myscript.bxl:your_function_name -- --bool_arg true --list_type 1 --list_type 2 --target //foo:bar`  You can also add helpdocs to the cli args and get them to show up in cli via--help: def _your_implementation(ctx): # ... pass your_function_name = bxl_main( impl = _your_implementation, cli_args = { &quot;my_bool&quot;: cli_args.bool(True, &quot;this will be printed as part of `--help`&quot;) }, )  The implementation function takes a single context as parameter (see the documentation for bxl.Context). Using it, you'll be able to access functions that enable you to perform queries, analysis, builds, and even create your own actions within BXL to build artifacts as part of a BXL function. The primary method to return information from BXL is to either print them, or build some artifact (for details, see thebxl.OutputStream documentation, available as part of ctx.output). At high level, ctx.output.print(..) prints results to stdout, and ctx.output.ensure(artifact) marks artifacts as to be materialized into buck-out by the end of the BXL function, returning an object that lets you print the output path via ctx.output.print(ensured). "},{"title":"Running a BXL​","type":1,"pageTitle":"Getting Started","url":"/docs/developers/bxl_getting_started/#running-a-bxl","content":"To run a BXL function, invoke the buck2 command: buck2 bxl &lt;bxl function&gt; -- &lt;function args&gt;  Where &lt;bxl function&gt; is of the form &lt;cell path to function&gt;:&lt;function name&gt;, and &lt;function args&gt; are the arguments that the function accepts from the command line. The documentation for a BXL function can be seen by running:  buck2 bxl &lt;bxl function&gt; -- --help`  Note that this is different from buck2 bxl --help, which generates the help for the buck2 command instead of the function. "},{"title":"Why BXL","type":0,"sectionRef":"#","url":"/docs/developers/bxl/","content":"","keywords":""},{"title":"Buck2 Extension Language (BXL)​","type":1,"pageTitle":"Why BXL","url":"/docs/developers/bxl/#buck2-extension-language-bxl","content":"BXL is a Starlark-based script that enables integrators to inspect and interact with the Buck2 graph. Integrators are able to: Write Starlark code that queries, analyzes, and builds on the Buck2 graph.Introspect and interact with the Buck2 graph structures natively, via Starlark, in a safe, controlled manner. Introspection of the Buck2 graph can occur at the unconfigured, configured, providers, and action stages. There are also APIs offered to allow BXL to accept custom command line argument, output artifacts, and print results to stdout. BXL leverages Buck2 core's incrementalcaching. It also has support forrunning actions,dynamic outputs, andanonymous targets. In addition, BXL hasprofilingcapabilities, and allows users to add their own telemetrydirectly within the BXL scripts. BXL is considered to be mostly stable, with a bit more active development here and there. "},{"title":"When should I use BXL over Buck2 API/CLI?​","type":1,"pageTitle":"Why BXL","url":"/docs/developers/bxl/#when-should-i-use-bxl-over-buck2-apicli","content":"There are many overlaps between BXL and Buck2 (for example, both can run cquery and both can build targets). It’s possible that one use case could be handled by both BXL and Buck2. Following are some specific recommendations to help decide when to use BXL over regular Buck2: Use/inspect resolved attributes that are not exposed/accessible to users via normal Buck2 operations. This includes introspecting the Starlark object of providers, analyzing the Starlark object of a rule’s attr before and after coercing and resolution, and introspecting intermediate query results. Reduce/eliminate the need to make several Buck2 calls within your program, such as running several subprocesses to call cquery several times. With BXL, you can just call the BXL script once in a subprocess, potentially reducing the amount of code you need to write in your program. For example, if you need to call cquery and build several times, you can put that all within a single BXL script and run buck2 bxl once, rather than runningbuck2 cquery and buck2 build several times. Reduce/eliminate the need to manually parse Buck2 output format within your program, and any bugs that may come with manual parsing. Some languages are more verbose than others when it comes to string parsing.BXL scripts are written in Starlark, which is basically a deterministic, immutable Python. BXL is able to directly introspect Starlark objects (such as rules and target nodes, and so on) and call methods on these objects instead of parsing them over Buck2’s output. "},{"title":"Example Use Cases​","type":1,"pageTitle":"Why BXL","url":"/docs/developers/bxl/#example-use-cases","content":""},{"title":"Generate a project for IDE​","type":1,"pageTitle":"Why BXL","url":"/docs/developers/bxl/#generate-a-project-for-ide","content":"IDE project generation is roughly as follows: Form the target graph for the project targetPerform some filtering on the graph targets if needed. This depends on the target's configuration.For each target, generate the project target metadata, including: compiler flagslinker flagspaths to generated filesinputs and outputs for each targetsthe paths relative to some PATH Write a single file translating this metadata into a format understood by the IDE An example BXL flow for generating a project for IDE might be: Add some command line arguments to accept a target (or subtarget) to generate the projectRun analysis on the project target with a specific configuration to filter the graph targetsFor each resulting target, inspect the providers and attributes to extract the required metadata information. BXL uses filesystem operations to handle paths within the projectRun actions based on the linker/compiler flags, and build artifacts as needed to generate a projectWrite a single file containing the metadata obtained from previous steps "},{"title":"Build an LSP​","type":1,"pageTitle":"Why BXL","url":"/docs/developers/bxl/#build-an-lsp","content":"A compilation database is a database containing information about which compile options are used to build the files in a project. Language Server Protocols (LSPs) uses the compilation database to provide language features like auto complete, go to definition, and find all references for the user within an IDE/editor. An example BXL flow for building a C++ LSP might be: Add a command line argument to accept a fileRun owners cquery in BXL to get the owning target of the fileRun analysis on the owning target to get the desired clang flagsUse BXL to write the clang flags to the disk in compilation database format "},{"title":"Perform graph analysis​","type":1,"pageTitle":"Why BXL","url":"/docs/developers/bxl/#perform-graph-analysis","content":"Some example graph analysis functionalities might be: Run an analysis in BXL on a set of targets, and then inspect their providers, and build some subtargetsRun a uquery on some set of targets, and inspect the resulting nodes' coerced attributesRun a cquery on some set of targets with a specific configuration, and inspect the resulting nodes' attributes before and after resolution "},{"title":"Buck 2 specific options","type":0,"sectionRef":"#","url":"/docs/developers/options/","content":"Buck 2 specific options Buck 2 introduces some options that don't exist in v1 and are accessed in the root cell: project.watchman_merge_base: defines the merge base to use for SCM-aware queries to Watchman. This is read when the daemon starts and cannot be changed later without a restart.test.v2_test_executor: defines the program to invoke as the test executor inbuck test. This is read every time a test command executes.","keywords":""},{"title":"BXL Telemetry","type":0,"sectionRef":"#","url":"/docs/developers/bxl_telemetry/","content":"","keywords":""},{"title":"Telemetry​","type":1,"pageTitle":"BXL Telemetry","url":"/docs/developers/bxl_telemetry/#telemetry","content":""},{"title":"Emitting events from your BXL script​","type":1,"pageTitle":"BXL Telemetry","url":"/docs/developers/bxl_telemetry/#emitting-events-from-your-bxl-script","content":"In BXL, you can emit custom events via ctx.instant_event(), which takes in two named parameters: id: string, identifies your event. Helpful to identify your event when looking through event logs. Ids do not have to be unique in a single BXL script.metadata: dict, where keys are strings, and values are strings, bools, ints, or lists/dicts of the mentioned types. You can put any metadata you wish here. Example: def _impl(ctx): ctx.instant_event(id = &quot;id1&quot;, metadata = {&quot;foo&quot;: &quot;bar&quot;}) my_script = bxl_main( impl = _impl, cli_args = {}, )  Only instant events can be manually created within BXL at this time, which means that the event represents a single point in time. If you need something similar to spans (start and end events which encompass a range of time) for measuring the duration of a particular section (excluding actions - see below for more information), you could couple instant events with the global now() function to measure the duration yourself: def _impl(ctx): instant = now() # do something time intensive end = instant.elapsed_millis() ctx.instant_event(id = &quot;id1&quot;, metadata = {&quot;duration&quot;: end}) # do something else time intensive end = instant.elapsed_millis() ctx.instant_event(id = &quot;id2&quot;, metadata = {&quot;duration&quot;: end}) my_script = bxl_main( impl = _impl, cli_args = {}, )  Measuring time for actions and ensuring artifacts You cannot use now() to measure the time it takes to run actions and ensure artifacts because these processes occur asynchronously outside of the BXL script execution. For BXL user telemetry, we emit action events via the buck2 core automatically. Events around ensuring the artifacts are not emitted currently, but will be added soon. "},{"title":"User event log​","type":1,"pageTitle":"BXL Telemetry","url":"/docs/developers/bxl_telemetry/#user-event-log","content":"To write to your own event log when running BXL, you can run your BXL command with the --user-event-log flag to tell buck2 where to write the events to. Buck2 is aware of the following file extensions: .json-lines,json-lines.zst, .json-lines.gz, and will compress the files automatically for you depending on the extension. If the extension is not one of these, the logs will always be written in JSONL format, uncompressed. Example: buck2 bxl path//to/my_script/script.bxl:my_script --user-event-log my_file.json-lines.gz  When using this flag to write to a custom event log, it is up to you to clean up these log files. In addition, if the same filename is used with subsequent BXL invocations, events are always appended to the existing file contents, which is the same behavior as buck2 &lt;any command&gt; --event-log &lt;path&gt;. If you tell buck2 to write to a compressed file, you are responsible for decompressing them. "},{"title":"Getting a user event log from a normal event log​","type":1,"pageTitle":"BXL Telemetry","url":"/docs/developers/bxl_telemetry/#getting-a-user-event-log-from-a-normal-event-log","content":"buck2 log show-user can be used to convert a normal event log (regardless of encoding/compression) to a user event. Similar to buck2 log show, you can choose the most recent invocation, or the nth invocation, or provide a path to the normal user event log. Note that user event logs are not able to be passed into buck2 log show or buck2 log show-user. "},{"title":"Event log output​","type":1,"pageTitle":"BXL Telemetry","url":"/docs/developers/bxl_telemetry/#event-log-output","content":"The first line of your event log will always be the invocation record, which contains useful things like command line args used, working directory, etc. The subsequent lines are either instant events and/or action events, depending on your BXL script's contents. Instant event Sample: { &quot;StarlarkUserEvent&quot;: { &quot;id&quot;: &quot;foo&quot;, &quot;metadata&quot;: { &quot;bool_value&quot;: true, &quot;string_value&quot;: &quot;str&quot;, &quot;int_value&quot;: 123, &quot;list_value&quot;: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ], &quot;dict_value&quot;: { &quot;foo&quot;: &quot;bar&quot; } }, }, &quot;epoch_millis&quot;: 123456789 # when the event was emitted }  Action event { &quot;ActionExecutionEvent&quot;: { &quot;kind&quot;: &quot;Write&quot;, # kind of action, like write or run &quot;name&quot;: { # name of the action, for user display. Unique within the execution of a particular target &quot;category&quot;: &quot;write&quot;, # category for the action &quot;identifier&quot;: &quot;my_output&quot; # identifier for the action }, &quot;duration_millis&quot;: 0, # duration of the action in millis, excluding input materialization time &quot;output_size&quot;: 10, # size in bytes of the action's outputs &quot;input_materialization_duration_millis&quot;: 0, # how long it took to materialize any inputs to the action &quot;execution_kind&quot;: &quot;Simple&quot;, # how the action was executed &quot;owner&quot;: &quot;cell//path/to/script.bxl:function_name&quot; # owner of the action execution (target label, anon target label, bxl label) }, &quot;epoch_millis&quot;: 123456789 # when the event was emitted }  execution_kind includes: Local: action was executed locallyRemote: action was executed via a remote executorActionCache: action was served by the action cache and not executedSimple: action is simple and executed inline within buck2 (ex: write, symlink_dir)Skipped: action was not executed at allDeferred: action logically executed, but didn't do all the workLocalDepFile: action was served by the local dep file cache and not executed.LocalWorker: action was executed via a local workerNotSet: action execution kind was not set Ensure artifact event { &quot;BxlEnsureArtifactsEvent&quot;: { &quot;duration_millis&quot;: 0, # duration of ensuring the artifact }, &quot;epoch_millis&quot;: 123456789 # when the event was emitted }  "},{"title":"Request for Comments","type":0,"sectionRef":"#","url":"/docs/developers/request_for_comments/","content":"","keywords":""},{"title":"Drafts​","type":1,"pageTitle":"Request for Comments","url":"/docs/developers/request_for_comments/#drafts","content":"@configuration syntaxbxl actions and Build APIDigest Kindslabels -&gt; metadata attribute "},{"title":"Accepted​","type":1,"pageTitle":"Request for Comments","url":"/docs/developers/request_for_comments/#accepted","content":"configured_aliasBuck Extension Language (BXL)Bxl Support for performing analysis on targetsPackage-local values "},{"title":"Implemented​","type":1,"pageTitle":"Request for Comments","url":"/docs/developers/request_for_comments/#implemented","content":"ProviderCollection[] "},{"title":"BXL and Dynamic Outputs","type":0,"sectionRef":"#","url":"/docs/developers/dynamic_output/","content":"","keywords":""},{"title":"Dynamic output​","type":1,"pageTitle":"BXL and Dynamic Outputs","url":"/docs/developers/dynamic_output/#dynamic-output","content":"When declaring dynamic outputs within a BXL script, the dynamic lambda for is created with a bxl_ctx, which means that you can do things like run analysis or queries to inspect the build graph from within the dynamic lambda. You may declare multiple dynamic outputs within a single BXL script, or declare nested dynamic outputs. Dynamic outputs are run asynchronously after the BXL evaluation. "},{"title":"Limitations​","type":1,"pageTitle":"BXL and Dynamic Outputs","url":"/docs/developers/dynamic_output/#limitations","content":"ctx.output is not available from a dynamic lambda. This means you can’t ensure artifacts or print cached outputs within a dynamic lambda.Error messages from skipping incompatible targets are only emitted to the console, and not cached in the stderrbuild() is not available from a dynamic lambdabxl_actions in a dynamic lambda always inherits the execution platform resolution of the root/parent BXL. The expected usage of bxl_actions from within a dynamic lambda is to instantiate it without any named parameters, but the exec_deps andtoolchains of the execution platform resolution are accessible, and return the same values as the root/parent BXL Profiling is not hooked up to dynamic BXL context "},{"title":"Silly example​","type":1,"pageTitle":"BXL and Dynamic Outputs","url":"/docs/developers/dynamic_output/#silly-example","content":"This is a silly example of creating a dynamic output which reads somequery_params input, calls some BXL functions like uquery,configured_targets to get the resolved attributes of a target node, and then writes the attributes to an output file. def _impl_dynamic_output(ctx): actions = ctx.bxl_actions().actions # Declare some input here to read within the lambda query_params = actions.write_json(&quot;query_params&quot;, {&quot;rule_type&quot;: &quot;apple_bundle&quot;, &quot;universe&quot;: &quot;fbcode//buck2/tests/...&quot;}) # Dynamic lambda's output artifact resolved_attrs = actions.declare_output(&quot;resolved_attrs&quot;) # Dynamic lambda function to be used in the dynamic_output def my_deferred(ctx, artifacts, outputs): # Read the input, then do some BXL things here params = artifacts[query_params].read_json() target = ctx.uquery().kind(params[&quot;rule_type&quot;], params[&quot;universe&quot;])[0] node = ctx.configured_targets(target.label) eager_attrs = node.resolved_attrs_eager(ctx) # Dynamic BXL context's `bxl_actions` does not take in named parameters because it inherits the exec platform resolution from the root/parent BXL. If the root BXL's `bxl_actions` were created with exec deps/toolchains, you can access them using `exec_deps` and `toolchains` attributes here ctx.bxl_actions().actions.write(outputs[resolved_attrs], str(eager_attrs)) actions.dynamic_output( dynamic = [query_params], inputs = [], outputs = [ resolved_attrs, ], f = my_deferred, ) ctx.output.print(ctx.output.ensure(resolved_attrs).abs_path()) dynamic_output_example = bxl_main( impl = _impl_dynamic_output, cli_args = { }, )  "},{"title":"Common How-Tos","type":0,"sectionRef":"#","url":"/docs/developers/bxl_how_tos/","content":"","keywords":""},{"title":"Passing in and using CLI args​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#passing-in-and-using-cli-args","content":"A BXL function can accept a cli_args attribute where args names and types are specified to use within your script, as shown in the following example: Example: def _impl_example(ctx): # ... pass example = bxl_main( impl = _impl_example, cli_args = { # cli args that you want to receive from the command line &quot;bool_arg&quot;: cli_args.bool(), &quot;list_type&quot;: cli_args.list(cli_args.int()), &quot;optional&quot;: cli_args.option(cli_args.string()), &quot;target&quot;: cli_args.target_label(), }, )  On the command line, you can invoke the arguments as follows: buck2 bxl //myscript.bxl:example -- --bool_arg true --list_type 1 --list_type 2 --target //foo:bar  For BXL functions, to read the arguments, use them as attributes from thecli_args attribute on the BXL ctx object, as follows: def _impl_example(ctx): my_bool_arg = ctx.cli_args.bool_arg  "},{"title":"Running actions​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#running-actions","content":"You can create actions within BXL via the actions_factory. This is called once globally then used on demand: def _impl_example(ctx): actions = ctx.bxl_actions().actions # call once, reuse wherever needed output = actions.write(&quot;my_output&quot;, &quot;out&quot;)  You will need to haveexecution platformsenabled for your project, or else you will get an error. You can specify the execution platform resolution by setting named parameters when instantiatingbxl_actions: exec_deps - These are dependencies you wish to access as executables for creating the action. This is usually the same set of targets one would pass to rule's attr.exec_dep. Accepts a list of strings, subtarget labels, target labels, or target nodes.toolchains - The set of toolchains needed for the actions you intend to create. Accepts a list of strings, subtarget labels, target labels, or target nodes.target_platform - The intended target platform for your toolchains. Accepts a string or target label.exec_compatible_with - Explicit list of configuration nodes (like platforms or constraints) that these actions are compatible with. This is theexec_compatible_with attribute of a target. Accepts a list of strings, target labels, or target nodes. If you specify exec_deps or toolchains, you can access the resolveddependency objects on the bxl_actions object. The bxl_actions object will have exec_deps and toolchains attributes, which are dicts where the keys are the unconfigured subtarget labels, and the values are the configured/resolved dependency objects. Note that the keys of exec_deps and toolchains must be unconfigured subtarget labels (StarlarkProvidersLabel), and not unconfigured target labels. You can use ctx.unconfigured_sub_targets(...) or with_sub_target() ontarget_label to create the label. def _impl_example(ctx): my_exec_dep = ctx.unconfigured_sub_targets(&quot;foo//bar:baz&quot;) # has some provider that you would use in the action bxl_actions = ctx.bxl_actions(exec_deps = [my_exec_dep]) # call once, reuse wherever needed output = bxl_actions.actions.run( [ &quot;python3&quot;, bxl_actions.exec_deps[my_exec_dep][RunInfo], # access resolved exec_deps on the `bxl_actions` out.as_output(), ], category = &quot;command&quot;, local_only = True, ) ctx.output.ensure(output)  "},{"title":"Getting providers from an analysis​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#getting-providers-from-an-analysis","content":"After calling analysis(), you can get the providers collection fromproviders(): def _impl_example(ctx): my_providers = ctx.analysis(my_target).providers()  "},{"title":"Get a specific provider from an analysis​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#get-a-specific-provider-from-an-analysis","content":"After calling analysis(), you can also get the providers collection fromproviders() then grab whatever specific provider you need: def _impl_example(ctx): default_info = ctx.analysis(my_target).providers()[DefaultInfo] ctx.output.print(default_info)  "},{"title":"Get a specific subtarget from an analysis​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#get-a-specific-subtarget-from-an-analysis","content":"Once you have a provider, you can get its subtargets by using the sub_targetsattribute on the struct to get a dict of provider labels to provider collections: def _impl_example(ctx): subtarget = ctx.analysis(my_target).providers()[DefaultInfo].sub_targets[&quot;my_subtarget&quot;] ctx.output.print(subtarget)  "},{"title":"Building a target/subtarget without blocking​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#building-a-targetsubtarget-without-blocking","content":"ctx.build is synchronous and should only be used when the result of the build is needed inline during the bxl execution. To execute builds without blocking the script, retrieve the DefaultInfo from the target's providers and use thectx.output.ensure_multiple api. Example: ctx.output.ensure_multiple(ctx.analysis(label).providers()[DefaultInfo])  "},{"title":"Getting attributes or resolved attributes efficiently on a configured target node​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#getting-attributes-or-resolved-attributes-efficiently-on-a-configured-target-node","content":"If you need to use all of the attrs/resolved_attrs, then initializing the eager variant once would be best. If you only need a few of the attrs, then initializing the lazy variant is better. There’s not really a hard line, it depends on the target node, and which attrs you are looking for. If performance is key to your BXL script, the best way to determine this is to use the BXL profiler. Regardless, if you use eager or lazy versions of getting attributes, you should cache the attrs object: def _impl_example(ctx): my_configured_node = ctx.configured_targets(&quot;:foo&quot;) # call once and resue, ideally when you need most/all attrs eager = my_configured_node.attrs_eager() # call once and reuse, ideally when you only need a few attrs lazy = my_configured_node.attrs_lazy() # call once and reuse, ideally when you need most/all resolved attrs resolved_eager = my_configured_node.resolved_attrs_eager(ctx) # call once and reuse, ideally when you only need a few resolved attrs resolved_lazy = my_configured_node.resolved_attrs_lazy(ctx)  "},{"title":"Inspecting a struct​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#inspecting-a-struct","content":"You can use dir(my_struct) to inspect a struct. You can also usegetattr(my_struct, &quot;my_attr&quot;) to grab individual attributes, which is equivalent to my_struct.my_attr. These are available as part of theStarlark language spec. "},{"title":"Set addition/subtraction on a target_set​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#set-additionsubtraction-on-a-target_set","content":"There are a few BXL actions that return a target_set (such as a cqueryeval()). The target_set supports set subtraction and addition (you can use- and + directly in Starlark). "},{"title":"Initializing configured/unconfigured target_set​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#initializing-configuredunconfigured-target_set","content":"You can use following apis to initialize target_set def bxl.utarget_set(nodes: None | list[bxl.UnconfiguredTargetNode]) -&gt; bxl.UnconfiguredTargetSet  def bxl.ctarget_set(nodes: None | list[bxl.ConfiguredTargetNode]) -&gt; bxl.ConfiguredTargetSet  "},{"title":"Profiling, Testing, and Debugging a BXL script​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#profiling-testing-and-debugging-a-bxl-script","content":"You can use buck2 bxl profiler, with various measurements, to determine where the script is least efficient. To time individual pieces of the script, you can use BXL’s timestamp methods: def _impl_example(_ctx): start = now() # call once and reuse wherever is necessary # do something time intensive here end1 = start.elapsed_millis() # do something else time intensive here end2 = start.elapsed_millis()  Debug - the common way to debug a BXL script is with print statements (print(), pprint() and ctx.output.print()). Test - BXL does not have a robust testing framework for mocking. The main method to test a BXL script is to actually invoke it with required inputs then verify the outputs. "},{"title":"Getting the path of an artifact as a string​","type":1,"pageTitle":"Common How-Tos","url":"/docs/developers/bxl_how_tos/#getting-the-path-of-an-artifact-as-a-string","content":"The starlark artifact type encapsulates source artifacts, declared artifacts, and build artifacts. It can be dangerous to access paths and use them in further BXL computations. For example, if you are trying to use absolute paths for something and end up passing it into a remotely executed action, the absolute path may not exist on the remote machine. Or, if you are working with paths and expecting the artifact to already have been materialized in further BXL computations, that would also result in errors. However, if you are not making any assumptions about the existence of these artifacts, you can use useget_path_without_materialization(), which accepts source, declared, or build aritfacts. It does not accept ensured artifacts (also seeWhat do I need to know about ensured artifacts). For getting paths of cmd_args() inputs, you can useget_paths_without_materialization(), but note this is risky because the inputs could contain tsets, which, when expanded, could be very large. Use these methods at your own risk. "},{"title":"Starlark Language Specification","type":0,"sectionRef":"#","url":"/docs/developers/starlark/spec/","content":"Starlark Language Specification The Starlark language spec can be found in theBazel GitHub repository.","keywords":""},{"title":"Environments","type":0,"sectionRef":"#","url":"/docs/developers/starlark/environment/","content":"Environments Some of the information within this page is outdated. However, the explanation of the problem, and thought process behind it, remains useful. The storage of values is similar but implemented using different types. ::: Starlark (with a nested def) has a series of environments that may be active during an evaluation, as illustrated in the following example: x = [] def foo(): y = True def bar(): z = 1 list.append(x, 1) The above example features the following environments: Global environment - defining things like list.appendModule environment - defining xEnvironment of foo - defining yEnvironment of bar - defining z A scope can access variables defined above it, and often mutate them, but not assign them. To unpack that: From the statements inside bar, you can access list.append, x, y, andz.From inside bar, you can mutate the variables to be accessed with statements like list.append(x, 1) (which may also be termed x.append(1)). However, before this module is imported by another module, all of its exports become frozen, which means it isn't possible to mutate a global list, and if foo is called from a different module, then x can't be modified. If bar does x = 1 that defines a local variable x in the function bar, shadowing the global x. As a consequence, you cannot assign to variables defined in an outer scope. Note that assignment after, or even in non-executed conditional branches, introduces a local variable. For example: x = 1 def f(): print(x) if False: x = 2 In the above code, on executing f(), it would complain that x is referenced before assignment, as the assignment x = 2 makes x a local variable. The rest of this document outlines the various types of environments, how they are accessed, and how they are updated. Global Environment​ The global environment is always frozen and consists of functions andtype-values. All things in the global environment are accessed by name. Type-values are things like list.append, which is used when you do eitherlist.append(xs, 1) or xs.append(1), assuming xs is of type list. The available methods for a type can be queried (for example, dir(list)). There are also global functions, such as len, range, and str. Slots​ To optimise evaluation, all variables are accessed by integers, which are known as 'slots'. Many variables can be converted to slots statically during compilation, and those which can't have their slot looked up by name at runtime. The Slots data type is defined as: enum Slots { Frozen(FrozenSlots), Slots(Rc&lt;RefCell&lt;Vec&lt;Option&lt;Value&gt;&gt;&gt;&gt;), } struct FrozenSlots(Arc&lt;Vec&lt;Option&lt;FrozenValue&gt;&gt;&gt;); As featured in the above code: A set of slots are either Frozen, which came from another module behindArc or just normal Slots, which can be manipulated by the current scope (behind a Rc/RefCell for single-threaded use and mutation).Vec is accessed by the slot index.Option refers to whether the slot has been assigned yet (to detect variables referenced before assignment). Module Environment​ The module environment is where the module executes, namely where x is defined above. The module environment can have values added in the following standards-conforming ways: Assignment statements (such as x = 1 or x += 1).For loops (such as the x in for x in []:).Via the load(&quot;a.bzl&quot;, &quot;foo&quot;), which imports foo frozen.Via def foo():, which defines foo in the module environment. Whether adef is frozen or not, when it's executed, its local variables are not frozen. In addition, two non-standards-conforming ways of defining variables are supported: Some modules can be injected as bindings in advance. Given a module foo that is injected, all the bindings of foo will be inserted in this module as frozen.The function load_symbols injects a dictionary of bindings into the module environment. Note that a module has a fixed set of variables (from the standards-conforming ways), a pre-execution set (from the injections) and yet more variables at runtime (via load_symbols). To support that structure, the mapping from name to slot index is tracked in a struct: enum Names { Frozen(FrozenNames), Names(Rc&lt;RefCell&lt;HashMap&lt;String, usize&gt;&gt;&gt;), } struct FrozenNames(Arc&lt;HashMap&lt;String, usize&gt;&gt;); Each name is given an entry in the map with an increasing slot index. A name will only be assigned a slot once, reusing it thereafter. A correspondingSlots data type provides the values associated with those names. Importantly, the Slots can be extended at runtime by the load_symbolsfunction. As with Slots, you can either share things behind an Arc or mutate them behind an Rc/RefCell. Function Environment​ A function can have variables introduced via assignments, for loops, and parameters. No additional variables can be discovered at runtime, so all names can be erased at compile time. A function can also access variables from the functions it is statically nested within, and from the variables at the root of the module. To support this structure, at runtime we pass around the context, defined as: struct Context { names: Names, slots: Vec&lt;Slots&gt;, } The above code contains the mapping of names for the module and the slots for the module and each function. When executed, the inner-most Slots (at the end of slots:) will never be frozen, as that represents the local variables: but any other may be. When a function value is captured in a frozen module, use FrozenContext: struct FrozenContext { names: FrozenNames, slots: Vec&lt;FrozenSlots&gt;, } ## List comprehension environments A list comprehension can be defined as: ```python [x for x in [1,2,3]] In the above code: The statement defines a variable x that is immediately initialised and shadows any other variables x in scope.The variable x cannot be assigned to, other than in the list comprehension, as it only lives inside the comprehension and the comprehension does not permit assignment statements (only expressions). Such names are not available at the top-level, even when defined in the root of a module. List comprehensions are implemented by adding additional entries into theSlots data type. Even when added at the root of a module, such names are not added to Names. Optimisations​ There are a number of optimisations made to the scheme: When freezing a Names or Slots structure, it's important to only freeze a particular mutable variant once, or you duplicate memory unnecessarily. Therefore, the Slots to be Rc&lt;RefCell&lt;(_, Option&lt;FrozenSlots&gt;)&gt;&gt; are augmented, and, similarly, the Names. When freeze is called, the original value is consumed, and the Somevariant is added.Note: it is unsafe to ever access the slots after the freeze. Programs can only assign to the inner-most Slots, and that slots must always be mutable. Therefore, define a local Slots that is always mutable, and a separate AST node for referring to it. For modules, it is important that this mutable local Slots is also in scope since the scope is used to retrieve unknown variables.","keywords":""},{"title":"A Moving Garbage Collector","type":0,"sectionRef":"#","url":"/docs/developers/starlark/gc/","content":"","keywords":""},{"title":"A worked example​","type":1,"pageTitle":"A Moving Garbage Collector","url":"/docs/developers/starlark/gc/#a-worked-example","content":"Given a heap with the following layout: X := Data(&quot;world&quot;) Y := Data(&quot;hello&quot;, X, Y) Z := Data(&quot;universe&quot;)  All of X, Y and Z are memory locations. The Y memory location has both some data of its own (&quot;hello&quot;) and two pointers (X and Y itself). The pointers from outside the heap into the heap are known as roots. Assuming, in the above example, that Y is the only root, then, since Y is used from outside, Y must be moved to the new memory block. Consequently, the data X needs to be copied, but Z can be dropped. Following are the required steps for using a garbage collector: To copy Y, allocate a value in the new heap A with a sentinel value in it (that that sentinel is called a Blackhole). Then, turn Y into aForward(A) pointer, so that if anyone else in this cycle tries to collectY they immediately &quot;forward&quot; to the new value and the data from Y is grabbed so its pointers can be traversed. That results in the following: X := Data(&quot;world&quot;) Y := Forward(A) Z := Data(&quot;universe&quot;) A := Blackhole With Data(&quot;hello&quot;, X, Y) as the current item being processed. Walk the pointers of the current value, performing a garbage collection on each of them. To copy Y, it can be seen that Y points at a Forward(A)node, so there's no need to do anything. To copy X, follow the process starting at step 1, but for X (which ends up at B). Performing that move leads to the following: X := Forward(B) Y := Forward(A) Z := Data(&quot;universe&quot;) A := Blackhole B := Data(&quot;world&quot;) Replace all the pointers with the forwarded value, and write it back over theBlackhole in A. This gives the following: X := Forward(B) Y := Forward(A) Z := Data(&quot;universe&quot;) A := Data(&quot;hello&quot;, B, A) B := Data(&quot;world&quot;) Adjust any roots pointing at Y to point at A and throw away the original heap, which produces the following: A := Data(&quot;hello&quot;, B, A) B := Data(&quot;world&quot;)  These above four steps successfully garbage collects a cyclic data structure, while preserving the cycles and getting rid of the unused data. "},{"title":"Heaps and Heap References","type":0,"sectionRef":"#","url":"/docs/developers/starlark/heaps/","content":"","keywords":""},{"title":"Heaps​","type":1,"pageTitle":"Heaps and Heap References","url":"/docs/developers/starlark/heaps/#heaps","content":"In Starlark, there are three interesting heap-related points of interest: A Heap has Value's allocated on it and cannot be cloned or shared.A FrozenHeap has FrozenValue's allocated on it and cannot be cloned or shared.A FrozenHeapRef is a FrozenHeap that is now read-only and can now be cloned and shared. A FrozenHeapRef keeps a heap alive. While you have a FrozenValue, it is important that you have either the FrozenHeap itself, or more usually, aFrozenHeapRef to it. A FrozenHeap may contains a set of FrozenHeapRef's to keep the FrozenHeaps it references alive. "},{"title":"Heap Containers​","type":1,"pageTitle":"Heaps and Heap References","url":"/docs/developers/starlark/heaps/#heap-containers","content":"Heaps are included in other data types: A Module contains a Heap (where normal values are allocated) and aFrozenHeap (stores references to other frozen heaps and has compilation constants allocated on it). The Heap portion is garbage collected. At the end, when you call freeze, Value's referenced by name in the Module are moved to the FrozenHeap and then then FrozenHeap is sealed to produce aFrozenHeapRef.A FrozenModule contains a FrozenHeapRef.A GlobalsBuilder contains a FrozenHeap onto which values are allocated.A Globals contains a FrozenHeapRef. "},{"title":"Heap References​","type":1,"pageTitle":"Heaps and Heap References","url":"/docs/developers/starlark/heaps/#heap-references","content":"It is important that when a FrozenValue X is referenced by a Value orFrozenValue (for example, included in a list), the heap where X originates is added as a reference to the heap where the new value is being created. As a concrete example in pseudo-code: let h1 = FrozenHeap::new(); let s = &quot;test&quot;.alloc(h1); let h1 : FrozenHeapRef = h1.into_ref(); let h2 = Heap::new(); h2.add_reference(h1); vec![s].alloc(h2);  In the above code, the following steps are taken: Create a FrozenHeap then allocate something in it.Turn the heap into a reference.Use the allocated value s from h1 when constructing a value in h2.For that to be legal, and for the heap h1 to not disappear while it is being allocated, it is important to call add_reference. Note that this API can only point at a FrozenValue from another heap, and only after that heap has been turned into a reference, so it will not be allocated in anymore. These restrictions are deliberate and mean that most programs only have one 'active heap' at a time. Following are some places where heap references are added by Starlark: Before evaluation is started, a reference is added to the Globals from theModule, so it can access the global functions.When evaluating a load statement, a reference is added to the FrozenModulethat is being loaded.When freezing a module, the FrozenHeap, in the Module, is moved to theFrozenModule, preserving the references that were added. "},{"title":"OwnedFrozenValue​","type":1,"pageTitle":"Heaps and Heap References","url":"/docs/developers/starlark/heaps/#ownedfrozenvalue","content":"When you get a value from a FrozenModule, it will be a OwnedFrozenValue. This structure is a pair of a FrozenHeapRef and a FrozenValue, where the ref keeps the value alive. You can move that OwnedFrozenValue into the value of a module with code such as: fn move&lt;'v&gt;(from: &amp;FrozenModule, to: &amp;'v Module) { let x : OwnedFrozenValue = from.get(&quot;value&quot;).unwrap(); let v : Value&lt;'v&gt; = x.owned_value(&amp;to); to.set(&quot;value&quot;, v); }  In general, you can use the OwnedFrozenValue in one of three ways: Operate on it directly - with methods like unpack_i32 or to_str.Extract it safely - using methods like owned_frozen_value, which takes aFrozenHeap to which the heap reference is added and returns a nakedFrozenValue. After that, it is then safe for the FrozenHeap you passed in to use the FrozenValue. With owned_value, there is lifetime checking that the right heap is passed, but with FrozenValue, there isn't.Be careful to pass the right heap, although given most programs only have one active heap at a time, it should mostly work out. Extract it unsafely - using methods unchecked_frozen_value, which gives you the underlying FrozenValue without adding any references. Be careful to make sure there is a good reason the FrozenValue remains valid. "},{"title":"Starlark Types","type":0,"sectionRef":"#","url":"/docs/developers/starlark/types/","content":"","keywords":""},{"title":"What does a type mean?​","type":1,"pageTitle":"Starlark Types","url":"/docs/developers/starlark/types/#what-does-a-type-mean","content":"A type is a Starlark expression that has a meaning as a type: When fib(3) is called, the value 3 is passed to fib as parameter i.When the execution of fib is started, the expression int is evaluated to the value of the int function.A check is then made that the value 3 matches the type represented by int. If the value doesn't match, it is a runtime error. Similarly, on returnstatements, or the end of the function, a check is made that result type matchesint. As some examples of types: The type typing.Any matches any value, with no restrictions.The types int, bool, str all represent the values produced by the respective functions.The type None represents the value None.The type list[int] represents a list of int types, e.g. list[typing.Any]represents a list containing any types.The type dict[int, bool] represents a dictionary with int keys and boolvalues.The type tuple[int, bool, str] represents a tuple of arity 3 with components being int, bool and str.The type tuple[int, ...] represents a tuple of unknown arity where all the components are of type int.The type int | bool represents a value that is either an int or a bool.The type typing.Callable represents something that can be called as a function.The type typing.Iterable represents something that can be iterated on.The type typing.Never represents a type with no valid values - e.g. the result of fail is typing.Never as the return value of fail can never be observed, given the program terminates. The goals of this type system are: Reuse the existing machinery of Starlark as much as possible, avoiding inventing a special class of type values. As a consequence, any optimisations for values like string/list are reused.Provide a pleasing syntax.Some degree of compatibility with Python, which allows types as expressions in the same places Buck2 allows them (but with different meaning and different checking).And finally, a non-goal is to provide a complete type system capable of representing every type invariant: it's intended to be a lossy approximation. In addition to these built-in types, records and enumerations are provided as special concepts. "},{"title":"Record types​","type":1,"pageTitle":"Starlark Types","url":"/docs/developers/starlark/types/#record-types","content":"A record type represents a set of named values, each with their own type. For example: MyRecord = record(host=str, port=int)  This above statement defines a record MyRecord with 2 fields, the first namedhost that must be of type str, and the second named port that must be of type int. Now MyRecord is defined, it's possible to do the following: Create values of this type with MyRecord(host=&quot;localhost&quot;, port=80). It is a runtime error if any arguments are missed, of the wrong type, or if any unexpected arguments are given.Get the type of the record suitable for a type annotation with MyRecord.Get the fields of the record. For example,v = MyRecord(host=&quot;localhost&quot;, port=80) will provide v.host == &quot;localhost&quot;and v.port == 80. Similarly, dir(v) == [&quot;host&quot;, &quot;port&quot;]. It is also possible to specify default values for parameters using the fieldfunction. For example: MyRecord = record(host=str, port=field(int, 80))  Now the port field can be omitted, defaulting to 80 is not present (for example, MyRecord(host=&quot;localhost&quot;).port == 80). Records are stored deduplicating their field names, making them more memory efficient than dictionaries. "},{"title":"Enum types​","type":1,"pageTitle":"Starlark Types","url":"/docs/developers/starlark/types/#enum-types","content":"The enum type represents one value picked from a set of values. For example: MyEnum = enum(&quot;option1&quot;, &quot;option2&quot;, &quot;option3&quot;)  This statement defines an enumeration MyEnum that consists of the three values&quot;option1&quot;, &quot;option2&quot; and &quot;option3&quot;. Now MyEnum is defined, it's possible to do the following: Create values of this type with MyEnum(&quot;option2&quot;). It is a runtime error if the argument is not one of the predeclared values of the enumeration.Get the type of the enum suitable for a type annotation with MyEnum.Given a value of the enum (for example, v = MyEnum(&quot;option2&quot;)), get the underlying value v.value == &quot;option2&quot; or the index in the enumerationv.index == 1.Get a list of the values that make up the array withMyEnum.values() == [&quot;option1&quot;, &quot;option2&quot;, &quot;option3&quot;].Treat MyEnum a bit like an array, with len(MyEnum) == 3,MyEnum[1] == MyEnum(&quot;option2&quot;) and iteration over enums[x.value for x in MyEnum] == [&quot;option1&quot;, &quot;option2&quot;, &quot;option3&quot;]. Enumeration types store each value once, which are then efficiently referenced by enumeration values. "},{"title":"Value Representation","type":0,"sectionRef":"#","url":"/docs/developers/starlark/values/","content":"Value Representation Some of the information in this page is outdated. However, the explanation of the problem, and thought process behind it, remains useful. Of particular note is that a garbage collected heap is now used for Value. ::: This page explains how values are represented in the Starlark interpreter, ignoring some incidental details. Importantly, in Starlark, any identifiers from modules that you import are 'frozen', which means that, if you have a module that defines a list, then once you have imported the module, the list is now immutable. This design means that you can safely share imports with multiple users, without any expensive copying, and use the imports in parallel. Frozen vs unfrozen values​ Values that are frozen are segregated from those that are not: Frozen values are those you import, and (assuming no GC) are to be ref-counted atomically (so they can be shared by multiple threads) and never changed.Unfrozen values are those which are local to the module, and, since modules execute single threaded, can be non-atomically ref-counted and mutated. Once a module has finished executing, it's values are frozen and can be reused freely. Thaw-on-write​ It's not uncommon to return list literals from functions. For example: def my_list(x): return ([1,2,3], x) This above code returns the unfrozen list [1,2,3]. But while the list is unfrozen, and could be mutated by the caller, it probably won't be. To optimise this pattern, construct a frozen list when compiling my_list and insert a shared reference to it in the result. If anyone tries to mutate the list, it's explicitly unfrozen by copying it into a mutable variant (known as thawing the value). Immutable containers of mutable data​ There are some data types (such as functions and tuples) that are themselves immutable but contain mutable data. Importantly, all types that can be invoked as functions (for example, lambda, def, and a.b()) fall into this category. These types can be non-atomically ref-counted but can't be mutated. Implementation in Rust​ Putting all these above concepts together results in the following: enum FrozenValue { None(NoneType), Bool(bool), Int(i64), Obj(Arc&lt;dyn StarlarkValue&gt;), } enum Value { Immutable(FrozenValue), Pseudo(Rc&lt;dyn ComplexValue&gt;) Mutable(Rc&lt;RefCell&lt;Mutable&gt;&gt;), } enum Mutable { Mutable(Box&lt;dyn ComplexValue&gt;), ThawOnWrite(Arc&lt;dyn StarlarkValue&gt;), } In the above code, both of the traits dyn SimpleValue and dyn ComplexValueenable you to convert to the other and have shared general value-like methods. There are four types of value: ImmutablePseudo - immutable containers of mutable values.Mutable/MutableMutable/ThawOnWrite - immutable now but can be replaced withMutable/Mutable if needed. There are two root types: FrozenValue - imported.Value - defined locally.","keywords":""},{"title":"Finding Commands That Buck2 Ran","type":0,"sectionRef":"#","url":"/docs/developers/what-ran/","content":"","keywords":""},{"title":"What Ran output format​","type":1,"pageTitle":"Finding Commands That Buck2 Ran","url":"/docs/developers/what-ran/#what-ran-output-format","content":"This will output a table showing all the commands that were executed, and how they were executed. The structure is as follows: REASON &lt;TAB&gt; TARGET &lt;TAB&gt; IDENTIFIER &lt;TAB&gt; EXECUTOR &lt;TAB&gt; REPRODUCER  Which should be used as follows: REASON - value is either build (for building a thing) or test (for running a test).TARGET - the name of the build target that declared an action.IDENTIFIER - depends on the target but will usually be something like a file name or a module.EXECUTOR - value is either cache, re or local.REPRODUCER - how you can re-run this yourself. "},{"title":"Using the What Ran output​","type":1,"pageTitle":"Finding Commands That Buck2 Ran","url":"/docs/developers/what-ran/#using-the-what-ran-output","content":"Use What Ran as follows: Start by identifying the command you're looking for: You can grep the output for a given target.You can then grep by identifier if necessary. For example, if you're after C++ compilation, try grepping for the basename of your file (for example, for fbcode/my/stuff.cpp, grep for stuff.cpp). Once you found it, reproduce as follows: If the executor was local, the command is in the output, so just run it. It's expected that you'll do this from the root of your project (usebuck2 root --kind project to find where that is).If the executor was re or cache, you're provided a RE digest of the formHASH:SIZE. Run frecli cas download-action HASH:SIZE to retrieve the action, then follow the instructions to run it. "},{"title":"Examples​","type":1,"pageTitle":"Finding Commands That Buck2 Ran","url":"/docs/developers/what-ran/#examples","content":"The following ran locally: build fbcode//scripts/torozco/getenv:getenv-san-conf-__generated-lib__ (archive_thin libgetenv-san-conf-__generated-lib__.pic.a) local fbcode/third-party-buck/platform010/build/llvm-fb/bin/llvm-ar qcsTD buck-out/v2/gen/fbcode/d839c731f5505c62/scripts/torozco/getenv/__getenv-san-conf-__generated-lib____/libgetenv-san-conf-__generated-lib__.pic.a buck-out/v2/gen/fbcode/d839c731f5505c62/scripts/torozco/getenv/__getenv-san-conf-__generated-lib____/__objects__/san-conf.c.pic.o  To repro, you'd run: fbcode/third-party-buck/platform010/build/llvm-fb/bin/llvm-ar qcsTD buck-out/v2/gen/fbcode/d839c731f5505c62/scripts/torozco/getenv/__getenv-san-conf-__generated-lib____/libgetenv-san-conf-__generated-lib__.pic.a buck-out/v2/gen/fbcode/d839c731f5505c62/scripts/torozco/getenv/__getenv-san-conf-__generated-lib____/__objects__/san-conf.c.pic.  The following ran on RE: build fbcode//common/init:kill (cxx_compile Kill.cpp (pic)) re 97feca9d014155a80ec55fe27e6bb17f9d2f8574:94  Reproducing this command will depend on the particular RE implementation you use. "},{"title":"Expired Digests​","type":1,"pageTitle":"Finding Commands That Buck2 Ran","url":"/docs/developers/what-ran/#expired-digests","content":"Note that if the action was a cache hit on RE, you might get an error when downloading it, indicating that it's not found. If that happens, it's because the cache entry is there but the inputs have expired. If this happens to you, run your build with --upload-all-actions. "},{"title":"Windows Cheat Sheet","type":0,"sectionRef":"#","url":"/docs/developers/windows_cheat_sheet/","content":"","keywords":""},{"title":"CMD, Powershell, Bash Command Comparison​","type":1,"pageTitle":"Windows Cheat Sheet","url":"/docs/developers/windows_cheat_sheet/#cmd-powershell-bash-command-comparison","content":"Bash\tPowershell\tCMD\tWhat does it docd\tcd\tcd\tChange the current directory mkdir\tmkdir\tmkdir / md\tCreate a directory ls\tls\tdir\tList contents of a directory export var=&quot;value&quot;\t$env:var=&quot;value&quot;\tset var=value\tTo set environment variables $ENV_VAR\t$env:ENV_VAR\t%ENV_VAR%\tRead environment variable echo &quot;Hello world&quot;\techo &quot;Hello world&quot;\techo Hello world\tTo print something on the screen rm\trm\tdel\tDelete a file rm -rf\trmdir\trmdir\tDelete a directory cat\tcat\ttype\tPrint file content to console "},{"title":"Symlinks​","type":1,"pageTitle":"Windows Cheat Sheet","url":"/docs/developers/windows_cheat_sheet/#symlinks","content":"In Windows, there are two types of symlinks: file and directory. You can find out which type of symlink is being created using:dir /AL /S &lt;path&gt;. The command lists all of the symbolic links in the &lt;path&gt; directory: ^&lt;SYMLINKD^&gt; is a Directory SymLink^&lt;SYMLINK^&gt; is a File SymLink "},{"title":"Target names​","type":1,"pageTitle":"Windows Cheat Sheet","url":"/docs/developers/windows_cheat_sheet/#target-names","content":"Escaping the '=' symbol on Windows is quite complicated: make sure none of the targets being built contain this symbol as it could cause build breakages. "},{"title":"Target Universe in BXL","type":0,"sectionRef":"#","url":"/docs/developers/target_universe/","content":"","keywords":""},{"title":"BXL cquery and target universe​","type":1,"pageTitle":"Target Universe in BXL","url":"/docs/developers/target_universe/#bxl-cquery-and-target-universe","content":"BXL cannot infer the target universelike in the CLI (in most cases). BXL splits up cquery functions per function (ex: ctx.cquery().kind(...)), with the exception of ctx.cquery.eval(...), which accepts literals exactly like in the CLI. For the eval query, target universe is inferred exactly like the CLI. For all other cases, take the following query as an example: buck2 cquery &quot;rdeps(deps(//example:foo), deps(//example:bar))&quot; The target universe here should be constructed from the all the target literals and their transitive deps, which is to say deps(//example:foo, //example:bar). When you run the query, the evaluation of deps(//example:foo) anddeps(//example:bar) nested in the rdeps query will happen inside the universe resulting from deps(//example:foo, //example:bar). Translating it to BXL's individual cquery functions, and let’s say we also try to use the target literals to construct the universe as the CLI target inference does: from_node = ctx.cquery().deps(&quot;//example:foo&quot;) # universe would be //example:foo to_node = ctx.cquery().deps(&quot;//example:bar&quot;) # universe would be //example:bar rdeps = ctx.cquery().rdeps(from_node, to_node) # what is the universe here?  Here, the from_node query is actually evaluated in the wrong target universe because we have broken up the query steps in BXL. Instead ofdeps(//example:foo) being evaluated in deps(//example:foo, //example:bar), it’s evaluated with only deps(//example:foo). It’s impossible to know that there’s going to be an rdeps query later on that expects a different target universe. "},{"title":"Specifying target universe in BXL cquery​","type":1,"pageTitle":"Target Universe in BXL","url":"/docs/developers/target_universe/#specifying-target-universe-in-bxl-cquery","content":"BXL cquery functions should only accept configured targets as inputs, with the exception of eval and testsof_with_default_platform. BXL has a ctx.target_universe() function to construct a target_universeobject, which has a lookup() function to lookup the configured targets within the target universe and return the target set. ​​The lookup functionality is useful because sometimes a single target can appear multiple times within a target universe. For example, if you specify a cxx toolchain using its unconfigured target label, it will always match against all cxx toolchains in the target universe (so at least once for target deps and once for exec deps), since cxx toolchains may have multiple configurations. Example: def _impl(): target_universe = ctx.target_universe([&quot;//example:foo&quot;, &quot;//example:bar&quot;]) to_node = target_universe.lookup(&quot;//example:foo&quot;) from_node = target_universe.lookup(&quot;//example:bar&quot;) rdeps = ctx.cquery().rdeps(to_node, from_node)  However, sometimes you might want a specific configuration instead of using all configurations found within a target universe, in which case you could usectx.configured_targets(...) to specify the configuration. Or, sometimes you may want to use the specific configured target nodes resulting from other BXL calls. In these cases, you can pass the configured targets directly into cquery functions, instead of going through target universe lookup. "},{"title":"What does the target universe tend to be in practice?​","type":1,"pageTitle":"Target Universe in BXL","url":"/docs/developers/target_universe/#what-does-the-target-universe-tend-to-be-in-practice","content":"For owner query, the universe would be constructed with the unconfigured target nodes returned from ctx.uquery().owner(...). Example: def _impl(): unconfigured_owners = ctx.uquery().owner(&quot;foobar&quot;) target_universe = ctx.target_universe(unconfigured_owners).target_set() owners = ctx.cquery().owner(&quot;foobar&quot;, target_universe)  For everything else, the universe would usually be constructed using all target literals found in your query. Example: def _impl(): target_universe = ctx.target_universe(&quot;//example:foo&quot;) inputs = target_universe.target_set() deps = ctx.cquery().deps(inputs)  While the above guideline should work for rdeps as well, for rdeps the universe would usually be narrowed down to the &quot;to&quot;/&quot;destination&quot; target set argument. (This is a subset of the target universe suggested for non-ownerquery cases). Updating the example from above: def _impl(): target_universe = ctx.target_universe(&quot;//example:foo&quot;) # narrowed down to the &quot;to&quot; literals in rdeps universe_node = target_universe.target_set() from_node = target_universe.lookup(&quot;//example:bar&quot;) rdeps = ctx.cquery().rdeps(universe_node, from_node)  "},{"title":"keep-going​","type":1,"pageTitle":"Target Universe in BXL","url":"/docs/developers/target_universe/#keep-going","content":"The configured graph can be broken for various reasons: incompatible targets (BXL skips these automatically), visibility issues, nonexistent targets, etc. For issues that are not incompatible targets, the target_universe can be constructed with the keep_going flag set to True to skip any other errors, and your cquery will not error out. Note that keep_going is only compatible for a single string literal target or target pattern at the moment. ctx.target_universe(&quot;//foo/...&quot;, keep_going = True)  "},{"title":"BXL build and target universe​","type":1,"pageTitle":"Target Universe in BXL","url":"/docs/developers/target_universe/#bxl-build-and-target-universe","content":"Note that BXL builds currently do not support target universe, but we intend to add this. "},{"title":"RFC: labels -> metadata attribute","type":0,"sectionRef":"#","url":"/docs/rfcs/attr-metadata/","content":"","keywords":""},{"title":"Context: labels​","type":1,"pageTitle":"RFC: labels -> metadata attribute","url":"/docs/rfcs/attr-metadata/#context-labels","content":"In buck1 we have labels builtin rule attribute, which is a list of strings. In buck2 we have labels attribute which is configured in prelude, it does not have special meaning. "},{"title":"Context: package values​","type":1,"pageTitle":"RFC: labels -> metadata attribute","url":"/docs/rfcs/attr-metadata/#context-package-values","content":"PACKAGE files have a function: write_package_value(key, value), where a key is a word-dot-word string, and value is arbitrary starlark value which should be serializable as JSON. "},{"title":"Context: metadata we use or we need​","type":1,"pageTitle":"RFC: labels -> metadata attribute","url":"/docs/rfcs/attr-metadata/#context-metadata-we-use-or-we-need","content":"There are several spaces where we use or need metadata to be stored in buck2 target graph. fbcode uses per-package values to switch code to new clang (example)testinfra wants to use PACKAGE values to mark a set of folders to a logical larger projectit is likely that per-target metadata attribute should be used inconfiguration factory function.TD wants to declare CI trigger jobs per-target or per-package, and this logic is to be specified in BUCK or PACKAGE files — as metadata "},{"title":"Proposal: metadata attribute​","type":1,"pageTitle":"RFC: labels -> metadata attribute","url":"/docs/rfcs/attr-metadata/#proposal-metadata-attribute","content":"Add builtin metadata attribute to all the targets. metadata has the same structure as package values: word-dot-word to arbitrary value serializable to JSON. For example: cxx_library( name = &quot;mylib&quot;, metadata = { &quot;td.run_on_windows&quot;: True, }, )  Metadata attribute is not configurable (means select cannot be used). "},{"title":"buck2 audit visibility command","type":0,"sectionRef":"#","url":"/docs/rfcs/audit_visibility/","content":"","keywords":""},{"title":"Context​","type":1,"pageTitle":"buck2 audit visibility command","url":"/docs/rfcs/audit_visibility/#context","content":"Buck has a concept of Visibility for every target. It allows users to define, for each target, the targets it can depend on and targets that can depend on it. Visibility is specified as an allowlist of targets/target patterns, and any target used that falls outside of the allowlist fails visibility checking. Visibility pattern can be specified on visibility and within_view attributes in buildfiles andPACKAGE files. Visibility is important to lots of codebase maintainers because it can be used to keep projects from pulling in unwanted dependencies. As some examples, App Core teams are using Buck visibility as areplacement to current supermodules for protecting app modularity. Instagram's using visibility toprotect modularity and define Link Groups used for build speed optimizations. There's interest from various DevX teams in using Buck visibility onPACKAGE filestoenforce repo boundaries, which will allow target determinators to migrate off of sparse profiles and onto Eden, although visibility in its current form is likely not fit for enforcing such repo boundaries. Visibility has also been used to enforcerequirements that only certain targets are allowed to depend on targets in fbcode/scripts. For perf reasons, buck2 doesn't always enforce visibility. Instead, it only enforces visibility on construction of the configured target graph. Visibility checking is expensive memory-wise because it requires tracking all deps at each node. When constructing configured target graph, this cost is already paid for when buck2 checks transitive target compatibility. When constructing the unconfigured target graph, however, this is costly, so we avoid checking visibility there. (Note that buck does not allow you to specify selects in visibility attributes.) In practice, this means that commands like cquery and build can enforce visibility whereas commands like uquery and targets cannot. Having visibility checked only on the configured target graph is problematic for 2 reasons: Visibility is only checked on configured deps after selects are resolved, so it's possible for a target to pass visibility checking in one configuration but fail visibility checking in another. For example, a target may pass visibility checking on a linux configuration but fail visibility checking on mac configuration if it has a bad mac-only dependency. This makes visibility enforcement more difficult because now you have to query the same graph in both linux and mac configuration before you know that visibility is always valid. Uquery (querying the unconfigured target graph) has better performance than cquery (querying the configured target graph). Big-O wise, uquery scales with O(# of targets) whereas cquery scales with O((# number of configurations) x (# of targets)). Having a way to check visibility on unconfigured target graph can be much cheaper than doing so on configured target graph. "},{"title":"Proposed Solution: audit visibility command​","type":1,"pageTitle":"buck2 audit visibility command","url":"/docs/rfcs/audit_visibility/#proposed-solution-audit-visibility-command","content":"It's clear that we need a way to check visibility on the unconfigured target graph, but we don't want buck2 uquery and buck2 targets to regress in memory use. To get the best of both worlds, I propose adding a separate command to buck2, buck2 audit visibility, that will check visibility on the unconfigured target graph. Instead of checking on construction of the unconfigured target graph, this command will check after construction, which will avoid any memory regression. The tradeoff is that the visibility checking won't be cached, and rerunning audit visibility will rerun visibility checking on each invocation. "},{"title":"Usage and Invocation​","type":1,"pageTitle":"buck2 audit visibility command","url":"/docs/rfcs/audit_visibility/#usage-and-invocation","content":"buck2 audit visibility command will take in a list of target patterns as well as common build args like config flags and mode files as args. It will construct the unconfigured target graph based on the transitive deps of those targets and check that this graph has valid visibility. Checking transitive deps matches the behavior of visibility checking on cquery, but we may revisit this decision in the future if there is a need for just verifying the immediate dependencies. For example, an invocation to check visibility on the transitive closure of fbobjc can be buck2 audit visibility fbsource//fbobjc/...  It cannot be used to check that a target has a valid visibility with respect to targets outside of the transitive closure of its deps. For example,buck2 audit visibility fbcode//buck2/starlark-rust/starlark:starlark will just check that all transitive deps of starlark target (including starlarktarget) have valid visibility with respect to each other. It will not check that any targets that depend on starlark respect starlark target's visibility attribute. "},{"title":"Bxl support for performing analysis on targets","type":0,"sectionRef":"#","url":"/docs/rfcs/bxl-analysis/","content":"","keywords":""},{"title":"Intro​","type":1,"pageTitle":"Bxl support for performing analysis on targets","url":"/docs/rfcs/bxl-analysis/#intro","content":"As Bob and I continue to build out bxl we want users to be able to inspect the providers and actions for a given target label. In order to support this, we need to be able to provide access to AnalysisResult via starlark, obtained via a call to RuleAnalysisCalculation::get_analysis_result. "},{"title":"How to implement it?​","type":1,"pageTitle":"Bxl support for performing analysis on targets","url":"/docs/rfcs/bxl-analysis/#how-to-implement-it","content":"Our three principle options are as follows: BxlContext::analyze(targetlabel: ConfiguredTargetLabelLike), whereConfiguredTargetLabelLike accepts ConfiguredTargetLabel,ConfiguredTargetNode, or sets and lists of these things + acceptable strings. In this scenario, we attach the analysis method onto the bxl context itself, and require that users pass in the target label-ish thing when they want to construct an analysis result. It's a little awkward in some ways because the analysis is more naturally a method on the argument being passed in and theBxlContext is a context that is needed to perform the calculation. On the other hand, this allows us to construct a type analogous to TargetExpr which can parse from a wide variety of different ConfiguredTarget like things (strings, nodes, labels, sets, ...). It also is a bit nice from an implementational standpoint since we don't have to pass the context around everywhere. This isn't a huge pro though, since we can stick it in the global eval field. result = bxl.analyze(bxl.cquery.deps(&quot;foo&quot;))  ConfiguredTargetLabel::analyze(), ConfiguredTargetNode::analyze(), ... where we carry around the BxlContext in the eval global field and implement analysis on each type that is target label like. The pro of this one is that it's quite natural - you can take aConfiguredStarlarkTargetLabel and then just ... call analyze() on it like you might expect to. The two downsides are that we have to propagate the context around behind the scenes, and we'll have to provide an implementation ofanalyze on everything that we'd like to have be able to be analyzable. result = &quot;root//bin:the_binary&quot;.analyze() # but we don't support &quot;root//bin:the_binary&quot;.rdeps() # instead this looks nice nodes = ctx.cquery.deps(&quot;foo&quot;) for n in nodes: # since we can now do nodes.label nodes.attrs.field # similarly access analysis nodes.analysis  BxlContext::analysis(): AnalysisContext where AnalysisContext exposesAnalysisContext::analyze(targetlabel: ConfiguredTargetLabelLike). There's not really any pros of this approach except that it's similar to the flow for cquery where we return a cqueryctx object to call cquery methods through. result = ctx.analysis().analyze(&quot;//lib:file1&quot;)  We can also restrict the API to require that users go through cquery to obtain a ConfiguredTargetNode prior to calling analysis, although we don't have to. I say that we don't have to because the get_analysis_result method mentioned above is configured to accept a label anyway. "},{"title":"Buck Extension Language (BXL)","type":0,"sectionRef":"#","url":"/docs/rfcs/bxl/","content":"","keywords":""},{"title":"Use Cases​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#use-cases","content":""},{"title":"Cpp LSP​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#cpp-lsp","content":"Lsp prefers to have a single buck command that given a file, returns the corresponding compilation database. This requires a single command, i.e a bxl, that accepts a file as input, performs owners queries, and uses the owning target plus the desired file to get the clang flags, and then writes it to disk in comp db format. It’s possible to write the same features using buck calls to cquery, and build using subtargets to generate compilation database per file. However, this requires lsp owners to maintain code in several locations and languages, and parse and reserialize data. It also does not provide the same incrementality and subscription update features of the resulting comp db that writing this in bxl would have. Furthermore, we may explore the idea of trimming the compilation command to only dependencies required per the file requested. Bxl actions provides a straightforward api for adding this when writing the actual comp db file. "},{"title":"Android LSP​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#android-lsp","content":"Android project requires traversing the target graph to find and java libraries, grouping and converting them between modules or project libraries depending on the number of references, and restructuring the graph as directory based. Android LSP is able to take advantage of subscriptions in the future when available, allowing developers to keep their IDE up-to-date automatically without needing to manually regenerate the project. With bxl, the graph traversals can be written in starlark, allowing propagation of information down the graph, accessing targets’ attributes to analyze dependencies, and access providers for artifacts and action information needed to output the project file. Project generation also performs directory listings that buck2’s dice already performs and caches (I think, need to confirm). Bxl poses the interesting possibility that we can expose a limited set of IO operations that are tracked by dice so bxl can access the same cached file operations as rest of buck2. Android project generation currently doesn’t write project files to buck-out, which prevents it from using buck2 actions. It will have to rely on an external script to process the graph information printed by buck and write the actual project files. If it moves to buck-out based, then it can take advantage of creating actions directly using the graph information processed, and potentially take advantage of incremental actions api to avoid writing the entire graph on each subsequent update. "},{"title":"iOS Project​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#ios-project","content":"iOS is currently being implemented as a series of queries that are aggregated by an external python script, that then invokes builds of subtargets. The same can be achieved in bxl, but with the entire sequence being cacheable and subscribable so that when the graph is updated, or even when generated files need updating, buck2 can automatically push the updates. However, it is uncertain whether xcode itself can make use of push updates. "},{"title":"Rust LSP​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#rust-lsp","content":"(note from dbarsky@: I’m adding this at Bob’s request. Can be removed as needed.) "},{"title":"Visual Studio Project (vsgo)​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#visual-studio-project-vsgo","content":"Vsgo is a pile of python that converts buck query/buck targets output via a variety of heuristics into inputs to a custom fork gyp which is then invoked to generate visual studio projects for a given buck target. Having direct access to the internals of buck would allow us to remove the heuristics and possibly even move project generation directly into bxl. "},{"title":"Goals​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#goals","content":"From the above use cases, BXL should offer a simple Starlark API that allows easy introspection of the buck2 graph at unconfigured, configured, providers, and actions stage, maintaining incremental behaviour of the BXL evaluation itself. Some minimal API should be offered to allow BXL to provide additional behaviour such as output artifacts, and print results. Most use cases from LSP desire to also propagate information via the command line for these operations, so BXL should support command line arguments as inputs. "},{"title":"API​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#api","content":""},{"title":"Defining a bxl function​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#defining-a-bxl-function","content":"There are multiple models possible. We can have each file be its own bxl, or have each file declare multiple bxl like rules. There are multiple advantages to allowing declaration of multiple bxls, such as grouping similar bxls in the same file, allowing them to &quot;invoke&quot; each other. It doesn’t necessarily add much more complexity for the author, as even with one bxl per file, the author still has to have some declaration for the bxls arguments. # sample.bxl func1 = bxl_main( impl = my_func1, args = { &quot;arg1&quot;: arg.list(arg.str()), } ) func2 = bxl_main( ... )  To invoke buck2 for that bxl, we can have the command line as follows. buck2 bxl sample.bxl::func1 -- --arg1 foo bar baz  For bxl functions to read the arguments, a similar api to rule attrs is used args = ctx.args.args_for_bxl  Args defined like attrs when declaring the bxl function above "},{"title":"Accessing target nodes​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#accessing-target-nodes","content":"All standard query functions will be enabled in bxl, allowing users to run query operations, storing them in variables and interacting with them. These allow introspection of the unconfigured targets, or the configured targets based on api # some.bxl targets = ctx.uquery(‘deps(&quot;//foo&quot;)’) targets = filter(targets, my_filter) # introspect a target for target in targets: ctx.print(target.attributes) # prints selects # also inspect the target like below ctx.print(target.label) target = ctx.cquery(&quot;//foo&quot;, &quot;//x86&quot;).attributes # cquery has selects resolved  "},{"title":"Inspect providers​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#inspect-providers","content":"When we have a configured target, bxl can request for the analysis of the rule target = &lt;some configured target&gt; ctx.analysis(target).providers # access the providers  "},{"title":"Actions​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#actions","content":"For IDEs, to generate compilation databases, or generate project files, writing them in bxl will entail creating actions, and executing them. As such, bxl will also be given the rules api to register actions, including dynamic outputs for the rule in the current bxl invocation to build artifacts as part of a bxl function. BXL has the ability to create actions with some constraints: Action is tied to a particular targetIt’s output location is determined in the same pattern as regular actions defined via rules targets = ctx.cquery(‘deps(&quot;//foo:rule&quot;)’) for t in targets: action_ctx = ctx.analysis(t).actions # the action context here is tied to the configured target `t` # actions registered by bxl will be attached with bxl prefix key action_ctx.registry.write(some_output, &quot;foo&quot;)  BXL can also interact with the existing actions on an action via the action_ctx, such as iterating through it, analyzing its outputs, or requesting it to be ran. targets = deps(&quot;foo:rule&quot;) for t in targets: action_ctx = ctx.analysis(t).actions for action in action_ctx.iter(): if &quot;foo/path&quot; in action.output: ctx.build(action)  "},{"title":"What is cached?​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#what-is-cached","content":"All computations requested by a bxl function will be treated as inputs. So if a bxl function calls uquery, then uses the result to do a cquery, and then a build, if buck2 detects that any of the recorded calls to uquery, cquery, and build changes, the entire bxl will be reran, with no early cutoff. The computations itself will still be cached via DICE, so no major performance issues are expected. However, in the event that a bxl function is computationally heavy, the recommendation would be to move that to an action, or split up the bxl and use inter-bxl caching described below. "},{"title":"Inter-bxl caching?​","type":1,"pageTitle":"Buck Extension Language (BXL)","url":"/docs/rfcs/bxl/#inter-bxl-caching","content":"Different bxl can be cacheable between each other if structured as &quot;outputs&quot;/artifacts. This is essentially the same behaviour as a bxl requestingctx.build, which is cached. Since we have those as hashes on RE, we can track properly and not require storing the values in dice. i.e. # caching_sample.bxl func1 = bxl_main( impl = my_func1, args = { &quot;arg1&quot;: arg.list(arg.str()), } ) my_func1(ctx): … # do various stuff that might change a lot, but the final result # doesn’t change much ctx.return(some_artifact) func2 = bxl_main( impl = my_func2, ... ) my_func2(ctx): artifact = ctx.bxl(&quot;:func1&quot;) # now read artifact value # everything below will only be reran if the artifact content changes … # do some expensive stuff  "},{"title":"Buck support to implement configured_alias","type":0,"sectionRef":"#","url":"/docs/rfcs/configured-alias/","content":"","keywords":""},{"title":"Intro​","type":1,"pageTitle":"Buck support to implement configured_alias","url":"/docs/rfcs/configured-alias/#intro","content":"Currently, Buck 2 lacks configured_alias rule support. configured_alias is a builtin rule in Buck v1, and it cannot be currently implemented as user defined rule in Buck v2. This RFC proposes Buck core support for configured_alias. "},{"title":"What is configured_alias?​","type":1,"pageTitle":"Buck support to implement configured_alias","url":"/docs/rfcs/configured-alias/#what-is-configured_alias","content":"Syntax is this: configured_alias( name = &quot;foo-but-linux-release&quot;, actual = &quot;:foo&quot;, platform = &quot;config//platforms:linux-release&quot;, )  When this rule is built, it ignores &quot;current&quot; target configuration, and builds the &quot;actual&quot; target with the configuration specified as &quot;platform&quot; argument. "},{"title":"How to implement it in buck v2?​","type":1,"pageTitle":"Buck support to implement configured_alias","url":"/docs/rfcs/configured-alias/#how-to-implement-it-in-buck-v2","content":""},{"title":"New rule attribute type: configured_dep​","type":1,"pageTitle":"Buck support to implement configured_alias","url":"/docs/rfcs/configured-alias/#new-rule-attribute-type-configured_dep","content":"Currently, we have several dependency attributes: attrs.depattrs.exec_depattrs.transition_depattrs.split_transition_dep This RFC proposes adding another attribute: attrs.configured_dep configured_dep is an attribute which accepts a pair of strings: target and configuration. During analysis, configured attr deps are resolved to providers resolved using given configuration. "},{"title":"configured_alias_impl user defined rule​","type":1,"pageTitle":"Buck support to implement configured_alias","url":"/docs/rfcs/configured-alias/#configured_alias_impl-user-defined-rule","content":"The rule implementation is trivial:  def _configured_alias_impl(ctx): return ctx.attrs.actual.providers configured_alias_impl = rule( impl = _configured_alias_impl, attrs = { &quot;actual&quot;: attrs.configured_dep(), } )  "},{"title":"Finally, configured_alias macro​","type":1,"pageTitle":"Buck support to implement configured_alias","url":"/docs/rfcs/configured-alias/#finally-configured_alias-macro","content":"def configured_alias(name, actual, platform): configured_alias_impl(name, actual = (actual, platform))  "},{"title":"Alternatives​","type":1,"pageTitle":"Buck support to implement configured_alias","url":"/docs/rfcs/configured-alias/#alternatives","content":""},{"title":"No configured_alias​","type":1,"pageTitle":"Buck support to implement configured_alias","url":"/docs/rfcs/configured-alias/#no-configured_alias","content":"Each specific case where configured_alias is used, it can be done with defining custom transition, and using custom transition rule. But having configured_alias is a convenient stopgap to unblock people. "},{"title":"Use @configuration syntax from another RFC.​","type":1,"pageTitle":"Buck support to implement configured_alias","url":"/docs/rfcs/configured-alias/#use-configuration-syntax-from-another-rfc","content":"Instead of passing confiured_target_label(x, y) pass x + &quot;@&quot; + y. "},{"title":"Accept configured_target_label in dep attribute​","type":1,"pageTitle":"Buck support to implement configured_alias","url":"/docs/rfcs/configured-alias/#accept-configured_target_label-in-dep-attribute","content":"dep attribute could support all of: regular target label as stringconfigured target label (as either configured_target_label or x@y I don't know practical applications for this magic, and unless there are uses for it, better keep API simple and explicit. "},{"title":"Bxl Actions and Build API","type":0,"sectionRef":"#","url":"/docs/rfcs/drafts/bxl-actions/","content":"","keywords":""},{"title":"Actions API​","type":1,"pageTitle":"Bxl Actions and Build API","url":"/docs/rfcs/drafts/bxl-actions/#actions-api","content":"The actions API should be the same as rules' actions API. That is, it has the same ctx.actions that allows registering of artifacts, creating actions, dynamic actions via the same api. "},{"title":"Creating and Building the Actions​","type":1,"pageTitle":"Bxl Actions and Build API","url":"/docs/rfcs/drafts/bxl-actions/#creating-and-building-the-actions","content":"Bxl allows users to build targets and actions. However, when creating actions, they are not bound/buildable until the artifact/action factories are finalized. As such, we will introduce the limitation that bxl cannot build artifacts that they themselves declared within the bxl. Instead, they will return a set of artifacts to expose to users, which buck2 will automatically build after finalizing the action factory. For dynamic-ness, bxl users will use the standard dynamic output api. There is an issue that during the dynamic output api's lambda, bxl functions will not be able to access the regular bxl functions for queries, etc. However, this is likely not important as most use cases should reasonably query bxl data before the dynamic outputs, and have limited power in dynamic-ness. We can also always replace the ctx of the dynamic to be the bxl context in the future, as we see fit. Sample: def my_bxl(ctx): actions_factory = ctx.bxl_actions.factory() artifact = actions_factory.write(&quot;file.txt&quot;, &quot;content&quot;) # note that existing artifacts that were declared by other rules can be built ctx.actions.build(ctx.analysis(ctx.target(&quot;foo&quot;)).providers[DefaultInfo].default_output)) return [artifact] # exposes the declared artifact to users  "},{"title":"Internal Representation (Deferred Framework)​","type":1,"pageTitle":"Bxl Actions and Build API","url":"/docs/rfcs/drafts/bxl-actions/#internal-representation-deferred-framework","content":"The existing actions framework attaches all actions to a deferred, which is based off a ConfiguredLabel, which also corresponds to the output path prefix. bxl actions should also have a unique output path prefix, and follow the same system of having a base deferred key to reuse the action implementation. We should extend the BaseKey of a DeferredKey to support beyond aConfiguredLabel, so that we can use a BxlFunctionLabel in its place. This would allow owner of these actions to point to the correct creator. The output path would be determined by using the BxlFunctionLabel as prefix similar to a label. While this means that not all outputs are associated with an actual rule, this is arguably more correct as bxl that creates outputs that doesn't fit the target graph structure (i.e android project generation follows directory structure rather than the packages defined by targets) to not have to conform the attaching their actions to existing rules. bxl functions can examine multiple rules and create a single action, attached only to their function label. The ActionRegistry will be attached to the evaluation result of bxl. Since we do not allow bxl to explicitly request build of the actions itself declares, we can wait until the end of the bxl function to finalize the actions. Then, the action lookup can simply refer to the result of the bxl. With the above changes, the rest of the actions framework does not need changed to support the proposed API. DICE caching will work as today. "},{"title":"[RFC] Configuration Modifiers","type":0,"sectionRef":"#","url":"/docs/rfcs/cfg-modifiers/api/","content":"","keywords":""},{"title":"Why do we need new configuration setup?​","type":1,"pageTitle":"[RFC] Configuration Modifiers","url":"/docs/rfcs/cfg-modifiers/api/#why-do-we-need-new-configuration-setup","content":"A target usually needs to be built in multiple build settings. For example, there may be different OS (ex. linux, mac, windows), architectures (ex. x86, arm), and sanitizers (ex. asan, tsan, ubsan) to use for a single target. Buck has 2 main ways of supporting customizations today: Buckconfigs specified through --config or -c flags. They are global flags and are often aggregated in modefiles (@&lt;modefile&gt; on the command line).Target platforms specified through default_target_platform attribute or--target-platforms flag), which become a target's &quot;configuration&quot;.--target-platforms flags are also commonly specified via modefiles. These methods are problematic for the following reasons. We have too many modefiles. A project that needs customizations often ends up adding its own set of modefiles, causing a continued rise in number of custom modefiles in the repo. Internally, the number of modefiles in our monorepo is currently on the order of 10,000s. Changing buckconfigs invalidates Buck's state. Changing buckconfigs or modefiles of buckconfigs invalidates global state, which adds non-trivial Buck overhead on every incremental build that changes state. This does not affect target platforms. Different modefiles of buckconfigs cannot be used in same build. Users that need to run multi-configuration builds today often work around this by writing scripts that wraps multiple buck build invocations of different modes. This is slow because Buck state keeps getting repeatedly invalidated. There is also no way to build a target in different modes (ex. dev and opt) at the same time, so users that need to do this always have to do this sequentially. This does not affect target platforms. Target platform generation is exponential in number of build settings. Suppose I want to customize targets based on 3 OSes, 2 architectures, and 3 compilers. With target platforms, I need to first generate all 18 permutations of these settings as platform targets before using them. This is not scalable. Target platform does not compose well on command line. Suppose I want to use ASAN on top of some existing platform. It's not possible to say specify ASAN on top of an existing platform on the command line. Instead, I must create a new platform target with ASAN added to the existing platform before I can use it. Poor user Experience. When every project needs its own set of modes, it's onerous for users to track what modes are needed to build what targets. Users often don't realize when they are using the wrong or unnecessary command line flags. Poor tooling integration. Similar to user, it's just onerous for tooling to keep track of what modes are needed to build a target with. Buckconfigs are also bad for performance for tools like language servers because it's impossible to request the builds of two modes in parallel when two targets needs different modes. Antithetical to Buck's principles. Buck's main strength is the ability to abstract away builds of different languages and libraries under one common syntax for the user. The need for project-custom flags goes against this principle. The Modifier API introduces a unified way to specify build settings on a project, target, and command line level. Like target platforms, it constructs Buck configurations so it supports multi-configuration builds. It avoids modefile proliferation by allowing users to easily set project-specific build settings like compiler and toolchain versions in the repo rather than on the command line. It avoids scalability problems of platform generation by being composition-first. The goals of this project is to: Make buck build work on any platform without the use of special flags. Today, building a mac target on mac often requires a mac mode, and likewise for windows. Instead, buck build should always work out of the box on any platform so that there's no need to specify mac mode on macs or windows mode on windows.Define a small constrained set of common modifiers that can be used to build any target in the repo. This will include common options like mode (ex. dev, opt, release), OS (ex. linux, mac, iphoneos), and architecture (ex. x86, arm).Unblock cross-building for the majority of targets. host_info() is a hack to obtain information about the host machine that is the main blocker to Buck2 cross-building (ex. building a mac or windows target from linux) working everywhere. As an extension of &quot;making buck build work on any platform&quot;, modifiers should make it possible to kill off most use cases ofhost_info in the repo.Simplify building build tooling. Because buck build works out of the box, tools like language servers can build targets they need without using project-specific modefiles or flags.Delete most modefiles from the repo.Deprecate target platforms for modifiers as the sole way of configuring top-level targets in Buck. "},{"title":"Configuration Background​","type":1,"pageTitle":"[RFC] Configuration Modifiers","url":"/docs/rfcs/cfg-modifiers/api/#configuration-background","content":"Feel free to skip this if you already understand Buck configurations. A configuration is a collection of constraint_value targets (commonly referred to as constraints). It defines the build settings used by a target. A constraint value is keyed by a constraint_setting, so there can only be oneconstraint_value of a constraint_setting in a configuration. For example, suppose cfg//os:_ is a constraint setting with constraint valuescfg//os:linux, cfg//os:macos, and cfg//os:windows. Then a configuration may contain either cfg//os:linux, cfg//os:macos, or cfg//os:windows to indicate which OS a target is built for. A constraint or a set of constraints can be selected on via select() to customize a target's behavior. For example, the following adds a linux only dep to a target. deps = select({ &quot;cfg//os:linux&quot;: [&quot;:linux_only_dep&quot;], &quot;DEFAULT&quot;: [], })  Before building a target on the command line (known as the top-level target), Buck needs to know its configuration in order to resolve selects. Modifiers are a new way to resolve a target's configuration for every top-level target. "},{"title":"API​","type":1,"pageTitle":"[RFC] Configuration Modifiers","url":"/docs/rfcs/cfg-modifiers/api/#api","content":"Every top-level target starts with an empty configuration, and Buck will apply a list of &quot;modifiers&quot; to obtain a configuration. A modifier is a modification of a constraint from the existing configuration to obtain a new configuration. There are two types of modifiers, conditional and unconditional modifiers. An unconditional modifier is just a constraint value. Applying an unconditional modifier will insert the associated constraint value into the configuration for its respective constraint setting, replacing any existing constraint value for that setting. For example, specifying cfg//os:linux as a modifier will insertcfg//os:linux into the configuration, overriding any existing constraint value for the cfg//os:_ constraint setting. A conditional modifier is a modifier that only applies when a certain condition is satisfied. This lets one express powerful composition based on other criteria. modifiers.match() is a conditional modifier that changes the constraint value inserted based on the existing configuration. For example, a modifier like modifiers.match({ &quot;cfg//os:windows&quot;: &quot;cfg//compiler:msvc&quot;, &quot;DEFAULT&quot;: &quot;cfg//compiler:clang&quot;, })  will insert msvc constraint into the configuration if OS is windows or clang constraint otherwise. A modifiers.match() behaves similarly to Buck'sselect() but can only be used in a modifier context. A modifiers.match() can only be used to modify a single constraint setting, so the following example is not valid. # This fails because a modifier cannot modify both compiler and OS. modifiers.match({ &quot;cfg//os:windows&quot;: &quot;cfg//compiler:msvc&quot;, &quot;DEFAULT&quot;: &quot;cfg//os:linux&quot;, })  A modifier can be specified in a PACKAGE file, on a target, or on the command line. This provides the flexibility needed to customize targets on a project, target, or cli level. "},{"title":"PACKAGE Modifier​","type":1,"pageTitle":"[RFC] Configuration Modifiers","url":"/docs/rfcs/cfg-modifiers/api/#package-modifier","content":"In a PACKAGE file, modifiers can be specified using the cfg_modifiers function and would apply to all targets covered under that PACKAGE. For example, modifiers specified in repo/PACKAGE would apply to any target underrepo//.... Modifiers specified in repo/foo/PACKAGE would apply to any target under repo//foo/... (For resolution order, see &quot;Modifier Resolution&quot; section). The cfg_modifiers function takes as input a dictionary of constraint setting to modifier for that setting. For example, the following is an example that sets modifiers for OS and compiler settings in the repo's top PACKAGE file for all targets in repo. # repo/PACKAGE set_cfg_modifiers(cfg_modifiers = [ &quot;cfg//:linux&quot;, modifiers.match({ &quot;DEFAULT&quot;: &quot;cfg//compiler:clang&quot;, &quot;cfg//os:windows&quot;: &quot;cfg//compiler:msvc&quot;, }), ])  To make constraints easier to type, you can specify aliases for modifier targets via Buck's target aliases. For example, suppose the following aliases exist in repo/.buckconfig. [alias] os = cfg//os:_ linux = cfg//os:linux macos = cfg//os:macos windows = cfg//os:windows compiler = cfg//compiler:_ clang = cfg//compiler:clang msvc = cfg//compiler:msvc  Then the same PACKAGE modifiers can be specified as follows. # repo/PACKAGE set_cfg_modifiers(cfg_modifiers = [ &quot;linux&quot;, modifiers.match({ &quot;DEFAULT&quot;: &quot;clang&quot;, &quot;windows&quot;: &quot;msvc&quot;, }), })  "},{"title":"Target Modifier​","type":1,"pageTitle":"[RFC] Configuration Modifiers","url":"/docs/rfcs/cfg-modifiers/api/#target-modifier","content":"On a target, modifiers can be specified on the metadata attribute. For example, the following specifies modifiers for repo//foo:bar. # repo/foo/BUCK python_binary( name = &quot;bar&quot;, # ... metadata = {&quot;buck.cfg_modifiers&quot;: [ &quot;cfg//os:windows&quot;, # Target modifiers can also use aliases &quot;clang&quot;, ]}, )  Note one day all targets will probably have their own cfg_modifiers attribute. "},{"title":"CLI Modifier​","type":1,"pageTitle":"[RFC] Configuration Modifiers","url":"/docs/rfcs/cfg-modifiers/api/#cli-modifier","content":"On the command line, modifiers are specified asbuck2 build &lt;target&gt;?&lt;modifiers separated by commas&gt;. For example, buck2 build repo//foo:bar?cfg//sanitizer:asan applies asan modifier on the command line.buck2 build repo//foo:bar?cfg//os:linux,cfg//sanitizer:asan will apply linux and asan modifiers. Aliases can also be used on command line, sobuck2 build repo//foo:bar?asan is valid. Command line modifiers cannot be selects, although this may be revisited if necessary. Modifiers can be specified for any target pattern, sobuck2 build repo//foo/...?asan and buck2 build repo//foo:?asan are also valid. When specifying a subtarget and modifier with ?, subtarget should go before modifier, ex. buck2 build repo//foo:bar[comp-db]?asan. To specify modifiers to a list of target patterns on the command line, you can use the --modifier or -m flag. For example,buck2 build repo//foo:bar repo//foo:baz -m release is equivalent tobuck2 build repo//foo:bar?release //foo:baz?release. --modifier flag can be specified multiple times to add multiple modifier, sobuck2 build --modifier=linux --modifier=release repo//foo:bar is equivalent tobuck2 build repo//foo:bar?linux,release. It is prohibited to specify both --modifier flag and ? in target pattern. This restriction can be lifted in the future if there is a need. When two modifiers of the same constraint setting are specified, then the later one overrides the earlier one. For example,buck2 build repo//foo:bar?dev,release is equivalent tobuck2 build repo//foo:bar?release. On command line, a config_setting target can be specified as a collection of modifiers after --modifier or ?. This will be equivalent to specifying each constraint inside the config_setting as a separate modifier. NOTE: only --modifier flag is currently implemented. -m is currently disabled and ? is not implemented. "},{"title":"Modifier Resolution​","type":1,"pageTitle":"[RFC] Configuration Modifiers","url":"/docs/rfcs/cfg-modifiers/api/#modifier-resolution","content":"Modifiers are resolved in order of constraint setting, and for each constraint setting, modifiers for that setting are resolved in order of PACKAGE, target, and command line, with modifier from parent PACKAGE applied before child PACKAGE. The end of this section will describe how Buck determines the order of constraint setting to resolve. Suppose modifiers for repo//foo:bar are specified as follows. # repo/PACKAGE set_cfg_modifiers(cfg_modifiers = [ &quot;cfg//:linux&quot;, modifiers.match({ &quot;DEFAULT&quot;: &quot;cfg//compiler:clang&quot;, &quot;cfg//os:windows&quot;: &quot;cfg//compiler:msvc&quot;, }), ]) # repo/foo/PACKAGE set_cfg_modifiers(cfg_modifiers = [&quot;cfg//os:macos&quot;]) # repo/foo/BUCK python_binary( name = &quot;bar&quot;, # ... metadata = {&quot;buck.cfg_modifiers&quot;: [&quot;cfg//os:windows&quot;]}, )  At the beginning, the configuration will be empty. When resolving modifiers, Buck will first resolve all modifiers for cfg//os:_ before resolving all modifiers for cfg//compiler:_. For OS, the linux modifier from repo/PACKAGE will apply first, followed by macos modifier from repo/foo/PACKAGE and windows modifier fromrepo//foo:bar's target modifiers, so repo//foo:bar will end up withcfg//os:windows for cfg//os:_ in its configuration. Next, to resolve compiler modifier, the modifiers.match from repo/PACKAGE will resolve tocfg//compiler:msvc since existing configuration is windows and apply that as the modifier. The target configuration for repo//foo:bar ends up with windows and msvc. However, suppose user invokes repo//foo:bar?linux on the command line. When resolving OS modifier, the linux modifier from cli will override any existing OS constraint and insert linux into the configuraiton. Then, when resolving the compiler modifier, the modifiers.match will resolve to cfg//compiler:clang, giving clang and linux as the final configuration. Because command line modifiers will apply at the end, they are also known as required modifiers. Any modifier specified on the command line will always override any modifier for the same constraint setting specified in the repo. The ordering of constraint setting to resolve modifiers is determined based on dependency order of constraints specified in the keys of the modifiers.matchspecified. Because some modifiers match on other constraints, modifiers for those constraints must be resolved first. In the previous example, because compiler modifier matches on OS constraints, Buck will resolve all OS modifiers before resolving compiler modifiers. modifiers.match that ends up with a cycle of matched constraints (ex. compiler modifier matches on sanitizer but sanitizer modifier also matches on compiler) will be an error. "},{"title":"Conditional Modifiers​","type":1,"pageTitle":"[RFC] Configuration Modifiers","url":"/docs/rfcs/cfg-modifiers/api/#conditional-modifiers","content":"Modifiers have 3 types of conditional modifiers that allow for powerful compositions. Each operator is a function that accepts a dictionary where the keys are the conditionals and values are modifiers. modifiers.match. Introduced in the previous sections, this is capable of inserting constraints based on constraints in the existing configuration. modifiers.match_rule. This is capable of selecting based on the rule name (also known as rule type). The keys are regex patterns to match against the rule name or &quot;DEFAULT&quot;. Partial matches are allowed. modifiers.match_host. This selects based on the host configuration, whereasmodifiers.match selects based on the target configuration. This host configuration is constructed when resolving modifiers. modifiers.match_hostis important to making buck build work anywhere on any platform. For example, when the OS to configure is not specified, it's best to assume that the user wants to target the same OS as the host machine. NOTE: match_rule and match_host are currently not implemented. An example using modifiers.match_rule and modifiers.match_host is as follows. # root/PACKAGE # We want OS to target the host machine by default. # Ex. build linux on linux machine, build windows on windows machine, # and build mac on mac machine. # However, if the rule is apple or android specific, then we should # always be building for apple/android as OS, no matter the host # configuration. set_cfg_modifiers(cfg_modifiers = [ modifiers.match_rule({ &quot;apple_.*&quot;: &quot;cfg//os:iphone&quot;, &quot;android_.*&quot;: &quot;cfg//os:android&quot;, &quot;DEFAULT&quot;: host_select({ &quot;cfg//os:linux&quot;: &quot;cfg//os:linux&quot;, &quot;cfg//os:macos&quot;: &quot;cfg//os:macos&quot;, &quot;cfg//os:windows&quot;: &quot;cfg//os:windows&quot;, }), }), ])  On select resolution, Buck's select currently requires unambiguous keys in the dictionary and resolves to the key with the most refined match. The select operators used in modifiers will diverge from this and implement a &quot;first-match&quot; behavior, where select resolves to the first condition that evalutes to true in the dictionary. "},{"title":"Legacy Target platform​","type":1,"pageTitle":"[RFC] Configuration Modifiers","url":"/docs/rfcs/cfg-modifiers/api/#legacy-target-platform","content":"Target platform (--target-platforms flag or default_target_platformattribute) will be a deprecated way of specifying configuration and will be killed once all use cases migrate to modifiers. To maintain backwards compatibility with target platforms during the migration process, modifier resolution will take into account the target platform specified. This allows for an easy migration where modifiers can be introduced one at a time without reaching feature parity of target platform. If a target's modifiers resolve to an empty configuration, then Buck will reuse the target platform as the configuration. If modifiers resolve to a non-empty configuration, then Buck look for any constraint in the target platform not covered by a constraint setting from the modifier configuration and add those to the configuration. For example, suppose in the previous example, the target platform for repo// foo:bar includes cfg//sanitizer:asan, then this constraint will be inserted into the configuration since no modifier covered the sanitizer constraint setting. "},{"title":"Debugging modifiers​","type":1,"pageTitle":"[RFC] Configuration Modifiers","url":"/docs/rfcs/cfg-modifiers/api/#debugging-modifiers","content":"NOTE: below is unimplemented. Because many layers of modifiers can be applied before obtaining a final configuration, it is important that modifier resolution is easy to debug and understand. Here are some ways that modifier resolution can be interpreted. buck2 audit modifiers command. There will be a buck2 audit modifierscommand to show all PACKAGE, target, and required modifiers for a target. It can also show configuration changes from modifier resolution process if requested by the user. Starlark print statements or debugger. Modifier resolution process will be implemented in Starlark in prelude. This means that any user can use any of the existing way to debug starlark (ex. print statements, Starlark debugger in VSCode) to debug the resolution process. "},{"title":"How configuration modifiers differ from transitions​","type":1,"pageTitle":"[RFC] Configuration Modifiers","url":"/docs/rfcs/cfg-modifiers/api/#how-configuration-modifiers-differ-from-transitions","content":"Modifiers are largely inspired by configuration transitions. The difference between modifier and transition is that a transition can change the configuration of any target in the graph, but a modifier can only change the configuration of a top-level target. In other words, if you have target A that depends on target B and you request a build of A, then A's target configuration would be resolved via modifiers and propagated down to B, but dep B would not do its own modifier resolution. When a top-level target goes through a per-rule transition, that transition is applied after modifiers are resolved. Below are some examples that show when to use modifier and when to use transition. Python version should be modeled as a transition and not modifier. Suppose we have python_binary A nested as a resource of another python_binary B. A should not inherit the python version from B, so a transition is needed to change A's python version when depended on by B.Library target should use modifiers and not transitions. A C++ library target should always inherit the configuration of its parent C++ binary when it is used as a dep, but a top-level C++ library target can still have its configuration changed via modifiers when requested from command line. In the future, we may add support for modifier transition, which can transition via modifiers, but that is out of the scope of this RFC. "},{"title":"@configuration syntax","type":0,"sectionRef":"#","url":"/docs/rfcs/drafts/configuration-at-syntax/","content":"","keywords":""},{"title":"What​","type":1,"pageTitle":"@configuration syntax","url":"/docs/rfcs/drafts/configuration-at-syntax/#what","content":"Command buck2 build //foo:bar@config//platform:linux-x86_64  should be equivalent to current syntax: buck2 build //foo:bar --target-platforms=//platform:linux-x86_64  "},{"title":"Why​","type":1,"pageTitle":"@configuration syntax","url":"/docs/rfcs/drafts/configuration-at-syntax/#why","content":"Might be convenient if we define global (or per-target, as proposed intarget configuration discovery RFC) alias. For example, if there's an alias release=//config:linux-x86_64-release  The command above can be expressed as: buck2 build //foo:bar@release  Additionally, if we haveconfiguration expression RFCimplemented, we can do something like: buck2 build //foo:bar@release+gcc  "},{"title":"Possible future extensions​","type":1,"pageTitle":"@configuration syntax","url":"/docs/rfcs/drafts/configuration-at-syntax/#possible-future-extensions","content":"For now, at-syntax only applies to command line arguments of build/targets/run/test commandsprobably cquery query It would be reasonable to expect that this syntax should be allowed anywhere we need a target (e.g. in deps attribute), but this is out of scope of this proposal. "},{"title":"Digest Kinds","type":0,"sectionRef":"#","url":"/docs/rfcs/drafts/digest-kinds/","content":"","keywords":""},{"title":"Use cases:​","type":1,"pageTitle":"Digest Kinds","url":"/docs/rfcs/drafts/digest-kinds/#use-cases","content":"Buck2 needs to support more than just SHA1 for open-sourcing, since publicly available RE providers use SHA256.Internally, we want to migrate to (potentially keyed) Blake3, and there will be a transition period where we need to support both Blake3 and SHA1. "},{"title":"Proposed plan​","type":1,"pageTitle":"Digest Kinds","url":"/docs/rfcs/drafts/digest-kinds/#proposed-plan","content":"Make all the ways in which Buck2 ingests digests either configurable or explicit about the type of digest they expect. Internally, we may keep track of digest types for debugging purposes, but we will never compute more than one digest. It follows that we won't expose configuration for the digests we output (namely: to use on RE): if we only have one digest for each blob, making it configurable has no utility since you never have a choice about the hash to use. "},{"title":"Implementation​","type":1,"pageTitle":"Digest Kinds","url":"/docs/rfcs/drafts/digest-kinds/#implementation","content":""},{"title":"Hashes received from RE​","type":1,"pageTitle":"Digest Kinds","url":"/docs/rfcs/drafts/digest-kinds/#hashes-received-from-re","content":"For interactions with RE, we'll expose two configurations (this can be on the CommandExecutorConfig): Preferred hash to use when Buck2 is doing the hashing (e.g. hashing directories).Accepted hashes. We'll use the format of the digests we receive from RE (in particular their size) to infer what algorithm they used (remember: the RE API provides no way of knowing the format of a digest, it's just a string). "},{"title":"Hashes of files​","type":1,"pageTitle":"Digest Kinds","url":"/docs/rfcs/drafts/digest-kinds/#hashes-of-files","content":"We'll expose the hash to use via a buckconfig. Our things-that-produce-hashes-of-files should either use the config to choose how they hash, or fail if they cannot provide the right hash format (e.g. that'll be true of Eden I/O). "},{"title":"Hashes of directories​","type":1,"pageTitle":"Digest Kinds","url":"/docs/rfcs/drafts/digest-kinds/#hashes-of-directories","content":"This one gets a little tricky. Our directories currently have an implementation of fingerprinting that receives only the directory as input, so some refactoring is in order. We have two options: Pick the hashing algorithm based on the contents of the directory (pick one that's already used). Dealing with empty directories is a bit annoying.Refactor the directory implementation and have directories parameterized over their fingerprints, not their hasher. The first one is easier but has the downside of not working with keyed Blake3 (because you don't have a way to bring in the key), so I'm aiming for the second implementation for now. "},{"title":"RFC: TestInfo v2","type":0,"sectionRef":"#","url":"/docs/rfcs/drafts/test-info-v2/","content":"RFC: TestInfo v2 A stub RFC for TestInfo v2 to track lessons learned about TestInfo v1. The stack starting D36339960 contains the original code for the TestInfo and templated test API experiment.","keywords":""},{"title":"Universal Configuration Naming Function","type":0,"sectionRef":"#","url":"/docs/rfcs/drafts/universal-cfg-naming/","content":"","keywords":""},{"title":"Context​","type":1,"pageTitle":"Universal Configuration Naming Function","url":"/docs/rfcs/drafts/universal-cfg-naming/#context","content":"NOTE: The configuration name consists of a readable string followed by the hash of the configuration. The readable string is technically the PlatformInfoname. For sake of ease of writing, this doc uses configuration name and platform name interchangeably to describe this concept. Currently, there are 3 ways to create and name a configuration. A platform target defines a configuration, and the platform target label becomes the platform name.A transition function defines the configuration and generates a name for the configuration.When a modifier is used, the cfg constructor function for modifiers defines the configuration and its name. There is currently a single naming function that generates all modifier-based configuration names. Modifiers are intended to replace platforms, so in the future all configuration names will be generated. Unfortuately, most of the generated names today used today in transitions are not very good. Problems that I've seen in practice include: Configuration names barely contain any useful information about the configuration. This happens a lot in transitions. For example, the android split CPU architecture transition names the generated configurations &quot;x86_64&quot; and &quot;arm64&quot;, which tells very little about the configuration beyond the CPU architectures it splits on.Transition function incorrectly retains the old configuration name that is no longer relevant, misleading the user about what this configuration actually does. I've seen this happen where a configuration has py3.8 in name but the python version constraint stored is actually py3.10. "},{"title":"Proposal​","type":1,"pageTitle":"Universal Configuration Naming Function","url":"/docs/rfcs/drafts/universal-cfg-naming/#proposal","content":"Register a single Starlark function to define all configuration names. This Starlark function would accept a ConfigurationInfo and return a string for the name of the ConfigurationInfo. # Example def name(cfg: ConfigurationInfo) -&gt; str: # ...  PlatformInfo is no longer available in Starlark. Any place that previously uses a PlatformInfo will now use ConfigurationInfo instead. Buck2 will invoke this function each time it encounters a new ConfigurationInfo to define its name. This function will attempt to provide a useful name based on the constraints in the configuration, which mitigates the issue of short or misleading configuration names. There are some risks that there will be high amount of code complexity in a function if all configurations are named by one function. This function will most likely be registered via a set_cfg_name function or something callable from root PACKAGE file or potentially prelude. "},{"title":"Return error in ProviderCollection[] on undeclared provider","type":0,"sectionRef":"#","url":"/docs/rfcs/implemented/provider-collection-at/","content":"","keywords":""},{"title":"Why​","type":1,"pageTitle":"Return error in ProviderCollection[] on undeclared provider","url":"/docs/rfcs/implemented/provider-collection-at/#why","content":"Better diagnostics when accessing unknown provider. E. g. when writing: ctx.attrs.foo[UnknownInfo].bar  Currently, the error is: Object of type `NoneType` has no attribute `bar`  Instead, the error will be something like: provider collection does not contain `UnknownInfo`, defined providers are `FooInfo`, `BarInfo`.  "},{"title":"Bazel​","type":1,"pageTitle":"Return error in ProviderCollection[] on undeclared provider","url":"/docs/rfcs/implemented/provider-collection-at/#bazel","content":"In bazel, [] on unknown provider is an error, like this: Error: &lt;target //optional_provider:n2&gt; (rule '_sum') doesn't contain declared provider 'UnknownInfo'  "},{"title":"plugin-deps","type":0,"sectionRef":"#","url":"/docs/rfcs/drafts/plugin-deps/","content":"","keywords":""},{"title":"Plugin Deps​","type":1,"pageTitle":"plugin-deps","url":"/docs/rfcs/drafts/plugin-deps/#plugin-deps","content":""},{"title":"Background on Rust proc macros​","type":1,"pageTitle":"plugin-deps","url":"/docs/rfcs/drafts/plugin-deps/#background-on-rust-proc-macros","content":"Rust proc macros are compiler plugins. They are a special kind of crate that is compiled to a dylib, which is then loaded by the compiler when another crate depends on the proc macro. Notably, like all Rust crates, proc macros may also be re-exported. This means that if there is a dependency chain likebin -&gt; lib -&gt; proc_macro, the proc macro must be made available when compiling the binary, even though it does not appear directly in the dependencies. Proc macros have posed a challenge to buck2, for two reasons: Rust users generally expect to not have to distinguish between proc macros and normal crates when specifying their dependencies. This means it is not easily possible to make the lib -&gt; proc_macro edge an exec_dep.bin and lib might end up with different exec platforms. This means that even if proc_macro were to be correctly configured as an exec dep oflib, that configuration might be wrong for bin. FIXME: Other use cases for this feature "},{"title":"Plugins deps​","type":1,"pageTitle":"plugin-deps","url":"/docs/rfcs/drafts/plugin-deps/#plugins-deps","content":"This RFC proposes introducing a concept of &quot;plugin deps&quot; to solve this problem. Plugin deps are deps that can be propagated up the build graph at configuration time, instead of at analysis time. Here's what this looks like: First, plugin deps come in &quot;kinds.&quot; Plugin kinds can be created likeMyKind = plugins.kind(). These act as identifiers that can be used to divide all the possible plugin deps up however users need to. Each configured target has plugin lists: There is one list for each plugin kind. The elements of these list are an unconfigured target, together with ashould_propagate bool. The same unconfigured target cannot appear more than once. In other words, this is a HashMap&lt;String, HashMap&lt;Target, bool&gt;&gt;. We need to describe two things: How to use these list, and how to create them. "},{"title":"Using a target's plugin lists​","type":1,"pageTitle":"plugin-deps","url":"/docs/rfcs/drafts/plugin-deps/#using-a-targets-plugin-lists","content":"Using plugin lists is very simple: The rule sets uses_plugins = [MyKind] when declared. Setting this make the elements of the plugin list for the given kind appear as exec deps on the configured nodes for this rule. This also means that the plugins participate in exec dep resolution like all other exec deps. Analysis will then be able to access a list of the providers for each of the plugins via ctx.plugins[MyKind]. The should_propagate bool that is associated with each element of the list is ignored at this stage. "},{"title":"Creating a target's plugin lists​","type":1,"pageTitle":"plugin-deps","url":"/docs/rfcs/drafts/plugin-deps/#creating-a-targets-plugin-lists","content":"Plugin lists are created by accumulating from two sources: The first of these is direct plugin deps. They are defined via a newattrs.plugin_dep(kind = &quot;foo&quot;). This attribute (like other deps), is set to a label when the target is declared. It then resolves as follows: In the unconfigured graph: To the appropriate unconfigured targetIn the configured graph: To the label of the unconfigured target. In other words, this will still be displayed in buck2 cquery -A, but will not appear in the deps.During analysis: Also to the unconfigured target label. The target that appears in the plugin_dep is added to the MyKind plugin list with should_propagate set. The second way to add to the plugin list is by inheriting from regular deps. This works as follows: Elements of the plugin lists for which theshould_propagate value is true are made available to the immediate rdeps of a configured target. The rdep can use them by setting pulls_plugins = [MyKind]in the appropriate attrs.dep() invocation. This will make the targets appear in the plugin list for the rdep with should_propagate unset. Alternatively, the rdep can set pulls_and_pushes_plugins = [MyKind] to add the targets to the plugin lists with should_propagate set to true. This enables transitive propagation further up the configured graph. To decide later: Should we allow plugin rules to appear in regular/exec deps, with no special behavior? I don't see why not. "},{"title":"Example: Proc macros​","type":1,"pageTitle":"plugin-deps","url":"/docs/rfcs/drafts/plugin-deps/#example-proc-macros","content":"RustProcMacro = plugins.kind() rust_proc_macro_propagation = rule( impl = _propagation_impl, attrs = { &quot;actual&quot;: attrs.plugin_dep(kind = RustProcMacro), }, ) rust_library = rule( impl = _similar_to_before, # See some notes below attrs = { &quot;proc_macro&quot;: attrs.bool(default = False), # Same as before &quot;deps&quot;: attrs.list(attrs.dep(pulls_and_pushes_plugins = [RustProcMacro])), # Here we avoid `pulls_and_pushes` because we do not want to make these deps available to rdeps &quot;doc_deps&quot;: attrs.list(attrs.dep(pulls_plugins = [RustProcMacro])), }, uses_plugins = [RustProcMacro] ) rust_binary = rule( impl = _similar_to_before, # See some notes below attrs = { &quot;deps&quot;: attrs.list(attrs.dep(pulls_plugins = [RustProcMacro])), &quot;doc_deps&quot;: attrs.list(attrs.dep(pulls_plugins = [RustProcMacro])), }, uses_plugins = [RustProcMacro] ) def _propagation_impl(ctx): return [ DefaultInfo(default_outputs = []), # During analysis for rust libraries, the providers for proc macros will appear in # `ctx.plugins`. However, this includes the transitive and direct proc macro deps, as # well as the transitive and direct proc macro doc-deps. Analysis needs to be able to # distinguish between all of these though. # # This dummy provider is passed to allow for precisely that. Generally, it will be passed # everywhere where the providers of Rust proc macros are currently passed. That ensures that # analysis on `rust_library` and `rust_binary` have all the information they need about # where the plugin &quot;entered the dependency graph.&quot; RustProcMacroMarker(ctx.attrs.actual), ] ### TARGETS # Expanded by macro rust_library( name = &quot;p1_REAL&quot;, proc_macro = True, ) # Expanded by macro rust_proc_macro_propagation( name = &quot;p1&quot;, actual = &quot;:p1_REAL&quot;, ) # Expanded by macro rust_library( name = &quot;p2_REAL&quot;, proc_macro = True, ) # Expanded by macro rust_proc_macro_propagation( name = &quot;p2&quot;, actual = &quot;:p2_REAL&quot;, ) rust_library( name = &quot;l&quot;, deps = [&quot;:p1&quot;], doc_deps = [&quot;:p2&quot;], ) rust_binary( name = &quot;b&quot;, deps = [&quot;:l&quot;], )  Analysis for :l will see: deps which contains only the RustProcMacroMarker(&quot;p&quot;)doc_deps which contains only the RustProcMacroMarker(&quot;p2&quot;)ctx.plugins[RustProcMacro] which contains the providers of :p1_REAL and:p2_REAL, correctly configured for the execution platform of :l. Analysis for :b will see: deps which contain the providers of l ctx.plugins[RustProcMacro] which contain the providers of :p1_REAL, also correctly configured for its own execution platform (which may be different from :l's). Note that because rust_library does not re-push doc deps, :b will not see :p2_REAL. As a result, the implementation of the rust_library rule should not propagate the providers of its proc macro deps (unlike its regular deps). There is one downside to this solution: buck2 build :p does absolutely none of the things that the user is probably expecting. They need buck2 build :p_REAL. That's a bit sad. Thankfully directly building proc macros is not that important a use case? Alias​ It is already the case today that we can't use the normal alias rule on toolchains. A similar situation crops up here, where aliasing a target that pushes plugins causes the plugins to &quot;get lost.&quot; The right solution to this is to probably allow plugins.ALL as a special value on pulls_plugins andpulls_and_pushes_plugins, and then set that for the alias rule. "},{"title":"Alias","type":0,"sectionRef":"#","url":"/docs/rule_authors/alias/","content":"","keywords":""},{"title":"alias​","type":1,"pageTitle":"Alias","url":"/docs/rule_authors/alias/#alias","content":"The alias rule has the following relevant attributes: name - (required) what the actual's label should be aliased as.actual - (required) a target label.default_host_platform - default host platform to use for the aliased target. Example filegroup( name = &quot;foo&quot;, srcs = [&quot;foo.txt&quot;], ) alias( name = &quot;other_foo&quot;, actual = &quot;:foo&quot;, )  "},{"title":"versioned_alias​","type":1,"pageTitle":"Alias","url":"/docs/rule_authors/alias/#versioned_alias","content":"The versioned_alias rule has the following relevant attributes: name - (required) what the actual's label should be aliased as.versions - (required) a map of versions to their respective versioned target labels. Under the hood, any versioned parameters from the versioned_alias's underlyingactual are translated into their select-based equivalents, which rely on constraint settings added to the target platform. Example versioned_alias( name = &quot;foo&quot;, versions = { # Target labels for foo versions &quot;1.1&quot;: &quot;//path/to/lib/1.1:foo&quot;, &quot;1.2&quot;: &quot;//path/to/lib/1.2:foo&quot;, }, visibility = [ &quot;PUBLIC&quot;, ], )  "},{"title":"configured_alias​","type":1,"pageTitle":"Alias","url":"/docs/rule_authors/alias/#configured_alias","content":"The configured_alias rule has the following relevant attributes: name - (required) what the actual's label should be aliased as.configured_actual - a configured label (mapped to a configured dep under the hood so the providers can be simply forwarded).fallback_actual - if configured_actual is not set, then fallback to this value, which is an unconfigured dep. If configured_actual is not set, thenfallback_actual must be set.platform - the platform to build the aliased target with. note The actual field is available for configured_alias but it is not used under the hood (to keep compatibility of output format with Buck1 queries). Outside of simply pointing at another target, this target has one other useful feature - it contains a platform argument. This makes the alias rule useful for two distinct scenarios: Configuration switching during the build. For example, there is an iOS target that needs to build a dependency for WatchOS so it can include it in the bundle. This can be represented by the iOS target having a dependency on an alias of the Watch app with platform = &quot;//the/desired/watchos:platform&quot;.Using a target to refer to another in a non-standard configuration. For example, if you want to have an experimental version of an app, you could represent that as an alias with an 'experimental' configuration pointing to the original target. Example configured_alias( name = &quot;foo-with-platform1&quot;, actual = &quot;//lib:foo&quot;, platform = &quot;//some_config:platform1&quot;, visibility = [&quot;PUBLIC&quot;], )  "},{"title":"Package-local values","type":0,"sectionRef":"#","url":"/docs/rfcs/package-local-values/","content":"","keywords":""},{"title":"Why​","type":1,"pageTitle":"Package-local values","url":"/docs/rfcs/package-local-values/#why","content":"DevX people want to have some per-directory configuration files, accessible from Starlark macros. For example, a project NNN may want to switch to building using LLVM 15 by default. End users would want to have an easy instruction how to do that, after DevX people provided instructions and infrastructure for that. "},{"title":"What we have now​","type":1,"pageTitle":"Package-local values","url":"/docs/rfcs/package-local-values/#what-we-have-now","content":"Currently, in fbcode, we have get_modes mechanism. get_modes symbol is registered in per-package implicit symbols,here. This symbol can be accessed from macros usingimplicit_package_symbol function. get_modes functions are package-local, but all BUILD_MODE.bzl files need to be registered in global buckconfig, which is not ideal. Proposed per-package properties can replace get_modes mechanism. "},{"title":"API​","type":1,"pageTitle":"Package-local values","url":"/docs/rfcs/package-local-values/#api","content":""},{"title":"PACKAGE files​","type":1,"pageTitle":"Package-local values","url":"/docs/rfcs/package-local-values/#package-files","content":"Before evaluating BUCK file, buck2 will evaluate all PACKAGE files in the same directory and all parent directories. Absent PACKAGE files are treated as empty files. All relevant PACKAGE files are executed sequentially from the root directory to the current directory (but unrelated PACKAGE files can be executed in parallel). Evaluating PACKAGE files sequentially provides additional guarantees, for example, attempt to override a property (unless explicitly requested) should fail with Starlark call stack. Each PACKAGE file is evaluated at most once (like bzl file). PACKAGE files may load arbitrary bzl files. BUCK-specific functions called in bzl files (like rule functions) are available, but calling functions fromPACKAGE files is an error. This way, bzl files are evaluated only once regardless of whether they are loaded from PACKAGE or BUCK file. "},{"title":"API​","type":1,"pageTitle":"Package-local values","url":"/docs/rfcs/package-local-values/#api-1","content":"PACKAGE files have a global function: PACKAGE file API​ def write_package_value( name: str, value: &quot;&quot;, overwrite: bool = False, ): ...  Name is a string which must contain exactly one dot symbol (just to enforce code style). Value is an arbitrary Starlark value, for example, an integer, a list of integer, a struct or a function. When overwrite is False (default), attempt to overwrite per-package value defined in parent PACKAGE file will fail. Written values are frozen when PACKAGE file evaluation is finished. Note write_package_value symbol exists in bzl globals, and it can be called from bzl file in context of PACKAGE evaluation, but callingwrite_package_file is an error on context of BUCK evaluation. Modifying PACKAGE file logically invalidates the BUCK file of this package, and all PACKAGE and BUCK files of subpackages. However, BUCK file evaluation may track which package-local values were accessed and only invalidate BUCK files which were potentially affected (similarly to how we do it with buckconfigs, with individual properties being projection keys). BUCK file API​ BUCK files (and bzl files included from BUCK files) have a global function: def read_package_value( name: str, ): ...  This function returns the nearest value registered per package, or None is such value does not exist. This function is available in bzl files, but attempt to call this function in context of PACKAGE file evaluation results in an error. This restriction can be lifted in the future. Per-package values are not accessible as global symbols in BUCK files. We may reconsider it in the future. "},{"title":"read_config​","type":1,"pageTitle":"Package-local values","url":"/docs/rfcs/package-local-values/#read_config","content":"PACKAGE files may call read_config function. "},{"title":"Configurations","type":0,"sectionRef":"#","url":"/docs/rule_authors/configurations/","content":"","keywords":""},{"title":"Context​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#context","content":"Buck configurations provide an API to express the different ways in which projects and targets can be built. A configuration consists of a set of constraints and config settings (values from buckconfig). These are determined by a base platform that sets the initial values and then a series of transitions that may change them. The common way that users are exposed to configurations is in select()invocations where the resolution is based on the configuration. A build may involve many configurations. A particular target label (//:foo) may end up with multiple instances in the configured graph with different configurations. "},{"title":"Selectable attributes​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#selectable-attributes","content":"Almost all rule attributes can be set to a select() value; such an attribute is 'selectable'. These attributes' final resolved values will depend on the configuration. There are some attributes that cannot use a select(); such attributes are termed 'not selectable'. Examples include attributes that buck needs to read from the unconfigured node (such as name and default_target_platform) and attributes that are used by platform() rules and their dependencies (see below). "},{"title":"Selectable resolution​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#selectable-resolution","content":"Resolving selectable attributes is pretty straightforward, it happens when constructing the 'configured target node'. At that point, the full configuration is available so Buck can lookup whether each constraint in the select is satisfied or not. If multiple conditions of the select() match, then the select will be resolved to the 'most refined' of the conditions that match. A set of constraints (as in a config_setting) is said to 'refine' another if it is a superset of that other's constraints. The 'most refined' of a set is then the condition that refines all the others. If there is no 'most refined' condition of the matching ones, it is an error. "},{"title":"Target Platform Resolution​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#target-platform-resolution","content":"In the event that targets are provided on the command line, or when there is no indication of what configuration the target will be built in, configurations are determined by performing 'target platform resolution' on the unconfigured target labels. The target platform resolution for a target //:foo works as follows: Look up (unconfigured) target node for //:foo.If the command has a --target-platforms flag, use that.If there's a default_target_platform attribute, use that.Else, use the cell's default platform. This is performed independently for any targets that need a platform. Since this resolution is done without a configuration, it means that thedefault_target_platform attribute is not selectable. This target platform will form the initial configuration for the node. "},{"title":"Configuration propagation​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#configuration-propagation","content":"Once the top-level nodes have been configured via the target platform resolution, the configuration is propagated to dependencies (possibly altered by transitions). note The target platform resolution is not applied to all nodes in the graph. "},{"title":"Transitions​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#transitions","content":"A transition transforms a configuration by adding or changing constraint values and config settings or by setting an entirely new underlying target platform. For more details, see Configuration transitions. "},{"title":"ConfigurationInfo, platform() analysis, and more​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#configurationinfo-platform-analysis-and-more","content":"The definition of a platform (either execution or target) is done with aplatform rule instance. The configuration is actually part of the analysis result of the platform target (the ConfigurationInfo provider instance). This is convenient from an implementation standpoint, but it leads to a situation where some nodes are analyzed with an 'unbound' Configuration. All the rule types involved in defining a platform may be analyzed with an unbound configuration (platform(), config_setting(), constraint_setting(), and so on). These are sometimes called 'configuration rules'. This means that all the attributes of these rules are not selectable. Configurations also reference a few other provider instances such asConstraintSettingInfo. All of these end up being potentially produced in a context with an unbound configuration. Using analysis for this also means that 'configuration' and 'analysis' are not distinct phases within a build (although they are still distinct for a node and are still conceptually useful). "},{"title":"Configurations and output paths​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#configurations-and-output-paths","content":"Since a target may appear within a build in multiple different configurations, output paths cannot be derived based on just targets (as multiple actions would map to the same outputs). For this reason, the target and the configuration are encoded into output paths. The configuration is currently represented as a hash of its values (a 'hashed buck-out'). "},{"title":"Target platform compatibility​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#target-platform-compatibility","content":"All (non-configuration) rules support a target_compatible_with attribute. In addition, the rule itself can define target_compatible_with constraints that affect all instances. The target_compatible_with attribute is a list of constraints/config settings and it is selectable. Target platform compatibility is transitive, all dependents of an incompatible target are incompatible. In other words, a node is compatible if and only if the node itself and all of its transitive dependencies are compatible. In buck, this is implemented by graph configuration returning either a configured target node or an indicator that the node is incompatible with the target platform. "},{"title":"Buck v1 compatibility​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#buck-v1-compatibility","content":"Buck2 also supports the Buck v1 legacy compatible_with field on nodes but it has different behavior. In summary: compatible_with: List of constraints, where any of them must match the configuration to be compatible.target_compatible_with: List of constraints, where all of them must match the configuration to be compatible. "},{"title":"Incompatible target skipping​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#incompatible-target-skipping","content":"In a build-like command where a non-literal target pattern is provided (for example, buck build //: or buck build //foo/...), the target pattern will be resolved to a set of unconfigured targets. Those targets will then go throughtarget platform resolution. If any of those targets resolve to a platform where they are incompatible, building them will be skipped. Users generally expect and prefer this behavior to needing to explicitly specify only the targets that can build in their current context. If an explicitly specified literal is incompatible, it is an error. The implementation checks compatibility when looking up the analysis results for configured nodes requested (in the non-ignored flow, it uses that analysis result to lookup the default outputs and build them). "},{"title":"Execution platforms​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#execution-platforms","content":"Execution platforms/configurations are used to represent the platforms where build execution happens. These are defined in a similar manner to target platforms. These may or may not be what one would logically consider different 'platforms'. For example, there could be multiple different execution platforms that all execute things similarly on the local machine. A build configures a fixed list of one or more execution platforms. "},{"title":"Execution deps​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#execution-deps","content":"Some target deps are 'execution deps'. These are the dependencies of the target that should be built for the execution platform. For example, a compiler or other build tool would be an execution dep. This includes all exe macro deps (for example, $(exe //:tool)) and includes all attrs.exec_dep() deps. "},{"title":"Toolchain deps​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#toolchain-deps","content":"In addition to attrs.exec_dep(), there are attrs.toolchain_dep(), which are similar but differ in an important way. These nodes don't select their execution platform, but instead have it forced on them by whatever includes them; hence, it must be recorded in the configured target label. The execution platform resolution sees through them. In other words, attrs.toolchain_dep() is like a mix of attrs.dep() andattrs.exec_dep(): it inherits target platform like attrs.dep() (so anyselect()s on the target of the attrs.toolchain_dep() will evaluate as if they were on the target containing the attrs.toolchain_dep() - the target platform gets inherited as normal) and any attrs.exec_dep()s of theattrs.toolchain_dep() target become attrs.exec_deps() on the dependent of target the attrs.toolchain_dep() (they get passed up the dep tree, so participate in exec platform resolution). This is illustrated in the following example: target( name = &quot;A&quot;, toolchain = attrs.toolchain_dep(default = &quot;:B&quot;), ) target( name = &quot;B&quot;, tool = attrs.exec_dep(default = &quot;:C&quot;) )  The above means that :C will be an execution dependency of :A and anyselect()s defined in :B would be evaluated against the same target platform as :A (as target platform gets inherited by attrs.toolchain_dep()s). "},{"title":"Running non-execution deps​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#running-non-execution-deps","content":"If you have a binary that you want to run, but it isn't a build tool, then you should use $(exe_target //:binary) rather than $(exe //:binary). That will run the same binary that you'd get from buck2 build, rather than one that is built for the execution platform. The path macros vary along two axes: Path Source: either DefaultInfo or RunInfo providersConfiguration: inherits the configuration or transitions to an execution platform configuration Specifically: $location: DefaultInfo path source, inherits configuration$exe: RunInfo path source, exec platform configuration$exe_target: RunInfo path source, inherits configuration "},{"title":"Execution platform resolution​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#execution-platform-resolution","content":"During analysis, unlike target platform resolution, every configured node undergoes execution platform resolution independently (see exception below). This means that even for a specific target platform, different nodes in the graph can be built on different execution platforms. This works roughly as follows: next: for platform in execution_platforms: if exec_compatible_with(target, platform): for dep in target.execution_deps(): if !target_compatible_with(dep, platform): continue next return platform return err  One important note here is that until the execution platform has been resolved,the configuration for execution deps is not known. Only after execution platform has been resolved can the execution deps be configured (also, analysis for them can only be performed at that point). For the normal use case, a particular configured target node performs execution platform resolution a single time. The execution platform is not encoded in output paths. Regarding target compatibility, imagine the following pseudo-code for thetarget_compatible_with() function above: def target_compatible_with(target, cfg): for constraint in target.target_compatible_with: if not satisfied(constraint, cfg): return False if len(target.compatible_with) &gt; 0: found_satisfied_constraint = False for constraint in target.compatible_with: if satisfied(constraint, cfg): found_satisfied_constraint = True break if not found_satisfied_constraint: return False for (dep, dep_cfg) in direct_deps(target): # NB: recursive call if not target_compatible_with(dep, dep_cfg): return False return True  "},{"title":"Execution groups​","type":1,"pageTitle":"Configurations","url":"/docs/rule_authors/configurations/#execution-groups","content":"Execution groups are a future feature that will allow a rule to perform execution platform resolution multiple times and then specify in which of the resolved platforms each action runs in. "},{"title":"Configuration Transitions","type":0,"sectionRef":"#","url":"/docs/rule_authors/configuration_transitions/","content":"","keywords":""},{"title":"Transition rule​","type":1,"pageTitle":"Configuration Transitions","url":"/docs/rule_authors/configuration_transitions/#transition-rule","content":"Transition rules are defined in .bzl files using the transition built-in. The transition function creates a configuration-related object. Thetransition object is opaque, it does not have any operations, and can only be used as an argument to rule function or attribute constructor. Thetransition function call must be assigned to a global variable (this is similar to user-defined provider declarations). The transition function takes three arguments: implementation - a function.refs - references to configuration rules to be resolved and passed to the implementation function.split - (optional) bool flag (default False) to indicate whether transition is a split transition (used in per attribute transitions). The implementation function takes two arguments: platform - a configuration to transition.refs - resolved references as a struct. Example transition from ios to watchos (for example, to build a watchOS bundle as part of an iOS build): def _impl(platform: PlatformInfo.type, refs: struct.type) -&gt; PlatformInfo.type: # Operating system constraint setting. os = refs.os[ConstraintSettingInfo] # Watchos constraint value. watchos = refs.watchos[ConstraintValueInfo] # Remove operating system constraint from input platform. constraints = { s: v for (s, v) in platform.configuration.constraints.items() if s != os.label } # Add watchos constraint value. constraints[watchos.setting.label] = watchos # Construct configuration structure. new_cfg = ConfigurationInfo( # Updated constraints. constraints = constraints, # Keep original config values. values = platform.configuration.values, ) # And return new configuration, # or a dict of marker to configuration in case of split transition. return PlatformInfo( # ... supplying configuration label. label = &quot;&lt;transitioned-to-watch&gt;&quot;, configuration = new_cfg, ) iphone_to_watch_transition = transition(_impl, refs = { &quot;os&quot;: &quot;//constraints:os&quot;, &quot;watchos&quot;: &quot;//constraints:watchos&quot;, })  A transition function applied twice must produce the configuration identical to the configuration produced after applying transition once. assert tr(tr(platform=platform, refs=refs), refs=refs) == tr(platform=platform, refs=refs)  If this invariant is not held, certain operations produce incorrect and possibly infinite graphs. This is not yet enforced. "},{"title":"Per rule transition​","type":1,"pageTitle":"Configuration Transitions","url":"/docs/rule_authors/configuration_transitions/#per-rule-transition","content":"The rule function has an optional cfg attribute, which takes a reference to the transition object (created with the transition function; not a string). When such a rule is called, it is instantiated, not with the requested configuration, but with the requested configuration transformed with a given rule transition. For example, the transition for watchos when the iOS target depends on watchos resource: watchos_resource = rule( cfg = iphone_to_watch_transition, ... )  "},{"title":"Per attribute transition​","type":1,"pageTitle":"Configuration Transitions","url":"/docs/rule_authors/configuration_transitions/#per-attribute-transition","content":"The attrs object has two attribute constructors: attrs.transition_dep(cfg)attrs.split_transition_dep(cfg) These attributes are similar to the dep attribute. When dependencies are resolved for the rule instance, then they are resolved not with the rule instance configuration, but with the configuration transformed with the given transition. For split transition, each dependency is resolved into a dict of marker to providers. For example: android_binary = rule( ... attrs = { &quot;deps&quot;: attrs.list(attrs.split_transition_dep(cfg = cpu_split_transition), default = []), }, )  When the above is invoked as follows: android_binary( deps = [&quot;//foo:bar&quot;, &quot;//qux:quux&quot;], )  Then the rule implementation gets something like the following in the depsattribute: { [ { # Key in this dict is the marker returned from split transition impl function. &quot;arm64&quot;: &quot;providers for //foo:bar configured for arm64&quot;, &quot;armv7&quot;: &quot;providers for //foo:bar configured for armv7&quot;, }, { &quot;arm64&quot;: &quot;providers for //qux:quux configured for arm64&quot;, &quot;armv7&quot;: &quot;providers for //qux:quux configured for armv7&quot;, }, ] }  note It is an error to pass a split transition object to attrs.transition_dep and a non-split transition to attrs.split_transition_dep. "},{"title":"Per target transition​","type":1,"pageTitle":"Configuration Transitions","url":"/docs/rule_authors/configuration_transitions/#per-target-transition","content":"The Buck2 team is considering the implementation of per target transitions (that is, transitions referenced at a rule instantiation site as opposed to rule declaration site). No specific plans or APIs exists at the moment. It could be something like the following: cxx_binary( name = &quot;foo&quot;, cfg = &quot;//transitions:opengl-es-1.0&quot;, ... )  "},{"title":"Request transition on command line​","type":1,"pageTitle":"Configuration Transitions","url":"/docs/rule_authors/configuration_transitions/#request-transition-on-command-line","content":"For information, see RFC. "},{"title":"Access rule attributes in transition function implementation​","type":1,"pageTitle":"Configuration Transitions","url":"/docs/rule_authors/configuration_transitions/#access-rule-attributes-in-transition-function-implementation","content":"It might be useful for the transition function to be able to query rule attributes (for example, to perform transition to different configurations depending on java_version attribute). Both incoming (per rule) and outgoing (per dependency) transitions can access rule attributes. For outgoing transitions, transition rule implementation accesses the attributes of the target that has dependencies with transitions, not attributes of dependency targets. def _tr(platform, refs, attrs): # NB: There are some restrictions on what attrs can be made accessible: # - Only primitive values for now (providers are not resolved) # - Only unconfigured attributes for now attrs.my_list_attribute # == [12345, 67890] tr = transition( _tr, refs = {}, attrs = { &quot;my_list_attribute&quot;: attr.list(...), }, ) my_rule = rule(..., cfg=tr) my_rule( ..., my_list_attribute = [12345, 67890], )  "},{"title":"Dep Files","type":0,"sectionRef":"#","url":"/docs/rule_authors/dep_files/","content":"","keywords":""},{"title":"Use Cases​","type":1,"pageTitle":"Dep Files","url":"/docs/rule_authors/dep_files/#use-cases","content":"Dep files are used to make dependencies finer grained than what exists in the target graph, but they're not a substitute for avoiding unused dependencies. They're often useful when targets export many outputs (such as C++ headers) that aren't all used by all their dependents. Dep files are currently used to skip recompilation steps in C++ when an unused header changed. They're also used in Java to skip recompilation when an unused class changed. "},{"title":"Using dep files​","type":1,"pageTitle":"Dep Files","url":"/docs/rule_authors/dep_files/#using-dep-files","content":"To use dep files, you need to do the following: Declare what output is a dep file and associate it with your command.Declare which inputs are covered by the dep file (this can be a subset of your inputs).Have your command produce the dep file in a format Buck2 can use. You must also enableDeferred Materialization to use dep files. "},{"title":"Declaring the dep files and associating inputs​","type":1,"pageTitle":"Dep Files","url":"/docs/rule_authors/dep_files/#declaring-the-dep-files-and-associating-inputs","content":"To declare a dep file and associate it with your command, you need to tag your artifacts. Specifically, you'll tag the output (the dep file) and the inputs it covers, as shown in the following code: # First, create a tag headers_tag = ctx.actions.artifact_tag() # Then, tag inputs and the dep file itself in your command line. # You do this using the `tag_artifacts` method on your tag. # This method does not mutate the input, it wraps it, so you use the output. # Any command-line-arg-like can be tagged. tagged_headers = headers_tag.tag_artifacts(headers) dep_file = ctx.actions.declare_output(&quot;deps&quot;).as_output() tagged_dep_file = headers_tag.tag_artifacts(dep_file) # Finally, declare your action. # Use the tagged artifacts as you would regular command-line-arg-likes. # Pass the tag in `dep_files` and give a name (this is used for logging). ctx.actions.run( [&quot;mycc&quot;, &quot;-I&quot;, tagged_headers, &quot;-MD&quot;, &quot;-MF&quot;, tagged_dep_file, &quot;-o&quot;, ...], dep_files = { &quot;headers&quot;: headers_tag } )  "},{"title":"Producing the dep file​","type":1,"pageTitle":"Dep Files","url":"/docs/rule_authors/dep_files/#producing-the-dep-file","content":"Your command must produce dep files in the format Buck2 expects, which is simply a list of all the inputs that were used, one per line. The paths must be the paths Buck2 would use for your inputs, which means paths relative to the project root. If this is not the format your tool produces, use a wrapper to take whatever output your command produces and rewrite it in the format Buck2 expects. "},{"title":"Testing dep files​","type":1,"pageTitle":"Dep Files","url":"/docs/rule_authors/dep_files/#testing-dep-files","content":"When writing a command that produces a dep file, you should test it! At a minimum, check that the inputs you expect are tagged properly. To do so, build your target, then usebuck2 audit dep-files TARGET CATEGORY IDENTIFIER, which will show you the set of inputs your command used and how they're tagged. "},{"title":"Extra notes to the implementer​","type":1,"pageTitle":"Dep Files","url":"/docs/rule_authors/dep_files/#extra-notes-to-the-implementer","content":""},{"title":"Limitations​","type":1,"pageTitle":"Dep Files","url":"/docs/rule_authors/dep_files/#limitations","content":"Dep files only work if a previous invocation of the command is known to your Buck2 daemon. Dep files are dropped when the daemon restarts or when you runbuck2 debug flush-dep-files. This means that, for example, if you change an unused header, then run a build on a fresh daemon, Buck2 will still need to execute this command in order to identify that the header was in fact unused. In contrast, if you did the build (and got a remote cache hit on the command), then applied your change and re-built, Buck2 would use the dep file on the second execution, and you wouldn't need to execute anything. "},{"title":"Dep files don't need to be covering​","type":1,"pageTitle":"Dep Files","url":"/docs/rule_authors/dep_files/#dep-files-dont-need-to-be-covering","content":"It's OK for the dep file to only cover a subset of the inputs of your action. However, within that subset, the dep file must declare all the inputs that were used. If you fail to report some inputs you used, then your command will not re-run when they change, and you'll get stale output. "},{"title":"Dep files are lazy​","type":1,"pageTitle":"Dep Files","url":"/docs/rule_authors/dep_files/#dep-files-are-lazy","content":"Dep files aren't parsed by Buck2 unless the command needs to re-run. If the command ran on RE, they aren't even downloaded until then. This ensures dep files don't cause a performance hit unless they are used, at which point they stand a chance of giving a performance boost instead. This means that if you produce an invalid dep file, Buck2 will not report this until your command runs again, at which point Buck2 will report that the dep file is invalid and refuse to proceed (note: you can unblock yourself usingbuck2 debug flush-dep-files). To flush out issues during development, you can pass --eager-dep-files to Buck2 to force Buck2 to parse your dep files as they are produced. "},{"title":"Dep files will traverse symlinks​","type":1,"pageTitle":"Dep Files","url":"/docs/rule_authors/dep_files/#dep-files-will-traverse-symlinks","content":"If your dep file reports that a symlink was used, Buck2 will track the symlink's target as covered by this dep file. "},{"title":"Anonymous Targets","type":0,"sectionRef":"#","url":"/docs/rule_authors/anon_targets/","content":"","keywords":""},{"title":"Anon rule​","type":1,"pageTitle":"Anonymous Targets","url":"/docs/rule_authors/anon_targets/#anon-rule","content":"An anonymous rule is defined using rule or anon_rule. Example: my_anon_rule = rule( impl = _anon_impl, attrs = {}, ) # Or: my_anon_rule = anon_rule( impl = _anon_impl, attrs = {}, artifact_promise_mappings = {} # only available for anon_rule )  For rule, these are normal rules, with the difference that they are not in a configuration, so ctx.actions.label won't show configuration information, but just unspecified. For anon_rule, the configuration restrictions also apply, and there is anartifact_promise_mappings field which you can specify a dict of artifact promise names to the map function, which would be applied to the anon target's promise during rule resolution. "},{"title":"Anon target​","type":1,"pageTitle":"Anonymous Targets","url":"/docs/rule_authors/anon_targets/#anon-target","content":"An anonymous rule is used via ctx.actions.anon_target orctx.actions.anon_targets, passing in the rule and the attributes for the rule. The return values of those functions are a AnonTarget and AnonTargets type, respectively. Example: my_anon_rule1 = anon_rule( impl = _anon_impl, attrs = {}, artifact_promise_mappings = {} ) my_anon_rule2 = anon_rule( impl = _anon_impl, attrs = {}, artifact_promise_mappings = {} ) # &lt;elsewhere&gt; anon_target = ctx.actions.anon_target(my_anon_rule1, {}) anon_targets = ctx.actions.anon_targets([(my_anon_rule1, {}), (my_anon_rule2, {})])  "},{"title":"AnonTarget and AnonTargets​","type":1,"pageTitle":"Anonymous Targets","url":"/docs/rule_authors/anon_targets/#anontarget-and-anontargets","content":"AnonTarget has a promise attribute, and artifact() and artifacts()functions. AnonTargets has a promise attribute and anon_targets attribute. The promise attribute for both types returns the anon target's promise (type is promise), which when evaluated returns the providers of the anonymous target. The promise type has a few special behaviors. It has a map function, which takes a function and applies it to the future, returning a new futureAll promises will eventually resolve to a list of providers For AnonTarget, the artifact() and artifacts() functions only return something if using anon_rule. artifact() takes in an artifact name, which should be found in the artifact_promise_mappings dict, and returns the artifact promise. artifacts() returns the dict of all promise artifact names to the artifact promise itself, as defined in artifact_promise_mappings. SeeConvert promise to artifact below for more information about artifact promises. Example: HelloInfo = provider(fields = [&quot;output&quot;]) my_anon_rule = anon_rule( impl = _anon_impl, attrs = {}, artifact_promise_mappings = { &quot;hello&quot;: lambda x: x[HelloInfo].output, } ) # &lt;elsewhere&gt; anon_target = ctx.actions.anon_target(my_anon_rule, {}) artifact = anon_target.artifact(&quot;hello&quot;) artifact_from_dict = anon_target.artifacts()[&quot;hello&quot;]  For AnonTargets, the anon_targets attribute returns a list of the underlyingAnonTargets. Example: HelloInfo = provider(fields = [&quot;output&quot;]) GoodbyeInfo = provider(fields = [&quot;output&quot;]) my_anon_rule1 = anon_rule( impl = _anon_impl, attrs = {}, artifact_promise_mappings = { &quot;hello&quot;: lambda x: x[HelloInfo].output, } ) my_anon_rule2 = anon_rule( impl = _anon_impl, attrs = {}, artifact_promise_mappings = { &quot;goodbye&quot;: lambda x: x[GoodbyeInfo].output, } ) # &lt;elsewhere&gt; all_targets = ctx.actions.anon_targets([(my_anon_rule1, {}), (my_anon_rule2, {})]) hello = all_targets.anon_targets[0].artifact(&quot;hello&quot;) goodbye = all_targets.anon_targets[1].artifact(&quot;goodbye&quot;)  Attributes Anon targets only support a subset of attributes that normal rules support. Supported attributes: boolintstrenumdep deps attributes do not take strings, but dependencies, already in a configurationexec_deps are available if the passed in dep's execution platform matchesDefault attr.deps (as used for toolchains) are not permitted, as the default can't express a dependency. They must be passed forward from the caller. that of the anon target's caller source Accepts bound artifacts or promise artifacts arg Can only be used if anon_target_compatible is True when declaringattrs.arg (ex: attrs.arg(anon_target_compatible = True)) labellisttupledictone_ofoption You can use these attributes like you would in normal rules: my_anon_rule = anon_rule( impl = _my_anon_impl, attrs = { &quot;my_int&quot;: attrs.int(), &quot;my_string_with_default&quot;: attrs.string(default = &quot;foo&quot;), &quot;my_optional_source&quot;: attrs.option(attrs.source()), &quot;my_list_of_labels&quot;: attrs.list(attrs.label()), }, artifact_promise_mappings = {} ) def _my_anon_impl(ctx: AnalysisContext) -&gt; list[Provider]: my_int = ctx.attrs.my_int my_string_with_default = ctx.attrs.my_string_with_default my_optional_source = ctx.attrs.my_optional_source my_list_of_labels = ctx.attrs.my_list_of_labels # do something with the attributes... return [DefaultInfo()]  "},{"title":"Attribute resolution​","type":1,"pageTitle":"Anonymous Targets","url":"/docs/rule_authors/anon_targets/#attribute-resolution","content":"Attribute resolution is handled differently from normal code: Transitions and more complex forms of attributes are banned.The name attribute is a reserved attribute. It is an implicit attribute when defining a rule for an anon target, but can be optionally set when creating an anon target. If present, it must be a syntactically valid target, but could refer to a cell/package that does not exist. If not present, buck2 will generate a name for the target automatically. "},{"title":"name attribute example​","type":1,"pageTitle":"Anonymous Targets","url":"/docs/rule_authors/anon_targets/#name-attribute-example","content":"# Rule definition for anon target my_rule = rule( impl = _my_impl, attrs = { # `name` is already implicitly defined as an attribute, and will error # out if you try to define it again during rule declaration }, ) # Anon target instantiation, elsewhere ctx.actions.anon_target( my_rule, { # you can optionally pass `name` into the attributes even though it's # not explicitly defined in the `attrs` field for `my_rule` &quot;name&quot;: &quot;foo//bar:baz&quot; }, )  To access the name attribute from an analysis context, you can usectx.label.name. Examples "},{"title":"Simple Example​","type":1,"pageTitle":"Anonymous Targets","url":"/docs/rule_authors/anon_targets/#simple-example","content":"# Define an anonymous rule UpperInfo = provider(fields = [&quot;message&quot;]) def _impl_upper(ctx): return [UpperInfo(message = ctx.attrs.message.upper()] upper = rule( attrs = {&quot;message&quot;, attrs.string()}, impl = _impl_upper ) # Use an anonymous target def impl(ctx): def k(providers): print(providers[UpperInfo].message) # These are the providers this target returns return [DefaultInfo()] return ctx.actions.anon_target(upper, { name: &quot;my//:greeting&quot;, message: &quot;Hello World&quot;, }) .promise .map(k)  "},{"title":"Longer example​","type":1,"pageTitle":"Anonymous Targets","url":"/docs/rule_authors/anon_targets/#longer-example","content":"The following code represents a scenario for a compile-and-link language where, if two targets end up compiling the same file (for example, they are in the same package and both list it, or it gets export_file'd), then that file is compiled just once: ## BUCK ############## @load(&quot;:silly.bzl&quot;, &quot;silly_binary&quot;) silly_binary( name = &quot;hello&quot;, srcs = [&quot;hello.sil&quot;, &quot;world.sil&quot;], ) ## silly.bzl ############ _SillyCompilation = provider(fields = [&quot;compiled&quot;]) def _silly_compilation_impl(ctx): out = ctx.actions.declare_output(&quot;output.o&quot;) ctx.actions.run(cmd_args( ctx.attrs.toolchain.compiler, ctx.attrs.src, &quot;-o&quot;, out.as_output(), )) return [DefaultInfo(), _SillyCompilation(compiled = out)] _silly_compilation = rule( impl = _silly_compilation_impl, attrs = { &quot;src&quot;: attrs.src(), &quot;toolchain&quot;: attrs.dep(), }, ) def _silly_binary_impl(ctx): def k(providers): # Step 2: now link them all together out = ctx.actions.declare_output(&quot;out.exe&quot;) objs = [p[_SillyCompilation].compiled for p in providers] ctx.actions.run(cmd_args( ctx.attrs._silly_toolchain.linker, objs, &quot;-o&quot;, out.as_output(), )) return [ DefaultInfo(default_output = out), RunInfo(args = out), ] # Step 1: compile all my individual files return ctx.actions.anon_targets( [(_silly_compilation, { &quot;src&quot;: src, &quot;toolchain&quot;: ctx.attrs._silly_toolchain }) for src in ctx.attrs.srcs] ).map(k) silly_binary = rule( impl = _silly_binary_impl, attrs = { &quot;srcs&quot;: attr.list(attr.src()), &quot;_silly_toolchain&quot;: attr.dep(default = &quot;toolchains//:silly&quot;), }, )  "},{"title":"Convert promise to artifact​","type":1,"pageTitle":"Anonymous Targets","url":"/docs/rule_authors/anon_targets/#convert-promise-to-artifact","content":"It can be challenging to pass around the promises from anon_target and structure functions to support that. If you only need an artifact (or multiple artifacts) from an anon_target, you can use artifact() function on the anon target to convert a promise to an artifact. This artifact can be passed to most things that expect artifacts, but until it is resolved (at the end of the current analysis) it can't be inspected with artifact functions like .extension, etc..short_path is supported if ctx.actions.assert_short_path() was called, which produces an artifact type. The promise must resolve to a build (not source) artifact with no associated artifacts. Example: HelloInfo = provider(fields = [&quot;hello&quot;, &quot;world&quot;]) def _anon_impl(ctx: AnalysisContext) -&gt; [&quot;provider&quot;]: hello = ctx.actions.write(&quot;hello.out&quot;, &quot;hello&quot;) world = ctx.actions.write(&quot;world.out&quot;, &quot;world&quot;) return [DefaultInfo(), HelloInfo(hello = hello, world = world)] _anon = anon_rule( impl = _anon_impl, attrs = {}, artifact_promise_mappings = { &quot;hello&quot;: lambda x: x[HelloInfo].hello, &quot;world&quot;: lambda x: x[HelloInfo].world, } ) def _use_impl(ctx: AnalysisContext) -&gt; [&quot;provider&quot;]: anon = ctx.actions.anon_target(_anon, {}) hello_artifact = anon.artifact(&quot;hello&quot;) world_artifact = anon.artifact(&quot;world&quot;) out = ctx.actions.declare_output(&quot;output&quot;) ctx.actions.run([ ctx.attrs.some_tool, hello_artifact, world_artifact, out.as_output() ], category = &quot;process&quot;) return [DefaultInfo(default_output = out)] use_promise_artifact = rule(impl = _use_impl, attrs = { &quot;some_tool&quot;: attr.exec_dep(), })  "},{"title":"Dynamic Dependencies","type":0,"sectionRef":"#","url":"/docs/rule_authors/dynamic_dependencies/","content":"","keywords":""},{"title":"Implementation​","type":1,"pageTitle":"Dynamic Dependencies","url":"/docs/rule_authors/dynamic_dependencies/#implementation","content":"Buck2 provides the following function: ctx.actions.dynamic_output(dynamic, inputs, outputs, lambda ctx: …)  The arguments are: dynamic - a list of artifacts whose values will be available in the function. These will be built before the function is run.inputs - a container of artifacts (cmd_args, list of artifacts, and so on). These inputs must include all the inputs that are referenced by the body of the function argument, apart from those listed in dynamic and outputs: extra inputs may be passed that are not used.The inputs are used for buck2 aquery functionality, but do not cause speculative building. In fact, these inputs may form a cycle with otherdynamic_output actions if they were all required.In the future, it may be possible to not pass all the inputs if the repo is set to permissive mode, allowing a more powerful form of dynamic dependencies. outputs - a list of unbound artifacts (created with declare_artifact) which will be bound by the function.The function argument is given 3 arguments: ctx (context) - which is the same as that passed to the initial rule analysis.outputs - using one of the artifacts from the dynamic_output's outputs(example usage: outputs[artifact_from_dynamic_output_outputs]) gives an unbounded artifact. The function argument must use its outputs argument to bind output artifacts, rather than reusing artifacts from the outputs passed into dynamic_output directly.artifacts - using one of the artifacts from dynamic (example usage:artifacts[artifact_from_dynamic]) gives an artifact value containing the methods read_string, read_lines, and read_json to obtain the values from the disk in various formats. Anything too complex should be piped through a Python script for transformation to JSON. The function must call ctx.actions (probably ctx.actions.run) to bind all outputs. It can examine the values of the dynamic variables and depends on the inputs. The function will usually be a def, as lambda in Starlark does not allow statements, making it quite underpowered. Following is an example of using the function to determine Erlang BEAM dependencies: def erlang(ctx): beams = {} for x in ctx.attr.srcs: dep_file = ctx.actions.declare_output(x + &quot;.out&quot;) ctx.actions.run(&quot;erl&quot;, &quot;-dump-output&quot;, x, dep_file.as_output()) beam_file = ctx.actions.declare_output(x + &quot;.beam&quot;) beams[x] = beam_file def f(ctx, artifacts, outputs, x=x, dep_file=dep_file): deps = artifacts[dep_file].read_lines() ctx.actions.run( &quot;erl&quot;, &quot;-comp&quot;, x, [beams[d] for d in deps], outputs[beams[x]].as_output() ) ctx.actions.dynamic_output([dep_file], [x] + deps, [beam_file], f) return [ErlangInfo(objects = beams.values())]  The above code uses declare_output for the beam_file then binds it within the function f, after having read the dep_file with read_lines. "},{"title":"Incremental Actions","type":0,"sectionRef":"#","url":"/docs/rule_authors/incremental_actions/","content":"Incremental Actions It's possible to make certain Buck2 actions behave incrementally, that is, to produce results for a current invocation based on the result from the previous run. Incrementality could significantly improve performance of some actions such as packaging (such as Apple App Bundles) or linking (MSVC incremental linking). There are two essential requirements to make an action incremental: The result from the previous run should be accessible.An understanding of which parts of the result need to be updated; it should be easy to compare inputs from a previous run with inputs from the current run and detect those changed. The only way to run user-defined commands in Buck2 is with ctx.actions.run. Both of the above requirements are met via its metadata_env_var,metadata_path and no_outputs_cleanup parameters. When the no_outputs_cleanup flag is turned on, Buck2 won't perform any deletion of old outputs for the action. That means the result from the previous run will be accessible, but the user script has to detect which parts of it should be deleted and perform a manual cleanup. When the metadata_env_var and metadata_path parameters are present, Buck2 will create a JSON file on a disk before actually executing the command. The file will contain a list of paths and hash digests for every command action input. All paths in the file are relative to the Buck2 project root. Symlinks are not included in metadata because it is possible for the user script to resolve symlink and use a resolved path to get the destination hash digest from action metadata if it's needed, as shown in the following JSON example: { &quot;version&quot;: 1, &quot;digests&quot;: [ { &quot;path&quot;: &quot;buck-out/v2/gen/cell/configuration_hash/path/to/target/__target_name__/generated_file&quot;, &quot;digest&quot;: &quot;da39a3ee5e6b4b0d3255bfef95601890afd80709:10&quot; }, ... ] } A user script that is run as a part of an action execution is responsible for parsing the JSON file. The version field is bumped every time there is a non-backwards compatible change to the format of the file. The user script should verify that the provided data is of a supported version and should be updated accordingly when the current version is newer than the supported one. The path of the JSON file is provided to the user script via an environment variable with a key equal to metadata_env_var. The user is able to specify the part of the path relative to the result directory via metadata_path. For example, if some rule implementation has the following code: result = ctx.actions.declare_output(&quot;result&quot;) command = cmd_args([&quot;my_script.py&quot;, &quot;--output&quot;, result.as_output()]) ctx.actions.run( command, category = &quot;my_category&quot;, metadata_env_var = &quot;ACTION_METADATA&quot;, metadata_path = &quot;action_metadata.json&quot;, no_outputs_cleanup = True, ) Then my_script.py will be executed as: ACTION_METADATA=project/relative/path/to/target/action_metadata.json my_script.py --output resolved/path/to/result my_script.py is responsible for reading the ACTION_METADATA environment variable and parsing a JSON file with the action metadata. Parsed metadata provides information about inputs for the current run, but the script needs somehow to obtain similar information about inputs from the previous run. Such information could just be another output of the user script (as with the previous result, it won't be deleted whenno_outputs_cleanup = True). The Format of such a file is an implementation detail of the user script, but at the very least it should contain a list of every source that was used to form the result and hash digests for such sources. The rule implementation would look something like the following: result = ctx.actions.declare_output(&quot;result&quot;) state = ctx.actions.declare_output(&quot;incremental_state.json&quot;) command = cmd_args([&quot;my_script.py&quot;, &quot;--output&quot;, result.as_output(), &quot;--incremental-state&quot;, state.as_output()]) ctx.actions.run( command, category = &quot;my_category&quot;, metadata_env_var = &quot;ACTION_METADATA&quot;, metadata_path = &quot;action_metadata.json&quot;, no_outputs_cleanup = True, ) The user script would then: Parse incremental_state.json and delete it. Deletion prior to amending the result is important so it doesn't result in a situation where an incremental state file is out of sync with the result when the user script fails while changing the result. Such a corrupted state might lead to subsequent incorrect builds reported as &quot;successful&quot;.Parse action metadata file, compute what is needed to update the result, and amend it accordingly.Calculate the new state and write it into the new incremental_state.json.","keywords":""},{"title":"Local Resources For Tests Execution","type":0,"sectionRef":"#","url":"/docs/rule_authors/local_resources/","content":"","keywords":""},{"title":"LocalResourceInfo provider​","type":1,"pageTitle":"Local Resources For Tests Execution","url":"/docs/rule_authors/local_resources/#localresourceinfo-provider","content":"This provider describes how to initialize and clean up a pool of homogeneous local resources. Management of initialized resources is done by Buck2 itself when it executes tests requiring such resources. Fields: setup — command represented by cmd_args object which is executed to initialize a local resource. Running this command should write a JSON to stdout. This JSON represents a pool of local resources which are ready to be used.resource_env_vars — key-value mapping {str: str} from environment variable (appended to an execution command for test which is dependent on this local resource) to keys in JSON output of setup command. Example JSON output of setup command: { &quot;pid&quot;: 42, &quot;resources&quot;: [ {&quot;socket_address&quot;: &quot;foo:1&quot;}, {&quot;socket_address&quot;: &quot;bar:2&quot;} ] }  JSON keys: pid — an optional attribute which maps to a PID of a process that holds initialized local resources. If present, on non-Windows platforms the process will be sent SIGTERM when those resources are no longer needed. Signal should be handled to release any system resources related to local resources.resources — a list of resource instances, each is a mapping from a string alias (e.g. socket_address) to a value which represents resource. The number of concurrently running tests that require resources of the same type is limited by how many instances are in a list. String alias is mapped to an environment variable key (which will be added to a command requiring such resource) using a resource_env_vars field in LocalResourceInfo provider (see example below). "},{"title":"Test Execution​","type":1,"pageTitle":"Local Resources For Tests Execution","url":"/docs/rule_authors/local_resources/#test-execution","content":"For a general context on how tests are executed, seeTest Execution. A decision whether certain local resource is required for specific test is made by a test runner. List of required resources is then passed to Buck2 inrequired_local_resources field of ExecuteRequest2 test API protobuf message. If resource is required for a certain test execution and test could potentially be executed locally, local_resources field in test's ExternalRunnerTestInfoprovider is used to select appropriate LocalResourceInfo provider. ExternalRunnerTestInfo.local_resources is a key-value mapping{str: [&quot;label&quot;, None]}. Keys represent resource types that match the values passed from the test runner, and values are labels that should point to a target exposing the LocalResourceInfo provider to be used for the initialization of the resource of that type. If the value is None, it indicates that a resource of that type will not be provided, even if the test runner requests it. Before running a test, setup command from selected provider is executed and its output is used to create a pool of resource instances. This pool is shared across all tests pointing to the same configured target label containingLocalResourceInfo provider (normally that means pool is shared for tests requiring same resource type). A resource is acquired (with potential queuing) from that pool prior single test is executed and is returned back to the pool when test finished execution. After buck2 test command is finished, cleanup is performed when SIGTERM is sent to each process holding a pool of resources. "},{"title":"Example Usage​","type":1,"pageTitle":"Local Resources For Tests Execution","url":"/docs/rule_authors/local_resources/#example-usage","content":"Define a target which has LocalResourceInfo provider: simulator( name = &quot;my_resource&quot;, broker = &quot;:broker&quot;, )  where broker points to a runnable handling actual simulators. Implementation of simulator rule would be: def _impl(ctx: AnalysisContext) -&gt; [&quot;provider&quot;]: return [ DefaultInfo(), LocalResourceInfo( setup = cmd_args([ctx.attrs.broker[RunInfo]]), resource_env_vars = { &quot;IDB_COMPANION&quot;: &quot;socket_address&quot; }, ) ]  Running a :broker via setup command produces the following JSON: { &quot;pid&quot;: 42, &quot;resources&quot;: [ {&quot;socket_address&quot;: &quot;foo:1&quot;}, {&quot;socket_address&quot;: &quot;bar:2&quot;} ] }  When Buck2 locally executes a test which requires this particular type of local resource, it reserves one resource from the pool (e.g.{&quot;socket_address&quot;: &quot;bar:2&quot;}) and add environment variable representing this resource to execution command (e.g. IDB_COMPANION=bar:2). In our examples&quot;socket_address&quot; alias was substituted by &quot;IDB_COMPANION&quot; based onLocalResourceInfo.resource_env_vars field. The last part is to map a resource type to desired LocalResourceInfo provider. Let's assume a test runner requires a resource of type &quot;ios_simulator&quot; for everyapple_test rule. Pass :my_resource target as a dependency into apple_test rule: apple_test = rule( impl = apple_test_impl, attrs = { ... &quot;_ios_simulator&quot;: attrs.default_only(attrs.dep(default = &quot;:my_resource&quot;, providers = [LocalResourceInfo])), ... }, )  Actually map &quot;ios_simulator&quot; resource type to :broker target containingLocalResourceInfo provider: def apple_test_impl(ctx: AnalysisContext) -&gt; [&quot;provider&quot;]: ... return [ ... ExternalRunnerTestInfo( ... local_resources = { &quot;ios_simulator&quot;: ctx.attrs._ios_simulator, }, ...  "},{"title":"Observability and Optimization","type":0,"sectionRef":"#","url":"/docs/rule_authors/optimization/","content":"","keywords":""},{"title":"Starlark profiling​","type":1,"pageTitle":"Observability and Optimization","url":"/docs/rule_authors/optimization/#starlark-profiling","content":"buck2 supports profiling of the evaluation of specific BUCK files and profiling of the analysis of specific targets. There are three buck2 profiling commands: buck2 profile loadingbuck2 profile analysisbuck2 profile bxl For example: buck2 profile loading --mode=heap-summary-allocated -o heap-summary.csv //some/package: buck2 profile analysis --mode=heap-summary-allocated -o heap-summary.csv //some/package:target  Possible values for profiling modes are as follows: heap-summary-allocated: The heap profile mode provides information about the time spent in each function and allocations performed by each function. Enabling this mode has the side effect of disabling garbage-collection. This profiling mode is the recommended one.heap-summary-retained: Like heap summary, but information about retained memory after module is frozen.time-flame: Provide output compatible withflamegraph.pl.heap-flame-allocated: Like heap profile, but writes output comparible withflamegraph.pl.heap-flame-retained: Like heap flame, but information about retained memory after module is frozen.statement: The statement profile mode provides information about time spent in each statement.bytecode: The bytecode profile mode provides information about bytecode instruction pairs.bytecode-pairs: The bytecode profile mode provides information about bytecode instruction pairs.typecheck: Profile runtime typechecking. "},{"title":"Summary profiling​","type":1,"pageTitle":"Observability and Optimization","url":"/docs/rule_authors/optimization/#summary-profiling","content":"The first profiling mode (heap-summary-allocated) provides the time spent within a function and the allocations that are performed. As an example, running over a folly BUCK file, produces a CSV file whose top-left corner is: Function Time(s) TimeRec(s) Calls Allocs TOTALS 10.455 10.455 9712799 3477203 fbchain_configs 1.163 2.514 11328 33984 is_string 0.726 1.028 1514985 0 apple_library 0.725 0.725 1887 0 type 0.435 0.435 2053296 0 ...  This reveals the following: Total execution was 10.455s, which will be a bit slower than normal, because profiling is on.1.163s was spent in fbchain_configs itself and 2.514s in that function and the things it calls.A disturbing 1.5M calls and 1.028s is spent testing if things are strings, which is almost certainly responsible for half the type calls.Happily, is_string doesn't allocate, but fbchain_configs does. Scrolling to the right, on the full CSV file (not shown), reveals it allocates 1 tuple and 2 dict per call. It can also be seen that fbchain_configs is mostly called by _add_code_coverage_configs. This profiling mode is implemented by turning off garbage collection, so the heap retains everything, and pushing function entry/exit entries on to the heap with the time they happen. After execution, the heap can be scanned in order to reconstruct the call tree and allocation patterns. As a result, this profile mode may consume significantly more memory. "},{"title":"Statement profiling​","type":1,"pageTitle":"Observability and Optimization","url":"/docs/rule_authors/optimization/#statement-profiling","content":"The second profiling mode tells us which statements spent most time executing. Running it over a structured-logger BUCK file gives us a CSV file starting with: File Span Duration(s) Count TOTAL 4.03 7187761 fbcode_allowed_list.bzl 420:9-423:1 0.27 455884 cell_defs.bzl 13:5-13:60 0.17 117736 read_configs.bzl 46:5-46:55 0.08 65042 prelude.bzl 28:9-29:20 0.07 1004 ...  This profile shows how much time is spent in each statement. Looking at the relevant portion of fbode_allowed_list.bzl: for _package in _recursive_allowlist: if base_path == _package or base_path.startswith(_package + &quot;/&quot;): return True  The if statement is at location 420:9-423:1 and takes 0.27s. The ifstatement runs approximately 456K times. While looking at the outer statement in the profile (not shown), it can be seen that the for loop is only called 3188 times, implying an average of 143 iterations per call. It's possible that this loop could be rewritten as some clever dictionary lookup, perhaps iterating over the path components of _package. Line profiling builds on top of the before_stmt hook that is used for debugging. It records the time each statement is entered then blames that statement for all time until the next statement. That means that sometimes, due to statements making function calls, the return of the function call may be 'blamed' until the next statement executes. As a result, treat the results with slight caution. "},{"title":"Flame profiling​","type":1,"pageTitle":"Observability and Optimization","url":"/docs/rule_authors/optimization/#flame-profiling","content":"The flame profiling modes produces a .svg flamegraph showing either time spent or allocations. You can open it in Google chrome and inspect the resulting flame graph. "},{"title":"Native profiling​","type":1,"pageTitle":"Observability and Optimization","url":"/docs/rule_authors/optimization/#native-profiling","content":"Profiling on Linux can be done withperf record -g --call-graph=dwarf,20000 ... and perf report --call-graph Don't profile the buck2 process directly unless you are interested in profiling the CLI; you likely want to profile the buck2 daemon process. You can find the pid with buck2 status and attach perf to that PID. Profiling on Mac can be done with Instruments. "},{"title":"Benchmarking​","type":1,"pageTitle":"Observability and Optimization","url":"/docs/rule_authors/optimization/#benchmarking","content":"If you want to do proper statistically relevant A/B testing, useabsh -a testa -b testb (see absh in the GitHub repository).To measure the number of instructions: On Linux, use perf stat fooOn Mac, use /usr/bin/time -lp foo On Mac, to run something with the time profiler on the command line, usexcrun xctrace record --template 'Time Profiler' --launch -- foo, thenopen Foo.trace for the name of the trace file it spits out (or pass--output to control the output filename). "},{"title":"Test Execution","type":0,"sectionRef":"#","url":"/docs/rule_authors/test_execution/","content":"","keywords":""},{"title":"Anatomy of a test run​","type":1,"pageTitle":"Test Execution","url":"/docs/rule_authors/test_execution/#anatomy-of-a-test-run","content":"When a user runs buck2 test $targets: Buck2 identifies all matching targets that have an ExternalRunnerTestInfo.Buck2 builds all the artifacts referenced by those targets (this will likely change eventually to build them only if they are used).Buck2 then notifies the test runner that those tests exist. Currently, the test runner receives a subset of ExternalRunnerTestInfo.The test runner can request command execution from Buck2 to list and execute tests.When it receives command results from Buck2, the test runner may fire off events that the end-user will see (such as test results), upload logs externally, request further executions, and so on. note If more than one target is being built, test building and execution will proceed concurrently. "},{"title":"Information available on ExternalRunnerTestInfo​","type":1,"pageTitle":"Test Execution","url":"/docs/rule_authors/test_execution/#information-available-on-externalrunnertestinfo","content":"As noted, rules communicate their testing capabilities viaExternalRunnerTestInfo. There are a number of fields available onExternalRunnerTestInfo to control how a given target is tested, as detailed in the following sub-sections. "},{"title":"Fields exposed to the test runner​","type":1,"pageTitle":"Test Execution","url":"/docs/rule_authors/test_execution/#fields-exposed-to-the-test-runner","content":"The following list shows what is available in ExternalRunnerTestInfo, with which the test runner can interact: type - a string key that defines the type of test this is. command and env - respectively, a list and a key-value mapping of arguments. They are not always visible to the test runner (for more details, seeVerbatim arguments and handles, below).labels - a set of string labels to pass to the test runner. contacts - a list of contacts for the tests; usually oncalls.executor_overrides - a key-value mapping of executor configurations that the test runner can use when requesting execution from Buck2.local_resources - a key-value mapping from resource type to optionalLocalResourceInfo provider. Provider is used for initialization of that resource type. If the value is None resource type is ignored even though test runner required it. For context seeLocal Resources For Tests Execution. "},{"title":"Fields pertinent for Remote Execution​","type":1,"pageTitle":"Test Execution","url":"/docs/rule_authors/test_execution/#fields-pertinent-for-remote-execution","content":"For compatibility with Remote Execution (RE), there are two fields that rules should set in their ExternalRunnerTestInfo if they should be run on RE: use_project_relative_paths - if true (the default is `true`), Buck2 will produce relative paths. If not, it'll produce absolute paths.run_from_project_root - if true (the default is `true`), tests will run from the project root (their `cwd` will be the project root, which is the same as all build commands). If `false`, it'll be the cell root. Note that passing --unstable-allow-all-tests-on-re to buck2 test will override those fields and set them to true, since they are a pre-requisite to run on RE. In contrast, passing --unstable-allow-compatible-tests-on-re will only allow tests that already set both those fields to true to execute on RE. Also note that when executor_overrides are set, if an executor override is used and results in execution on RE, it'll happen on RE unconditionally. Therefore, it's a good idea to set those fields if RE-only executor overrides are provided. "},{"title":"Verbatim arguments and handles​","type":1,"pageTitle":"Test Execution","url":"/docs/rule_authors/test_execution/#verbatim-arguments-and-handles","content":"As noted above, the test runner only interacts with a subset of arguments provided by rules in ExternalRunnerTestInfo. The reason for this is that the test runner doesn't get to access, for example, artifacts, that Buck2 knows about. Consider the following example: binary = ctx.attrs.dep[RunInfo] test_info = ExternalRunnerTestInfo(command = [binary, &quot;run-tests&quot;], ...)  When Buck2 actually runs this command, binary is expanded to a path (and possibly to more args). Buck2 would also account for any hidden arguments and make those available where the command is executed. It is important for Buck2 to retain this capability when running with the test runner. To that end, all non-trivial arguments present in command (and in the values of env), such as cmd_args or RunInfo, are exposed to the test runner as opaque handles, and simple string arguments are passed as-is to the test runner. This means that the test runner would see the command described above as: [ArgHandle(index = 0), Verbatim(&quot;foobar&quot;)]  When requesting execution from Buck2, the test runner can use the ArgHandleand Buck2 will swap it back for the underlying value that was set on the provider. This allows the test runner to introspect and modify parts of the command lines it receives, as long as it doesn't need to access the actual text value of non-verbatim arguments. Usually, this works out to be sufficient (or can be made sufficient with a bit of refactoring in the test runner). "},{"title":"Execution Configurations​","type":1,"pageTitle":"Test Execution","url":"/docs/rule_authors/test_execution/#execution-configurations","content":"By default, tests execute using the execution configuration of the associated target. This is the execution configuration that would be used for run actions (ctx.actions.run) declared in the same target. This is a default that actually makes little sense but works out as long as cross-compiling is not the norm. To support this, ExternalRunnerTestInfo allows specifying override platforms, which are given a name. The test runner can request execution on them by passing their name when it sends execution requests to Buck2, as shown in the following code: ExternalRunnerTestInfo( executor_overrides = { &quot;ios-simulator&quot;: CommandExecutorConfig( local_enabled = False, remote_enabled = True, remote_execution_properties = { &quot;platform&quot;: &quot;ios-simulator-pure-re&quot;, &quot;subplatform&quot;: &quot;iPhone 8.iOS 15.0&quot;, &quot;xcode-version&quot;: &quot;xcodestable&quot;, }, remote_execution_use_case = &quot;tpx-default&quot;, ), &quot;static-listing&quot;: CommandExecutorConfig(local_enabled = True, remote_enabled = False), }, ... )  The default execution platform can also be overridden: ExternalRunnerTestInfo( default_executor = CommandExecutorConfig( local_enabled = False, remote_enabled = True, remote_execution_properties = { &quot;platform&quot;: &quot;ios-simulator-pure-re&quot;, &quot;subplatform&quot;: &quot;iPhone 8.iOS 15.0&quot;, &quot;xcode-version&quot;: &quot;xcodestable&quot;, }, remote_execution_use_case = &quot;tpx-default&quot;, ), ... )  "},{"title":"Working Directory​","type":1,"pageTitle":"Test Execution","url":"/docs/rule_authors/test_execution/#working-directory","content":"Tests can be run from the cell root by setting `run_from_project_root = False`. To produce paths relative to the cell root for use by tests, userelative_to(ctx.label.cell_root) on cmd_args. "},{"title":"PACKAGE Files","type":0,"sectionRef":"#","url":"/docs/rule_authors/package_files/","content":"","keywords":""},{"title":"APIs​","type":1,"pageTitle":"PACKAGE Files","url":"/docs/rule_authors/package_files/#apis","content":""},{"title":"PACKAGE APIs​","type":1,"pageTitle":"PACKAGE Files","url":"/docs/rule_authors/package_files/#package-apis","content":"write_package_value​ def write_package_value( name: str, value: &quot;&quot;, overwrite: bool = False, ): ...  This global API is only available in PACKAGE files, or bzl files included inPACKAGE files. name is a string which must contain exactly one dot symbol (just to enforce code style). value is an arbitrary Starlark value, for example, an integer, a list of integer, a struct or a function. The value must be serializable into JSON. When overwrite is False (default), attempt to overwrite per-PACKAGE value defined in parent PACKAGE file will fail. Written values are frozen when PACKAGE file evaluation is finished. Note write_package_value symbol exists in bzl globals, and it can be called from bzl file in context of PACKAGE evaluation, but callingwrite_package_file is an error on context of BUCK evaluation. Modifying PACKAGE file logically invalidates the BUCK file of this directory, and all PACKAGE and BUCK files of sub-PACKAGEs. However, BUCKfile evaluation may track which PACKAGE-local values were accessed and only invalidate BUCK files which were potentially affected (similarly to how we do it with buckconfigs). read_parent_package_value​ def read_parent_package_value( key: str, ): ...  This global API is only available in PACKAGE files, or bzl files included inPACKAGE files. This function returns the PACKAGE value defined in a parent PACKAGE file, orNone is such value does not exist. This function is available in PACKAGE files, but attempt to call this function in context of bzl file evaluation results in an error. package​ def package( inherit: bool = False, visibility: list[str] | tuple[str, ...] = [], within_view: list[str] | tuple[str, ...] = [] ) -&gt; None  This global API is only available in PACKAGE files, or bzl files included inPACKAGE files. visibility is a list of visibility patterns to apply to all targets contained within the directory, unless the target defines it's own visibility patterns. within_view is a list of visibility patterns restricting what all target contained within the PACKAGE directory can depend on. Applies to first-order deps, and not transitive deps. If inherit is True, then the visibility and within_view will be inherited from the nearest parent PACKAGE. read_config​ PACKAGE files are able to call read_config to read buckconfigs. "},{"title":"BUCK-specific API​","type":1,"pageTitle":"PACKAGE Files","url":"/docs/rule_authors/package_files/#buck-specific-api","content":"read_package_value​ def read_package_value( name: str, ): ...  This global API is only available in BUCK files, or bzl files included inBUCK files. This function returns the nearest name value registered per PACKAGE, orNone is such value does not exist. This function is available in bzl files, but attempt to call this function in context of PACKAGE file evaluation results in an error. This restriction can be lifted in the future. "},{"title":"Transitive Sets","type":0,"sectionRef":"#","url":"/docs/rule_authors/transitive_sets/","content":"","keywords":""},{"title":"Rule API​","type":1,"pageTitle":"Transitive Sets","url":"/docs/rule_authors/transitive_sets/#rule-api","content":"First, you need to declare your transitive set type, then you can use it, as follows: # This is the type MySet = transitive_set() # Those are transitive sets: set1 = ctx.actions.tset(MySet, value = &quot;foo&quot;) set2 = ctx.actions.tset(MySet, value = &quot;bar&quot;, children = [set1])  Values are optional, and so are children. This means you can have a set with no value and sets with no children. "},{"title":"Projections: using transitive sets in command lines​","type":1,"pageTitle":"Transitive Sets","url":"/docs/rule_authors/transitive_sets/#projections-using-transitive-sets-in-command-lines","content":"Sets aren't useful unless you can use their contents! To use a set in a command line, you use a concept called a 'projection', which defines how to turn individual values found in the set into command line arguments. To define a projection, you write a function that takes a value of your set and returns a command-line like object (cmd_args, string, attr.arg()attributes, artifact, and so on) or a list of them in whichever way makes sense for your use case. Then, you call project_as_args to turn a set into a value suitable for inclusion in a command line. When expanded, this projection will expand like a list of all the node's individual projected values. Following is an example: # Declare the projection def project_as_define(value: str): return cmd_args(value, format = &quot;-D{}&quot;) # Add it to the set definition MySet = transitive_set(args_projections = { &quot;define&quot;: project_as_define }) # Create a set set1 = ctx.actions.tset(MySet, value = &quot;foo&quot;) set2 = ctx.actions.tset(MySet, value = &quot;bar&quot;, children = [set1]) # Call the projection. # Note &quot;define&quot; is the key used above in `args_projections`. args = set2.project_as_args(&quot;define&quot;)  When you use args in a command line, it will expand to -Dbar -Dfoo. Note that creating projections is very cheap. Notably, it is independent of the size of the set. "},{"title":"Projections: using transitive sets in write_json()​","type":1,"pageTitle":"Transitive Sets","url":"/docs/rule_authors/transitive_sets/#projections-using-transitive-sets-in-write_json","content":"As with command lines, sets can form json projections to be used in write_json. A json projection is defined in the same way as an arg projection. The function should return a value that write_json otherwise supports. Then, you callproject_as_json to turn a set into a value that can be passed to write_json(or can appear within the value passed to it, it doesn't need to be the top-level value). When expanded, the projection will expand like a list of all the node's individual projected values. Following is an example: # Declare the projection def project_as_json(value: str): return struct(key = &quot;foo&quot;, value = value) # Add it to the set definition MySet = transitive_set(json_projections = { &quot;define&quot;: project_as_json }) # Create a set set1 = ctx.actions.tset(MySet, value = &quot;foo&quot;) set2 = ctx.actions.tset(MySet, value = &quot;bar&quot;, children = [set1]) # Call the projection. # Note &quot;define&quot; is the key we used above in `json_projections`. args = set2.project_as_json(&quot;define&quot;)  Note that if your projected values include (or may include) artifacts, you will likely want to use write_json(with_inputs=True) to get back a cmd_args that has all the artifacts in the json structure already in its .hidden. "},{"title":"Traversals in depth​","type":1,"pageTitle":"Transitive Sets","url":"/docs/rule_authors/transitive_sets/#traversals-in-depth","content":"Transitive sets form DAGs. Notably, this means individual nodes can exist more than once in a given transitive set. When a transitive set is traversed, nodes that have already been visited are skipped. This means their arguments will only be emitted once. For example: flowchart TD foo((foo)) bar((bar)) qux((qux)) qux --&gt; foo bar --&gt; foo qux --&gt; bar set1 = ctx.actions.tset(MySet, value = &quot;foo&quot;) set2 = ctx.actions.tset(MySet, value = &quot;bar&quot;, children = [set1]) set3 = ctx.actions.tset(MySet, value = &quot;qux&quot;, children = [set1, set2]) args = set3.project_as_args(&quot;define&quot;)  This will expand to -Dqux -Dfoo -Dbar, even though set1 (&quot;foo&quot;) shows up twice in the DAG. "},{"title":"Other APIs​","type":1,"pageTitle":"Transitive Sets","url":"/docs/rule_authors/transitive_sets/#other-apis","content":""},{"title":"Transitive set reductions​","type":1,"pageTitle":"Transitive Sets","url":"/docs/rule_authors/transitive_sets/#transitive-set-reductions","content":"You can aggregate values of a transitive set via a reduction. This can be helpful for tasks such as propagating Boolean flags up the tree. Following is a real-world example. When defining a reduction, you receive the reduced values of all your children, and an optional value for the current node (the value will be None when you create a set and you don't pass a value), and you need to merge them together to produce this node's value: def link_info_has_default_filelist(children: list[bool], infos: LinkInfos | None): if infos: info = infos.default if info.filelist: return True return any(children) # Set of LinkInfos LinkInfosTSet = transitive_set( reductions = { &quot;has_default_filelist&quot;: link_info_has_default_filelist, }, )  "},{"title":"Transitive set iteration​","type":1,"pageTitle":"Transitive Sets","url":"/docs/rule_authors/transitive_sets/#transitive-set-iteration","content":"You can iterate over a transitive set. This will yield each value once. You can also iterate over projections. However, note that this is generally not recommended, since unlike creating and using a projection, this operation is O(set). You should use this as an escape hatch if and only if you need to implement something transitive sets don't support via projections or reductions, because in doing so you'll lose a lot of the performance benefits. For example: set1 = ctx.actions.tset(MySet, value = &quot;foo&quot;) set2 = ctx.actions.tset(MySet, value = &quot;bar&quot;, children = [set1]) set3 = ctx.actions.tset(MySet, value = &quot;qux&quot;, children = [set1, set2]) values = list(set3.traverse())  This will yield [&quot;qux&quot;, &quot;foo&quot;, &quot;bar&quot;]. "},{"title":"Ordering​","type":1,"pageTitle":"Transitive Sets","url":"/docs/rule_authors/transitive_sets/#ordering","content":"Transitive set iteration uses a left-to-right, pre-order traversal by default, and ignores nodes that have already been visited. This order is reflected in projections as well. A few different traversal orders are supported with the ordering attribute: Ordering\tDescriptionpreorder (default)\tTraverses using a depth-first-search, visiting nodes left-to-right. postorder\tTraverses children left-to-right, and then visits the current node. topological\tA Topological sort, such that nodes are listed after all nodes that have them as descendants. This is similar to a pre-order traversal, except that when nodes are shared with more than one parent it is returned in the order of its last occurrence. bfs\tBreadth-first-search (BFS) traversal, traverses nodes left-to-right before traversing children. For example: set1 = ctx.actions.tset(MySet, value = &quot;foo&quot;) set2 = ctx.actions.tset(MySet, value = &quot;bar&quot;, children = [set1]) set3 = ctx.actions.tset(MySet, value = &quot;qux&quot;, children = [set1, set2]) values = list(set3.traverse(ordering = &quot;topological&quot;)) # This also works for projections args = set3.project_as_args(&quot;project&quot;, ordering = &quot;topological&quot;))  Following is an example of how different orderings evaluate: flowchart TD foo((foo)) bar((bar)) qux((qux)) qux --&gt; foo bar --&gt; foo qux --&gt; bar Ordering\tResultpreorder\t[&quot;qux&quot;, &quot;foo&quot;, &quot;bar&quot;] postorder\t[&quot;foo&quot;, &quot;bar&quot;, &quot;qux&quot;] topological\t[&quot;qux&quot;, &quot;bar&quot;, &quot;foo&quot;] bfs\t[&quot;qux&quot;, &quot;foo&quot;, &quot;bar&quot;] "},{"title":"Implementation details​","type":1,"pageTitle":"Transitive Sets","url":"/docs/rule_authors/transitive_sets/#implementation-details","content":""},{"title":"Performance​","type":1,"pageTitle":"Transitive Sets","url":"/docs/rule_authors/transitive_sets/#performance","content":"The performance benefits of tsets arise due to: Caching: projections and reductions are cached.Lazy Evaluation: projection traversals are evaluated lazily. "},{"title":"Evaluation​","type":1,"pageTitle":"Transitive Sets","url":"/docs/rule_authors/transitive_sets/#evaluation","content":"Projections and reductions are evaluated eagerly for each node of your transitive set. This means that if your projection throws an error, you'll find out when creating a set via ctx.actions.tset. "},{"title":"Deferred Materialization","type":0,"sectionRef":"#","url":"/docs/users/advanced/deferred_materialization/","content":"","keywords":""},{"title":"Pitfalls​","type":1,"pageTitle":"Deferred Materialization","url":"/docs/users/advanced/deferred_materialization/#pitfalls","content":"Buck2's deferred materialization makes assumptions about your Remote Execution backend. In particular, it expects that the TTL returned from action cache entries by your Remote Execution backend always exceeds the TTL of all output artifacts it references. Nonetheless, artifacts may also eventually expire from your Remote Execution backend. When that happens, builds using Deferred Materialization may fail if those artifacts are needed locally. A kill is necessary to recover from those builds. However, theRestarter can be used to mitigate this issue by restarting Buck2 daemon when it encounters an expired artifact. At Meta, artifacts get periodically refreshed, but open source RE backends do not expose the TTL of artifacts, so this feature does not work outside of Meta. "},{"title":"Enabling Deferred Materialization​","type":1,"pageTitle":"Deferred Materialization","url":"/docs/users/advanced/deferred_materialization/#enabling-deferred-materialization","content":"To enable deferred materialization, add this to yourBuckconfig: [buck2] materializations = deferred  "},{"title":"On-disk state​","type":1,"pageTitle":"Deferred Materialization","url":"/docs/users/advanced/deferred_materialization/#on-disk-state","content":"Buck2 can also optionally track its state on disk in a SQLite database. This allows Buck2 to remember what files are on disk across restarts. This can allow Buck2 to avoid re-downloading outputs from your Remote Execution backend if they are already on disk. To enable, add this to your Buckconfig: [buck2] sqlite_materializer_state = true  "},{"title":"Deferring Write Actions​","type":1,"pageTitle":"Deferred Materialization","url":"/docs/users/advanced/deferred_materialization/#deferring-write-actions","content":"To further speedup builds, Buck2 can also be instructed to not execute any writes on the critical path for a build. To enable, add this to your Buckconfig: [buck2] defer_write_actions = true  This mechanism is recommended if you're using the On-disk State, since it means Buck can omit writes entirely if the same content is already on disk. "},{"title":"buck2 clean --stale​","type":1,"pageTitle":"Deferred Materialization","url":"/docs/users/advanced/deferred_materialization/#buck2-clean---stale","content":"The deferred materializer can be configured to continuously delete stale artifacts, that haven't been recently accessed, or untracked artifacts, that exist in buck-out but not in the materalizer state. Unlike buck2 clean this does not fully wipe buck-out but it should not negatively impact build performance if you are building and rebasing regularly. Enabling this requires enabling on-disk state anddeferred write actions, and adding this to your Buckconfig: [buck2] clean_stale_enabled = true  It can be further configured by changing these default values: [buck2] # one week clean_stale_artifact_ttl_hours = 24 * 7 clean_stale_period_hours = 24 clean_stale_start_offset_hours = 12  clean_stale_start_offset_hours determines the time following daemon start up before the first clean will be scheduled.clean_stale_period_hours determines how frequently to schedule recurring clean events.clean_stale_artifact_ttl_hours determines how long artifacts should be kept in buck-out before cleaning them. If clean stale is running in the background at the same time that a build begins to materialize artifacts, the clean will be interrupted and not run again until after the next scheduled period, but it should be able to make gradual progress and prevent long term accumulation of artifacts. If needed, a clean can be manually triggered by calling buck2 clean --stale. "},{"title":"External Cells","type":0,"sectionRef":"#","url":"/docs/users/advanced/external_cells/","content":"","keywords":""},{"title":"Setting up an external cell​","type":1,"pageTitle":"External Cells","url":"/docs/users/advanced/external_cells/#setting-up-an-external-cell","content":"Configuring an external cell looks much like configuring a regular cell. First, add the cell to the cells section of your .buckconfig like normal: [cells] prelude = some/path  The external cell's files won't actually be generated in the repo. However, you still need to provide a path for it - this path influences the handling of tree files, since those cross cell boundaries. It's also used forexpand-external-cells, more on that below. Next, add an entry to the external_cells buckconfig section that specifies the &quot;origin&quot; of the external cell given an alias. This tells buck2 where you want to get the cell from, if not files in the source repo. [external_cells] prelude = bundled  For the bundled origin, that's it. Other origins may require additional configuration. "},{"title":"Origins​","type":1,"pageTitle":"External Cells","url":"/docs/users/advanced/external_cells/#origins","content":"Buck2 currently supports two external cell origins, bundled and git. "},{"title":"The bundled origin​","type":1,"pageTitle":"External Cells","url":"/docs/users/advanced/external_cells/#the-bundled-origin","content":"The bundled origin can only be used with the prelude cell, and provides access to a copy of the prelude that is bundled as part of the buck2 binary. This is useful as an easier-to-install alternative to vendoring or submoduling the prelude. "},{"title":"The git origin​","type":1,"pageTitle":"External Cells","url":"/docs/users/advanced/external_cells/#the-git-origin","content":"The git origin indicates that an external cell's content should be loaded from some git repo. It accepts two additional configuration parameters, git_originand commit, like this: [cells] root = . libfoo = libfoo [external_cells] libfoo = git [external_cell_libfoo] git_origin = https://github.com/facebook/foo commit_hash = &lt;sha1sum&gt;  The commit_hash value must be a sha1, it cannot be eg a branch name. "},{"title":"Expanding external cells​","type":1,"pageTitle":"External Cells","url":"/docs/users/advanced/external_cells/#expanding-external-cells","content":"Because external cells only represent a different way to access source files, buck2 provides an expand-external-cell command. This command will make a copy of the external cell into the path in the repo you specified for your cell. By commenting out the external_cells buckconfig entry, this allows you to make direct edits to the cell's files in your repo. "},{"title":"Details & Limitations​","type":1,"pageTitle":"External Cells","url":"/docs/users/advanced/external_cells/#details--limitations","content":"External cells can only be configured in the project root's .buckconfig. This also means that there is no support for &quot;transitive&quot; external cells, ie an external cell cannot specify additional external cells to pull in. External cells cannot have nested cells inside them. The cells buckconfig section of external cells is ignored. This is done to ensure that when using an external cell to access some dependency in a git repo, that git repo can still be an independently building project that specifies its own toolchain and prelude configuration. Because of this difference between external and non-external cells, it's possible that running buck2 expand-external-cell may not produce a working cell immediately, but instead require you to delete the cells section first. cell_aliases still work just like with regular cells. "},{"title":"Writing Rules","type":0,"sectionRef":"#","url":"/docs/rule_authors/writing_rules/","content":"","keywords":""},{"title":"Workflow by example​","type":1,"pageTitle":"Writing Rules","url":"/docs/rule_authors/writing_rules/#workflow-by-example","content":"The built-in Buck2 rules are stored in the prelude folder in the buck2 repo. To add a rule for a language, say pascal: Look atprelude/declsto see the attributes that are supported in Buck1 and are mirrored into Buck2. If pascal was an existing rule, you would see what attributes it takes (often it will be pascal_library and pascal_binary). Create a file pascal.bzl that will contain your rule implementations. The details are explained later, but a dummy rule looks like the following: def pascal_binary_impl(_ctx: AnalysisContext) -&gt; list[Provider]: return [DefaultInfo()] Create a directory in fbcode/buck2/tests/targets/rules/pascal withTARGETS and whatever source files and test targets you need to test your project. Note, Apple tests are currently located atxplat/buck2/tests/apple/.... Test your code with buck2 build fbcode//buck2/tests/targets/rules/pascal:. They should succeed with no actual output produced. Now implement the rules (see the rest of this page). note Before merging a diff, it's important that all your Starlark is warning free (if you don't want to set up Buck2 for local development, test it in CI). "},{"title":"Concepts and design​","type":1,"pageTitle":"Writing Rules","url":"/docs/rule_authors/writing_rules/#concepts-and-design","content":"A rule for a target uses attributes to declare actions, which produceartifacts that get included in providers. For example, given: def pascal_binary_impl(ctx: AnalysisContext) -&gt; list[Provider]: ... binary = ctx.actions.declare_output(ctx.attrs.out) ctx.actions.run([&quot;pascalc&quot;, ctx.attrs.srcs, &quot;-o&quot;, binary.as_output()]) return [ DefaultInfo(default_output = binary), ] pascal_binary = rule(impl = pascal_binary_impl, attrs = { &quot;out&quot;: attrs.string(), ... })  In the above snippet: Rule is pascal_binary, which is implemented by pascal_binary_impl. The rule says how to build things.Target will be something likefbcode//buck2/tests/targets/rules/pascal:my_binary. The rule implementationpascal_binary_impl will be called once per target.Attributes are the fields on the target (for example, you might haveout, which can be accessed via ctx.attrs.out).Actions are declared by the rule with things like ctx.actions.run, which takes a command line. Note that the actions are not run by the rule, but declared, so that Buck2 can run them later.Artifacts represent files on disk, which could be source or build outputs (binary in the above example). For build outputs, the artifact is produced by an action, and the existence of the artifact does not imply the build has been run: the artifact 'remembers' what should be run if it is required. Providers are returned, which is information that other rules get to use. These will often contain artifacts. The rule implementation takes in a ctx, which is the rule context. The two most important fields are ctx.attrs, which picks up the attributes declared by the rule, and ctx.actions, which lets you create new actions to actually do something. The output of any actions performed will be materialized in buck-out. However, only the defined outputs of providers are available for dependent rules to consume and only the actions necessary to produce those outputs being consumed will be run. By default, the default_output of the DefaultInfo provider is built and output during a buck build. "},{"title":"Providers​","type":1,"pageTitle":"Writing Rules","url":"/docs/rule_authors/writing_rules/#providers","content":"Providers are the data returned from a rule and are the only way that information from this rule is available to rules that depend on it. Every rule must return at least the DefaultInfo provider, but most will also return either RunInfo (because they are executable) or some custom provider (because they are incorporated into something that is ultimately executable). The DefaultInfo provider has a field default_output, which is the file that will be built when someone executes a buck2 build on this particular target, and the file that will be used when someone runs $(location target) or uses it as a source file (such as srcs = [&quot;:my_target&quot;].) The current rule of thumb is that if you can build the default_output, the rule must 'work', and, if usable, should be 'ready'. For example, for a binary, the executable and runtime libraries it depends on might be returned. For a library, because neither the static or dynamic library is the 'default', you merely have to do enough work to ensure that the static and dynamic library probably work. Similar to how DefaultInfo wraps a list of artifacts and $(location) selects from DefaultInfo, RunInfo wraps a command line and $(exe) selects fromRunInfo. For more information about command lines, see Run action, below. For libraries, usually you need to pass some information about the library up to the binary. The only information that dependents on the library get are the providers, so designing the information that flows around the provider is critical to designing good rules. For a hypothetical rule, you may decide you want the name of the library and the artifact that represents the .so file, for which you could define the following provider: PascalLibraryInfo = provider(fields=[ &quot;name&quot;, # The name of the library &quot;object&quot; # An artifact, the .so file that needs linking in ] )  Often, you'll grab your dependencies from all your providers: my_deps = [x[PascalLibraryInfo] for x in ctx.attrs.deps]  In many cases, it becomes apparent you need the transitive closure of all libraries (for example, the libraries and everything they depend upon), in which case, the standard pattern is to move to a provider of a list of record (see thetypes.mddocument in GitHub) and the flatten/dedupe functions, defining it as: PascalLibraryInfo = provider(fields=[&quot;links&quot;]) # a list of LinkData LinkData = record(name = str, object = &quot;artifact&quot;)  And then consuming it: my_links = dedupe(flatten([x[PascalLibraryInfo].links for x in ctx.attrs.deps])) my_info = PascalLibraryInfo(links = my_links)  However, this flatten/dupe pattern can get expensive, especially when you have a deep dependency graph. To fix that it's recommended to usetransitive sets. "},{"title":"Actions​","type":1,"pageTitle":"Writing Rules","url":"/docs/rule_authors/writing_rules/#actions","content":"There are several actions you can use to create symlink trees, and so on. Run action​ Of the various actions, the run action is by far the most important: it's the one that invokes a command line. A command line is both a list of string arguments and a list of artifacts they depend on; with syntactic niceties for adding artifacts to command lines in a way that ensures the dependencies are usually correct. Following are examples of command line manipulations: cmd = cmd_args([&quot;some&quot;, &quot;arguments&quot;]) cmd.add(&quot;another-arg&quot;) cmd.add(ctx.attrs.src) # An input artifact out = ctx.actions.declare_output(&quot;an output&quot;) cmd.add(out.as_output()) ctx.actions.run(cmd)  The action declare_output creates a new artifact which is not bound to anything. You can call .as_output() on it when adding it to a command line to say that this command line doesn't take the artifact as an input but produces it as an output. From now on, if out is used as a dependency (either to another command line, or in DefaultInfo) then the action will be run to produce that artifact. Typically, these outputs are declared (declare_output), bound in actx.actions.run call with .as_output(), then either used locally as the input to another action or returned in a provider. As another example: cmd = cmd_args([&quot;cp&quot;, input, output.as_output()]) ctx.actions.run(cmd)  A command provides both a string (what to write when used) and a list of artifacts (what must be available when used). Normally, as in the case above, the artifacts that are used correspond to those on the command line. But imagine the rule is changed to write the command to a shell script first: sh = ctx.actions.write(&quot;test.sh&quot;, [&quot;cp&quot;, input, output]) cmd = cmd_args([&quot;sh&quot;,sh],hidden=[input, output.as_output()]) ctx.actions.run(cmd)  The command has been written to a shell script, which is now run. Beforehand, all the artifacts used by the command appeared on the command line. Now they don't. However, the shell script still accesses input and output. To inform the run command, use the hidden field of the command line to declare the dependency. For more complicated actions, which perform meaningful logic beyond invoking a simple command, the tendency is to write custom Python scripts. Python scripts are used instead of shell scripts as they have better cross-platform compatibility and fewer hidden corners (especially in error paths). As an example of a Python helper, seemake_comp_db.py. A further advantage of using Python is that these commands can be tested in isolation, outside of Buck2. "},{"title":"Debugging​","type":1,"pageTitle":"Writing Rules","url":"/docs/rule_authors/writing_rules/#debugging","content":"The functions fail, print and pprint are your friends. To get started, abuck2 build fbcode//buck2/tests/targets/rules/pascal: builds everything orbuck2 run fbcode//buck2/tests/targets/rules/pascal:my_binary runs a specific binary that returns a RunInfo. "},{"title":"Testing Rules​","type":1,"pageTitle":"Writing Rules","url":"/docs/rule_authors/writing_rules/#testing-rules","content":"A common way to test is to use genrule to cause the produced binary to run and assert some properties from it. If your rule is in Buck1 and Buck2, use aTARGETS file so you can test with both. If your tests are incompatible with Buck1 (such as if it is a new rule), use TARGETS.v2, which will only be seen by Buck2 and won't cause errors with Buck1. "},{"title":"New rules​","type":1,"pageTitle":"Writing Rules","url":"/docs/rule_authors/writing_rules/#new-rules","content":"If your rule is not already in Buck1, then you can define it wherever you like, with a preference for it not being in fbcode/buck2/prelude. The only advantage of the prelude is that rules can be used without a corresponding load, which is generally considered a misfeature. The attributes should usually be placed adjacent to the rule itself. As an example, just below the pascal_binary_impl function, you could write: pascal_binary = rule( impl = pascal_binary_impl, attrs = { &quot;deps&quot;: attrs.list(attrs.dep()), &quot;src&quot;: attrs.source(), } )  "},{"title":"Restarter","type":0,"sectionRef":"#","url":"/docs/users/advanced/restarter/","content":"","keywords":""},{"title":"Enabling the Restarter​","type":1,"pageTitle":"Restarter","url":"/docs/users/advanced/restarter/#enabling-the-restarter","content":"To enable, add this to your Buckconfig: [buck2] restarter = true  "},{"title":"In Memory Cache","type":0,"sectionRef":"#","url":"/docs/users/advanced/in_memory_cache/","content":"","keywords":""},{"title":"Enabling the in-memory cache​","type":1,"pageTitle":"In Memory Cache","url":"/docs/users/advanced/in_memory_cache/#enabling-the-in-memory-cache","content":"This feature requires enablingDeferred Materialization first. This is necessary so that Buck2 knows what's on disk. This requirement might go away once we decouple keeping track of what's on disk and deferred materialization. Once done, to enable, add this to your Buckconfig: [buck2] hash_all_commands = true  "},{"title":"Buck2 Consoles","type":0,"sectionRef":"#","url":"/docs/users/build_observability/interactive_console/","content":"","keywords":""},{"title":"Simpleconsole​","type":1,"pageTitle":"Buck2 Consoles","url":"/docs/users/build_observability/interactive_console/#simpleconsole","content":"The simpleconsole prints the stdout/stderr messages and event spans, line by line. There is no resource usage telemetry emitted. "},{"title":"Demo​","type":1,"pageTitle":"Buck2 Consoles","url":"/docs/users/build_observability/interactive_console/#demo","content":" "},{"title":"Superconsole​","type":1,"pageTitle":"Buck2 Consoles","url":"/docs/users/build_observability/interactive_console/#superconsole","content":"The superconsole uses thesuperconsole library to provide an interactive console which shows the event spans going on within Buck2. "},{"title":"Demo​","type":1,"pageTitle":"Buck2 Consoles","url":"/docs/users/build_observability/interactive_console/#demo-1","content":" "},{"title":"Toggles​","type":1,"pageTitle":"Buck2 Consoles","url":"/docs/users/build_observability/interactive_console/#toggles","content":"The superconsole also provides several toggles to inspect ongoing Buck2 telemetry. To see what's available you can press ? or h. This will work as long as stdin is a TTY, which will be true most of the time if you're not piping anything into Buck2. To disable to allow alternate use of stdin, or for follow up pasted commands to not get swallowed, you can set theBUCK_NO_INTERACTIVE_CONSOLE environment variable, or use the flag--no-interactive-console. We support the following toggles: c - toggle commands (shown in superconsole by default)d - toggle DICE key statese - toggle debugging events, such as spans and instant event counts2 - toggle two lines mode when showing eventsr - toggle detailed remote execution info, such as uploads, downloads, and action cache callsi - toggle I/O countersp - display target configurations+ - show more lines- - show fewer linesh - show help Note: Not available yet for Windows "},{"title":"No console​","type":1,"pageTitle":"Buck2 Consoles","url":"/docs/users/build_observability/interactive_console/#no-console","content":"When specifying the none console type, Buck2 will only print if the build succeeded, or the error if the build failed. "},{"title":"Build Report","type":0,"sectionRef":"#","url":"/docs/users/build_observability/build_report/","content":"","keywords":""},{"title":"Schema​","type":1,"pageTitle":"Build Report","url":"/docs/users/build_observability/build_report/#schema","content":"BuildReport { # A unique ID identifying this buck invocation. Currently a UUID, however # that may change in the future. trace_id: str, # True if all requested targets built successfully success: bool, # The absolute path to the project root project_root: Path, # The results of the build, categorized by unconfigured target results: dict[TargetLabel, BuildReportEntry], # A cache for error message lookup. This is meant for deduplicating strings # that might otherwise appear many times in the build report and cause an # unnecessary size increase. They keys are used in other fields in the build # report in reference to these strings. strings: dict[str, str], # BUCK1 BACKCOMPAT ONLY! # # Currently always empty. Will be filled in if a flag is passed in the future. # # A map from targets that failed to build to error messages describing the # failure. failures: dict[TargetLabel, str], } BuildReportEntry { # The results of building the target in the given configurations configured: dict[Configuration, ConfiguredBuildReportEntry], # Errors encountered while building this target. # # Note that this does not include the errors that are found within the # `ConfiguredBuildReportEntry`s. Instead, it includes additional errors # which could not be associated with a specific configuration of the # target, typically because they occurred before the target could be # configured. errors: list[Error], # BUCK1 BACKCOMPAT ONLY! # # The two fields below are included for buck1 backwards compatibility only. # They are both computed by aggregating across all the configured targets in # the way you might expect. success: &quot;FAIL&quot; | &quot;SUCCESS, outputs: dict[str, list[Path]], # The path to the package containing this target, relative to the project # root. This is the source code location for this target. package_project_relative_path: Optional[str] } ConfiguredBuildReportEntry { # Did this target build successfully or not? success: &quot;FAIL&quot; | &quot;SUCCESS, # A map of subtargets that were built to a list of the successfully built # outputs for that subtarget. # # The keys are generated by joining the subtargets with a `|`. For example, # if you request to have `:target` and `:target[foo][bar]` built on the CLI, # this list will contain one entry for `&quot;&quot;` and one for `&quot;foo|bar&quot;`. outputs: dict[str, list[Path]], # The number of targets in the configured dependency graph of this target. # # This is only included if `-c buck2.log_configured_graph_size=true` is set. # Otherwise, it is left as None. configured_graph_size: Optional[uint], } Error { # The stringified hash of the same stringified error message that is shown to the user on the # console. The hash is stored as the key in the `strings` cache of the `BuildReport` message_content: str, # Structured action error. Present only if the error was actually an action error action_error: Optional[ActionError], # An index that can be used to detect duplicate errors. Two errors with the # same cause index have the same cause. Note that that does not mean that # they have the same error message. cause_index: uint, } ActionError { # The action key key: ActionKey, # The action name name: ActionName, # Digest of the action digest: str, # Stringified hash of the stderr of the action stderr: str, # Stringified hash of the stdout of the action stdout: str, # Stringified hash of the same stringified error message that is provided by the action error: str, # Optional list of error categorizations provided by an error handler which is invoked # in the event of a failed action, or an error message if the error handler failed. error_diagnostics: Optional[ActionErrorDiagnostics], } ActionKey { # The configured target, anon target, or bxl function which owns this action owner: str, } ActionName { # The category of the action category: str, # The optional identifier of the action identifier: Optional[str], } enum ActionErrorDiagnostics { # The list of sub errors if the error handler succeeded sub_errors: list[ActionSubError], # The stringified hash of the error message if the error handler failed handler_invocation_error: String, } ActionSubError { # Name of the error category. The category should be finer grain error categorizations # provided by the rule authors, and tend to be language specific. These should not be # any kind of shared concepts among all errors for all languages/rules. For example, # timeouts and infra errors should not go here - buck2 tries to categorize these types # of errors automatically. An example of a finer grain error category may be the error # code for rustc outputs. category: str, # The stringified hash of the extra message provided for the specific sub-error category. message_content: str, # List of error locations, if any locations: Optional[list[ActionErrorLocation]], } ActionErrorLocation { # File path where the error appeared, preferrably either project-relative or absolute. file: str, # Optional line number line: Optional[u64] }  "},{"title":"On Compatibility​","type":1,"pageTitle":"Build Report","url":"/docs/users/build_observability/build_report/#on-compatibility","content":"The format of the build report is generally stable. However, note that new fields may be added at any time, and you should ensure this does not cause your parsing to fail. A number of fields above are marked as being for buck1 backwards compatibility only. These fields all have superior alternatives available in the build report already. We would strongly prefer that new code neither use nor parse them, as this increases the likelyhood that they can be removed one day. The build report additionally outputs a few fields that are intentionally not documented here. Those fields are even less useful than ones documented as being for backwards compatibility only, and even closer to removal. Please avoid using or parsing these if at all possible. "},{"title":"Limitations​","type":1,"pageTitle":"Build Report","url":"/docs/users/build_observability/build_report/#limitations","content":"The build report currently has at least the following limitations: It includes only one action error per failed target. This is the expected behavior when --keep-going is not passed, but when --keep-going is passed, this is a bug.It is currently not generated when a non-existant package is specified on the command line. This is also a bug.It cannot be requested for any buck2 command other than buildErrors do not contain any additional metadata outside of the error message. This will be made available as such metadata is available in buck2.The &quot;failures&quot; field is always empty. This will be changed under a backcompat opt-in flag in the future. Finally, it's worth raising that the concept of error deduplication has some fundamental limitations; if two targets both refer to the same non-existant dependency, do those errors have the same cause (the dependency doesn't exist) or different causes (each target is individually broken)? As a result, the exact details of when two errors are considered to have the same cause are not generally stable, and may not always be what you expect. "},{"title":"Logging","type":0,"sectionRef":"#","url":"/docs/users/build_observability/logging/","content":"","keywords":""},{"title":"Event log format​","type":1,"pageTitle":"Logging","url":"/docs/users/build_observability/logging/#event-log-format","content":"Warning: the schemas are all subject to change, so we do not recommend relying on the format. For the source of truth, take a look at data.proto. "},{"title":"Invocation header​","type":1,"pageTitle":"Logging","url":"/docs/users/build_observability/logging/#invocation-header","content":"The first line of the event log is always the Invocation header: Invocation { # CLI args split into a list of strings command_line_args: List[str], # Expanded CLI args, which expand any argsfiles expanded_command_line_args: List[str], # Absolute path of the current working directory of the Buck2 command working_dir: str, # UUID of the Buck2 command trace_id: str, }  "},{"title":"Command result footer​","type":1,"pageTitle":"Logging","url":"/docs/users/build_observability/logging/#command-result-footer","content":"The last line is always the CommandResult: Result { # One of the result types of CommandResult protobuf type in data.proto result: BuildResponse | CqueryResponse | BxlResponse | ..., }  "},{"title":"Buck events​","type":1,"pageTitle":"Logging","url":"/docs/users/build_observability/logging/#buck-events","content":"The rest of the event log contain BuckEvents, which are eitherSpanStartEvents, SpanEndEvents, or InstantEvents. The BuckEvent format is roughly as follows: Event { # When the event was fired. This is always a 2-item list, where the first # value is millis, second value is micros timestamp: List[u64], # UUID of the Buck2 command, same one as the invocation header trace_id: str, # A trace-unique 64-bit integer identifying this event's span ID, # if this event begins a new span or belongs to one. span_id: u64, # A trace-unique 64-bit identifying the span that this event is logically # parented to. parent_id: u64, # See sections below for more details data: SpanStart | SpanEnd | Instant, }  Span starts​ The SpanStartEvent indicates that a span of work starting: SpanStart { # One of the data types of SpanStartEvent protobuf type in data.proto data: AnalysisStart | ActionExecutionStart | ..., }  Span ends​ The SpanEndEvent indicates that a span of work has finished: SpanEnd { # Duration of the span duration_us: u64, # CPU poll times for this span stats: SpanStats, # One of the data types of SpanEndEvent protobuf type in data.proto data: AnalysisEnd | ActionExecutionEnd | ..., } # CPU poll times for this span SpanStats { max_poll_time_us: u64, total_poll_time_us: u64, }  Instant events​ The InstantEvent represents a single point in time: InstantEvent { # One of the data types of InstantEvent protobuf type in data.proto data: ConsoleMessage | ActionError | ..., }  One specific instant event type that may be of interest is the SnapShot event, which includes some interesting details like RSS, CPU, I/O, remote execution, and DICE metrics. "},{"title":"Viewing the event log​","type":1,"pageTitle":"Logging","url":"/docs/users/build_observability/logging/#viewing-the-event-log","content":"Event logs can be accessed using commands under buck2 log show, which outputs the event logs in JSONL format. You can run buck2 log show --help to see all available options. Some useful commands: Show the logs for the most recent Buck2 command: buck2 log show  Show the logs for a specific Buck2 command, given the command's UUID: buck2 log show --trace-id &lt;UUID&gt;  Show the logs for a recent Buck2 command: buck2 log show --recent &lt;NUMBER&gt;  The JSON schema is derived from the protobuf types, and the log itself could be quite large. jq can be useful to find specific things. For example, this jq script shows the max event delay between a snapshot event creation on the daemon side, and when the client receives it. buck2 log show | jq -s ' map( .Event.data.Instant.data.Snapshot.this_event_client_delay_ms | select(. != null) ) | max'  "},{"title":"Buck2 Cheat Sheet","type":0,"sectionRef":"#","url":"/docs/users/cheat_sheet/","content":"","keywords":""},{"title":"How do I find all the targets for a package?​","type":1,"pageTitle":"Buck2 Cheat Sheet","url":"/docs/users/cheat_sheet/#how-do-i-find-all-the-targets-for-a-package","content":"Specify a build target pattern that represents the targets in the package. buck2 cquery //path/to/dir/...  The buck2 cquery command can accept abuild target pattern as a parameter. If you specify a build target pattern, Buck2 evaluates this pattern and shows all the build targets that match it. "},{"title":"How do I specify more than one target to buck2 cquery?​","type":1,"pageTitle":"Buck2 Cheat Sheet","url":"/docs/users/cheat_sheet/#how-do-i-specify-more-than-one-target-to-buck2-cquery","content":"Use the buck2 cquery set() operator. The following command line returns the target main in the build file in the root of the Buck2 project and all the targets from the build file in the myclass subdirectory of the root. buck2 cquery &quot;set( '//:main' '//myclass:' )&quot;  "},{"title":"How do I get the attribute names and values for the targets returned by a query?​","type":1,"pageTitle":"Buck2 Cheat Sheet","url":"/docs/users/cheat_sheet/#how-do-i-get-the-attribute-names-and-values-for-the-targets-returned-by-a-query","content":"Add the --output-attribute &lt;ATTRIBUTE&gt; or --output-all-attributes option to the command line, followed by regular expressions that represent the attributes of interest. buck2 cquery &quot;deps(//foo:bar)&quot; --output-attribute 'name' 'exported_headers'  The --output-attribute option enables you to specify which attributes Buck2 should return. Instead of returning the names of the targets that match the query expression, Buck2 returns the names and values of the specified attributes for those targets in JSON format. Attributes are specified as regular expressions. For example, '.*' matches all attributes. See thebuck2 cquery docs for more details. The output for the example query above might look something like the following. {&quot;//foo/bar/lib:lib&quot; : {&quot;exported_headers&quot; : [ &quot;App/util.h&quot; ],&quot;name&quot; : &quot;lib&quot;},&quot;//foo/bar:app&quot; : {&quot;exported_headers&quot; : [ &quot;App/lib.h&quot; ],&quot;name&quot; : &quot;app&quot;}}  "},{"title":"How do I perform a query *inside* of a rule?​","type":1,"pageTitle":"Buck2 Cheat Sheet","url":"/docs/users/cheat_sheet/#how-do-i-perform-a-query-inside-of-a-rule","content":"Buck2 supports certain string parameter macros to be used when defining a target. You can use the query macros as such: $(query_targets &quot;queryfunction(//:foo)&quot;) $(query_outputs &quot;queryfunction(//:foo)&quot;) $(query_targets_and_outputs [SEPARATOR] &quot;queryfunction(//:foo)&quot;)  Note, however, that the query macros are supported only forgenrule andapk_genrule. "},{"title":"How do I find the dependencies for a target?​","type":1,"pageTitle":"Buck2 Cheat Sheet","url":"/docs/users/cheat_sheet/#how-do-i-find-the-dependencies-for-a-target","content":"Use the deps() operator. buck2 cquery &quot;deps('//foo:bar')&quot; buck2 cquery &quot;deps('//foo:bar', 1, first_order_deps())&quot; buck2 cquery &quot;deps(set('//foo:bar' '//foo:lib' '//foo/baz:util'))&quot;  The deps operator finds the dependencies of the specified targets. The first argument represents the targets of interest. This can be a singlebuild target orbuild target pattern, or a set of these. The optional second argument is the depth of the search for dependencies from the specified targets. For example, 1, as shown in the example above, returns only the direct dependencies. If you do not provide this argument, the output is the complete set of transitive dependencies. How do I find the reverse-dependencies for a target, that is, the targets that *depend on* a specified target? Use the buck2 cquery rdeps() (reverse dependencies) operator. The following example, returns the targets in thetransitive closure of//foo:bar that depend directly on //example:baz. buck2 cquery &quot;rdeps('//foo:bar', '//example:baz', 1)&quot;  "},{"title":"How do I find the buildfile that contains the target that owns a source file?​","type":1,"pageTitle":"Buck2 Cheat Sheet","url":"/docs/users/cheat_sheet/#how-do-i-find-the-buildfile-that-contains-the-target-that-owns-a-source-file","content":"In order to find the build file associated with a source file, combine theowner operator with buildfile. For example, buck2 cquery &quot;buildfile(owner('foo/bar/main.cpp'))&quot;  first finds the targets that own foo/bar/main.cpp and then returns the build files, such as foo/bar/BUCK, that define those targets. "},{"title":"aquery","type":0,"sectionRef":"#","url":"/docs/users/commands/aquery/","content":"","keywords":""},{"title":"buck aquery​","type":1,"pageTitle":"aquery","url":"/docs/users/commands/aquery/#buck-aquery","content":"Perform queries on the action graph (experimental) The action graph consists of all the declared actions for a build, with dependencies when one action consumes the outputs of another action. Run `buck2 docs aquery` or https://buck2.build/docs/users/query/aquery/ for more documentation about the functions available in aquery expressions. Examples: Print the action producing a target's default output `buck2 aquery //java/com/example/app:amazing` List all the commands for run actions for building a target `buck2 aquery 'kind(run, deps(&quot;//java/com/example/app:amazing+more&quot;))' --output-attribute=cmd` Dynamic outputs (`ctx.actions.dynamic_output`): Currently, aquery interacts poorly with dynamic outputs. It may return incorrect results or otherwise behave unexpectedly. Usage: buck2-release aquery [OPTIONS] &lt;QUERY&gt; [QUERY_ARGS]... Arguments: &lt;QUERY&gt; the query to evaluate [QUERY_ARGS]... list of literals for a multi-query (one containing `%s` or `%Ss`) Options: -A, --output-all-attributes Output all attributes, equivalent of --output-attribute ''. Avoid using this flag in automation because it may be expensive to produce certain attributes, and because it makes harder to track which special attributes are used. -B, --output-basic-attributes Output basic attributes, namely those the user can supply, plus rule type and package name -a, --output-attribute &lt;ATTRIBUTE&gt; Regular expressions to match attributes. Regular expressions are used in &quot;search&quot; mode, so for example empty string matches all attributes including special attributes. When using in automation, please specify the regular expression to match the attribute precisely, for example `--output-attribute '^headers$'` to make it easier to track which special attributes are used. --output-attributes &lt;ATTRIBUTE&gt;... Deprecated: Use `--output-attribute` instead. List of space-separated attributes to output, --output-attributes attr1 attr2. --json Output in JSON format --dot Output in Graphviz Dot format --dot-compact Output in a more compact format than Graphviz Dot --output-format &lt;dot|dot_compact|json|starlark&gt; Output format (default: list). dot - dot graph format. dot_compact - compact alternative to dot format. json - JSON format. starlark - targets are printed like starlark code that would produce them. [possible values: dot, json, dot_compact, starlark] -h, --help Print help (see a summary with '-h') Target Configuration Options: --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"bxl","type":0,"sectionRef":"#","url":"/docs/users/commands/bxl/","content":"","keywords":""},{"title":"buck bxl​","type":1,"pageTitle":"bxl","url":"/docs/users/commands/bxl/#buck-bxl","content":"Run BXL scripts Usage: buck2-release bxl [OPTIONS] &lt;BXL label&gt; [-- &lt;BXL INPUT ARGS&gt;...] Arguments: &lt;BXL label&gt; The bxl function to execute as defined by the label of form `&lt;cell&gt;//path/file.bxl:&lt;function&gt;` [BXL INPUT ARGS]... Arguments passed to the bxl script Options: -M, --materializations &lt;MATERIALIZATIONS&gt; Materialize (or skip) the final artifacts, bypassing buckconfig. [possible values: all, none] --user-event-log &lt;PATH&gt; Write user events to this log file. Both user and internal events are written to main event log. If this flag is specified, user events are additionally written to user event log. Log format is JSONL, uncompressed if no known extensions are detected, or you can explicitly specify the compression via the file extension (ex: `.json-lines.gz` would be gzip compressed, `.json-lines.zst` would be zstd compressed). Resulting log is is compatible with `buck2 log show-user` --build-report &lt;PATH&gt; Print a build report `--build-report=-` will print the build report to stdout `--build-report=&lt;filepath&gt;` will write the build report to the file --enable-optional-validations &lt;VALIDATION_NAMES&gt; Comma separated list of validation names to run that are marked optional. By default, validations marked as optional are skipped. This option overrides the behaviour and executes those validations. --build-report-options &lt;BUILD_REPORT_OPTIONS&gt; Comma separated list of build report options. The following options are supported: `fill-out-failures`: fill out failures the same way Buck1 would. `package-project-relative-paths`: emit the project-relative path of packages for the targets that were built. -j, --num-threads &lt;THREADS&gt; Number of threads to use during execution (default is # cores) --local-only Enable only local execution. Will reject actions that cannot execute locally [env: BUCK_OFFLINE_BUILD=] --remote-only Enable only remote execution. Will reject actions that cannot execute remotely --prefer-local Enable hybrid execution. Will prefer executing actions that can execute locally on the local host --prefer-remote Enable hybrid execution. Will prefer executing actions that can execute remotely on RE and will avoid racing local and remote execution --unstable-no-execution Experimental: Disable all execution --no-remote-cache Do not perform remote cache queries or cache writes. If remote execution is enabled, the RE service might still deduplicate actions, so for e.g. benchmarking, using a random isolation dir is preferred [env: BUCK_OFFLINE_BUILD=] --write-to-cache-anyway Could be used to enable the action cache writes on the RE worker when no_remote_cache is specified --eager-dep-files Process dep files when they are generated (i.e. after running a command that produces dep files), rather than when they are used (i.e. before re-running a command that previously produced dep files). Use this when debugging commands that produce dep files. Note that commands that previously produced dep files will not re-run: only dep files produced during this command will be eagerly loaded --upload-all-actions Uploads every action to the RE service, regardless of whether the action needs to execute on RE. This is useful when debugging builds and trying to inspect actions which executed remotely. It's possible that the action result is cached but the action itself has expired. In this case, downloading the action itself would fail. Enabling this option would unconditionally upload all actions, thus you will not hit any expiration issues. --fail-fast If Buck hits an error, do as little work as possible before exiting. To illustrate the effect of this flag, consider an invocation of `build :foo :bar`. The default behavior of buck is to do enough work to get a result for the builds of each of `:foo` and `:bar`, and no more. This means that buck will continue to complete the build of `:bar` after the build of `:foo` has failed; however, once one dependency of `:foo` has failed, other dependencies will be cancelled unless they are needed by `:bar`. This flag changes the behavior of buck to not wait on `:bar` to complete once `:foo` has failed. Generally, this flag only has an effect on builds that specify multiple targets. `--keep-going` changes the behavior of buck to not only wait on `:bar` once one dependency of `:foo` has failed, but to additionally attempt to build other dependencies of `:foo` if possible. --keep-going If Buck hits an error, continue doing as much work as possible before exiting. See `--fail-fast` for more details. --skip-missing-targets If target is missing, then skip building instead of throwing error --skip-incompatible-targets If target is incompatible with the specified configuration, skip building instead of throwing error. This does not apply to targets specified with glob patterns `/...` or `:` which are skipped unconditionally --materialize-failed-inputs Materializes inputs for failed actions which ran on RE -h, --help Print help (see a summary with '-h') Target Configuration Options: --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"build","type":0,"sectionRef":"#","url":"/docs/users/commands/build/","content":"","keywords":""},{"title":"buck build​","type":1,"pageTitle":"build","url":"/docs/users/commands/build/#buck-build","content":"Build the specified targets Usage: buck2-release build [OPTIONS] [TARGET_PATTERNS]... Arguments: [TARGET_PATTERNS]... Patterns to build Options: --show-output Print the path to the output for each of the rules relative to the project root --show-full-output Print the absolute path to the output for each of the rules --show-simple-output Print only the path to the output for each of the rules relative to the project root --show-full-simple-output Print only the absolute path to the output for each of the rules --show-json-output Print the output paths relative to the project root, in JSON format --show-full-json-output Print the output absolute paths, in JSON format -M, --materializations &lt;MATERIALIZATIONS&gt; Materialize (or skip) the final artifacts, bypassing buckconfig. [possible values: all, none] --build-default-info Build default info (this is the default) --skip-default-info Do not build default info (this is not the default) --build-run-info Build runtime dependencies (this is the default) --skip-run-info Do not build runtime dependencies (this is not the default) --build-test-info Build tests (this is not the default) --skip-test-info Do not build tests (this is the default) --out &lt;OUTPUT_PATH&gt; Copy the output of the built target to this path (`-` to stdout) --output-hashes-file &lt;OUTPUT_HASHES_FILE&gt; Experimental: Path to a file where the Buck2 daemon should write a list of produced artifacts in json format --build-report &lt;PATH&gt; Print a build report `--build-report=-` will print the build report to stdout `--build-report=&lt;filepath&gt;` will write the build report to the file --enable-optional-validations &lt;VALIDATION_NAMES&gt; Comma separated list of validation names to run that are marked optional. By default, validations marked as optional are skipped. This option overrides the behaviour and executes those validations. --build-report-options &lt;BUILD_REPORT_OPTIONS&gt; Comma separated list of build report options. The following options are supported: `fill-out-failures`: fill out failures the same way Buck1 would. `package-project-relative-paths`: emit the project-relative path of packages for the targets that were built. -j, --num-threads &lt;THREADS&gt; Number of threads to use during execution (default is # cores) --local-only Enable only local execution. Will reject actions that cannot execute locally [env: BUCK_OFFLINE_BUILD=] --remote-only Enable only remote execution. Will reject actions that cannot execute remotely --prefer-local Enable hybrid execution. Will prefer executing actions that can execute locally on the local host --prefer-remote Enable hybrid execution. Will prefer executing actions that can execute remotely on RE and will avoid racing local and remote execution --unstable-no-execution Experimental: Disable all execution --no-remote-cache Do not perform remote cache queries or cache writes. If remote execution is enabled, the RE service might still deduplicate actions, so for e.g. benchmarking, using a random isolation dir is preferred [env: BUCK_OFFLINE_BUILD=] --write-to-cache-anyway Could be used to enable the action cache writes on the RE worker when no_remote_cache is specified --eager-dep-files Process dep files when they are generated (i.e. after running a command that produces dep files), rather than when they are used (i.e. before re-running a command that previously produced dep files). Use this when debugging commands that produce dep files. Note that commands that previously produced dep files will not re-run: only dep files produced during this command will be eagerly loaded --upload-all-actions Uploads every action to the RE service, regardless of whether the action needs to execute on RE. This is useful when debugging builds and trying to inspect actions which executed remotely. It's possible that the action result is cached but the action itself has expired. In this case, downloading the action itself would fail. Enabling this option would unconditionally upload all actions, thus you will not hit any expiration issues. --fail-fast If Buck hits an error, do as little work as possible before exiting. To illustrate the effect of this flag, consider an invocation of `build :foo :bar`. The default behavior of buck is to do enough work to get a result for the builds of each of `:foo` and `:bar`, and no more. This means that buck will continue to complete the build of `:bar` after the build of `:foo` has failed; however, once one dependency of `:foo` has failed, other dependencies will be cancelled unless they are needed by `:bar`. This flag changes the behavior of buck to not wait on `:bar` to complete once `:foo` has failed. Generally, this flag only has an effect on builds that specify multiple targets. `--keep-going` changes the behavior of buck to not only wait on `:bar` once one dependency of `:foo` has failed, but to additionally attempt to build other dependencies of `:foo` if possible. --keep-going If Buck hits an error, continue doing as much work as possible before exiting. See `--fail-fast` for more details. --skip-missing-targets If target is missing, then skip building instead of throwing error --skip-incompatible-targets If target is incompatible with the specified configuration, skip building instead of throwing error. This does not apply to targets specified with glob patterns `/...` or `:` which are skipped unconditionally --materialize-failed-inputs Materializes inputs for failed actions which ran on RE -h, --help Print help (see a summary with '-h') Target Configuration Options: -u, --target-universe &lt;TARGET_UNIVERSE&gt; Comma separated list of targets to construct a configured target universe. When the option is specified, command targets are be resolved in this universe. Additionally, `--target-platforms=` and `--modifier=` flags are be used to configure the universe targets, not the command targets. This argument is particularly recommended on most non-trivial cqueries. In the absence of this argument, buck2 will use the target literals in your cquery expression as the value for this argument, which may not be what you want. --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"clean","type":0,"sectionRef":"#","url":"/docs/users/commands/clean/","content":"","keywords":""},{"title":"buck clean​","type":1,"pageTitle":"clean","url":"/docs/users/commands/clean/#buck-clean","content":"Delete generated files and caches. The command also kills the buck2 daemon. Usage: buck2-release clean [OPTIONS] Options: --dry-run Performs a dry-run and prints the paths that would be removed. --stale [&lt;DURATION&gt;] Delete artifacts from buck-out older than 1 week or older than the specified duration, without killing the daemon --tracked-only Only considers tracked artifacts for cleanup. `buck-out` can contain untracked artifacts for different reasons: - Outputs from aborted actions - State getting deleted (e.g., new buckversion that changes the on-disk state format) - Writing to `buck-out` without being expected by Buck --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"completion","type":0,"sectionRef":"#","url":"/docs/users/commands/completion/","content":"","keywords":""},{"title":"buck completion​","type":1,"pageTitle":"completion","url":"/docs/users/commands/completion/#buck-completion","content":"Print completion configuration for shell For a one-time setup, run one of the following commands: source &lt;(buck2 completion bash) source &lt;(buck2 completion zsh) Usage: buck2-release completion [OPTIONS] &lt;SHELL&gt; Arguments: &lt;SHELL&gt; shell for which to generate completion script [possible values: bash, zsh] Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"cquery","type":0,"sectionRef":"#","url":"/docs/users/commands/cquery/","content":"","keywords":""},{"title":"buck cquery​","type":1,"pageTitle":"cquery","url":"/docs/users/commands/cquery/#buck-cquery","content":"Perform queries on the configured target graph The configured target graph includes information about the configuration (platforms) and transitions involved in building targets. In the configured graph, `selects` are fully resolved. The same target may appear in multiple different configurations (when printed, the configuration is after the target in parentheses). A user can specify a `--target-universe` flag to control how literals are resolved. When provided, any literals will resolve to all matching targets within the universe (which includes the targets passed as the universe and all transitive deps of them). When not provided, we implicitly set the universe to be rooted at every target literal in the `cquery`. Run `buck2 docs cquery` or https://buck2.build/docs/users/query/cquery/ for more documentation about the functions available in cquery expressions. Examples: Print all the attributes of a target `buck2 cquery //java/com/example/app:amazing --output-all-attributes` List the deps of a target (special characters in a target will require quotes): `buck2 cquery 'deps(&quot;//java/com/example/app:amazing+more&quot;)'` Usage: buck2-release cquery [OPTIONS] &lt;QUERY&gt; [QUERY_ARGS]... Arguments: &lt;QUERY&gt; the query to evaluate [QUERY_ARGS]... list of literals for a multi-query (one containing `%s` or `%Ss`) Options: -A, --output-all-attributes Output all attributes, equivalent of --output-attribute ''. Avoid using this flag in automation because it may be expensive to produce certain attributes, and because it makes harder to track which special attributes are used. -B, --output-basic-attributes Output basic attributes, namely those the user can supply, plus rule type and package name -a, --output-attribute &lt;ATTRIBUTE&gt; Regular expressions to match attributes. Regular expressions are used in &quot;search&quot; mode, so for example empty string matches all attributes including special attributes. When using in automation, please specify the regular expression to match the attribute precisely, for example `--output-attribute '^headers$'` to make it easier to track which special attributes are used. --output-attributes &lt;ATTRIBUTE&gt;... Deprecated: Use `--output-attribute` instead. List of space-separated attributes to output, --output-attributes attr1 attr2. --json Output in JSON format --dot Output in Graphviz Dot format --dot-compact Output in a more compact format than Graphviz Dot --output-format &lt;dot|dot_compact|json|starlark&gt; Output format (default: list). dot - dot graph format. dot_compact - compact alternative to dot format. json - JSON format. starlark - targets are printed like starlark code that would produce them. [possible values: dot, json, dot_compact, starlark] --show-providers Show the providers of the query result instead of the attributes and labels -h, --help Print help (see a summary with '-h') Target Configuration Options: -u, --target-universe &lt;TARGET_UNIVERSE&gt; Comma separated list of targets to construct a configured target universe. When the option is specified, command targets are be resolved in this universe. Additionally, `--target-platforms=` and `--modifier=` flags are be used to configure the universe targets, not the command targets. This argument is particularly recommended on most non-trivial cqueries. In the absence of this argument, buck2 will use the target literals in your cquery expression as the value for this argument, which may not be what you want. --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Starlark Profiling Options: --profile-mode &lt;PROFILE_MODE&gt; Profile target loading. When this option is enabled, Buck will profile every `BUCK` file loaded during the query and merge the results into a single profile. The command may return cached profile data if `BUCK` files were not invalidated. [possible values: time-flame, heap-flame-allocated, heap-flame-retained, heap-summary-allocated, heap-summary-retained, statement, bytecode, bytecode-pairs, typecheck, coverage] --profile-output &lt;PROFILE_OUTPUT&gt; Where to write profile output Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"ctargets","type":0,"sectionRef":"#","url":"/docs/users/commands/ctargets/","content":"","keywords":""},{"title":"buck ctargets​","type":1,"pageTitle":"ctargets","url":"/docs/users/commands/ctargets/#buck-ctargets","content":"Resolve target patterns to configured targets Usage: buck2-release ctargets [OPTIONS] [TARGET_PATTERNS]... Arguments: [TARGET_PATTERNS]... Patterns to interpret Options: --skip-missing-targets Skip missing targets from `BUCK` files when non-glob pattern is specified. This option does not skip missing packages and does not ignore errors of `BUCK` file evaluation -h, --help Print help (see a summary with '-h') Target Configuration Options: --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"expand-external-cell","type":0,"sectionRef":"#","url":"/docs/users/commands/expand-external-cell/","content":"","keywords":""},{"title":"buck expand-external-cell​","type":1,"pageTitle":"expand-external-cell","url":"/docs/users/commands/expand-external-cell/#buck-expand-external-cell","content":"Expand the contents of an external cell into the repo. The contents are placed at the path you specified for this cell in your buckconfig. If you additionally remove the entry from the `external_cells` section of your buckconfig, you can edit the files directly in the repo and see those edits reflected in your build. Note that this creates a point-in-time snapshot. The files in the repo will not be updated if you eg change the git commit of the cell in the future. Usage: buck2-release expand-external-cell [OPTIONS] &lt;CELL&gt; Arguments: &lt;CELL&gt; Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"help-env","type":0,"sectionRef":"#","url":"/docs/users/commands/help-env/","content":"","keywords":""},{"title":"buck help-env​","type":1,"pageTitle":"help-env","url":"/docs/users/commands/help-env/#buck-help-env","content":"Print help for environment variables used by buck2 Usage: buck2-release help-env [OPTIONS] Options: --self-testing Also print those environment variables that are only used for buck2 integration tests. These are all unstable and not meant to be used by most users. -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"docs","type":0,"sectionRef":"#","url":"/docs/users/commands/docs/","content":"","keywords":""},{"title":"buck docs​","type":1,"pageTitle":"docs","url":"/docs/users/commands/docs/#buck-docs","content":"Print documentation of specified symbols Usage: buck2-release docs [OPTIONS] &lt;COMMAND&gt; Commands: starlark Print documentation of user-defined starlark symbols starlark-builtins Generate documentation for starlark builtins uquery Print documentation for query/uquery cquery Print documentation for cquery aquery Print documentation for aquery help Print this message or the help of the given subcommand(s) Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck docs starlark​","type":1,"pageTitle":"docs","url":"/docs/users/commands/docs/#buck-docs-starlark","content":"Print documentation of user-defined starlark symbols Usage: buck2-release docs starlark [OPTIONS] [SYMBOL_PATTERNS]... Arguments: [SYMBOL_PATTERNS]... Patterns to interpret. //foo:bar.bzl is 'every symbol in //foo:bar.bzl', //foo:bar.bzl:baz only returns the documentation for the symbol 'baz' in //foo:bar.bzl Options: --markdown-files-destination-dir &lt;DESTINATION_DIR&gt; --markdown-files-native-subdir &lt;NATIVE_SUBDIR&gt; [default: native] --markdown-files-starlark-subdir &lt;STARLARK_SUBDIR&gt; [default: starlark] --format &lt;FORMAT&gt; how to format the returned documentation [default: json] [possible values: json, markdown_files] --builtins get documentation for built in functions, rules, and providers -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck docs starlark-builtins​","type":1,"pageTitle":"docs","url":"/docs/users/commands/docs/#buck-docs-starlark-builtins","content":"Generate documentation for starlark builtins. This command is designed to support buck2's doc generation and does not have stable output. Usage: buck2-release docs starlark-builtins [OPTIONS] --output-dir &lt;OUTPUT_DIR&gt; Options: --output-dir &lt;OUTPUT_DIR&gt; The directory to output files to -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck docs uquery​","type":1,"pageTitle":"docs","url":"/docs/users/commands/docs/#buck-docs-uquery","content":"Print documentation for query/uquery Usage: buck2-release docs uquery [OPTIONS] Options: --format &lt;FORMAT&gt; How to format the documentation [default: rendered] [possible values: markdown, rendered] -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck docs cquery​","type":1,"pageTitle":"docs","url":"/docs/users/commands/docs/#buck-docs-cquery","content":"Print documentation for cquery Usage: buck2-release docs cquery [OPTIONS] Options: --format &lt;FORMAT&gt; How to format the documentation [default: rendered] [possible values: markdown, rendered] -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck docs aquery​","type":1,"pageTitle":"docs","url":"/docs/users/commands/docs/#buck-docs-aquery","content":"Print documentation for aquery Usage: buck2-release docs aquery [OPTIONS] Options: --format &lt;FORMAT&gt; How to format the documentation [default: rendered] [possible values: markdown, rendered] -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"init","type":0,"sectionRef":"#","url":"/docs/users/commands/init/","content":"","keywords":""},{"title":"buck init​","type":1,"pageTitle":"init","url":"/docs/users/commands/init/#buck-init","content":"Initialize a buck2 project Usage: buck2-release init [OPTIONS] [PATH] Arguments: [PATH] The path to initialize the project in. The folder does not need to exist [default: .] Options: --no-prelude Don't include the standard prelude or generate toolchain definitions --allow-dirty Initialize the project even if the git repo at \\[PATH\\] has uncommitted changes --git Also initialize a git repository at the given path, and set up an appropriate `.gitignore` file -h, --help Print help (see a summary with '-h') Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"kill","type":0,"sectionRef":"#","url":"/docs/users/commands/kill/","content":"","keywords":""},{"title":"buck kill​","type":1,"pageTitle":"kill","url":"/docs/users/commands/kill/#buck-kill","content":"Kill the buck daemon. Note there's also `buck2 killall` and `buck2 clean`. `buck2 killall` kills all the buck2 processes on the machine. `buck2 clean` kills the buck2 daemon and also deletes the buck2 state files. Usage: buck2-release kill [OPTIONS] Options: -h, --help Print help (see a summary with '-h') Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"install","type":0,"sectionRef":"#","url":"/docs/users/commands/install/","content":"","keywords":""},{"title":"buck install​","type":1,"pageTitle":"install","url":"/docs/users/commands/install/#buck-install","content":"Build and install an application Usage: buck2-release install [OPTIONS] [TARGET]... [-- &lt;INSTALL_ARGS&gt;...] Arguments: [TARGET]... Target to build and install [INSTALL_ARGS]... Additional arguments passed to the install when running it Options: --installer-debug Prints installer output to stderr. It might break superconsole -r, --run Run an Android activity. Here for compatibility with buck1 - it is automatically forwarded to the installer -e, --emulator Use this option to use emulators only on Android. Here for compatibility with buck1 - it is automatically forwarded to the installer -d, --device Use this option to use real devices only on Android. Here for compatibility with buck1 - it is automatically forwarded to the installer -s, --serial &lt;SERIAL&gt; Use Android device or emulator with specific serial or UDID number. Here for compatibility with buck1 - it is automatically forwarded to the installer -x, --all-devices Use all connected Android devices and/or emulators (multi-install mode). Here for compatibility with buck1 - it is automatically forwarded to the installer -a, --activity &lt;ACTIVITY&gt; Android activity to launch e.g. com.facebook/.LoginActivity. Implies -r. Here for compatibility with buck1 - it is automatically forwarded to the installer -i, --intent-uri &lt;INTENT_URI&gt; Android Intent URI to launch e.g. fb://profile. Implies -r. Here for compatibility with buck1 - it is automatically forwarded to the installer -w, --wait-for-debugger Have the launched Android process wait for the debugger. Here for compatibility with buck1 - it is automatically forwarded to the installer -u, --uninstall Use this option to uninstall an installed app before installing again. Here for compatibility with buck1 - it is automatically forwarded to the installer -k, --keep Use this option to Keep user data when uninstalling. Here for compatibility with buck1 - it is automatically forwarded to the installer --build-report &lt;PATH&gt; Print a build report `--build-report=-` will print the build report to stdout `--build-report=&lt;filepath&gt;` will write the build report to the file --enable-optional-validations &lt;VALIDATION_NAMES&gt; Comma separated list of validation names to run that are marked optional. By default, validations marked as optional are skipped. This option overrides the behaviour and executes those validations. --build-report-options &lt;BUILD_REPORT_OPTIONS&gt; Comma separated list of build report options. The following options are supported: `fill-out-failures`: fill out failures the same way Buck1 would. `package-project-relative-paths`: emit the project-relative path of packages for the targets that were built. -j, --num-threads &lt;THREADS&gt; Number of threads to use during execution (default is # cores) --local-only Enable only local execution. Will reject actions that cannot execute locally [env: BUCK_OFFLINE_BUILD=] --remote-only Enable only remote execution. Will reject actions that cannot execute remotely --prefer-local Enable hybrid execution. Will prefer executing actions that can execute locally on the local host --prefer-remote Enable hybrid execution. Will prefer executing actions that can execute remotely on RE and will avoid racing local and remote execution --unstable-no-execution Experimental: Disable all execution --no-remote-cache Do not perform remote cache queries or cache writes. If remote execution is enabled, the RE service might still deduplicate actions, so for e.g. benchmarking, using a random isolation dir is preferred [env: BUCK_OFFLINE_BUILD=] --write-to-cache-anyway Could be used to enable the action cache writes on the RE worker when no_remote_cache is specified --eager-dep-files Process dep files when they are generated (i.e. after running a command that produces dep files), rather than when they are used (i.e. before re-running a command that previously produced dep files). Use this when debugging commands that produce dep files. Note that commands that previously produced dep files will not re-run: only dep files produced during this command will be eagerly loaded --upload-all-actions Uploads every action to the RE service, regardless of whether the action needs to execute on RE. This is useful when debugging builds and trying to inspect actions which executed remotely. It's possible that the action result is cached but the action itself has expired. In this case, downloading the action itself would fail. Enabling this option would unconditionally upload all actions, thus you will not hit any expiration issues. --fail-fast If Buck hits an error, do as little work as possible before exiting. To illustrate the effect of this flag, consider an invocation of `build :foo :bar`. The default behavior of buck is to do enough work to get a result for the builds of each of `:foo` and `:bar`, and no more. This means that buck will continue to complete the build of `:bar` after the build of `:foo` has failed; however, once one dependency of `:foo` has failed, other dependencies will be cancelled unless they are needed by `:bar`. This flag changes the behavior of buck to not wait on `:bar` to complete once `:foo` has failed. Generally, this flag only has an effect on builds that specify multiple targets. `--keep-going` changes the behavior of buck to not only wait on `:bar` once one dependency of `:foo` has failed, but to additionally attempt to build other dependencies of `:foo` if possible. --keep-going If Buck hits an error, continue doing as much work as possible before exiting. See `--fail-fast` for more details. --skip-missing-targets If target is missing, then skip building instead of throwing error --skip-incompatible-targets If target is incompatible with the specified configuration, skip building instead of throwing error. This does not apply to targets specified with glob patterns `/...` or `:` which are skipped unconditionally --materialize-failed-inputs Materializes inputs for failed actions which ran on RE -h, --help Print help (see a summary with '-h') Target Configuration Options: --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"killall","type":0,"sectionRef":"#","url":"/docs/users/commands/killall/","content":"","keywords":""},{"title":"buck killall​","type":1,"pageTitle":"killall","url":"/docs/users/commands/killall/#buck-killall","content":"Kill all buck2 processes on the machine Usage: buck2-release killall [OPTIONS] Options: -h, --help Print help (see a summary with '-h') Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"lsp","type":0,"sectionRef":"#","url":"/docs/users/commands/lsp/","content":"","keywords":""},{"title":"buck lsp​","type":1,"pageTitle":"lsp","url":"/docs/users/commands/lsp/#buck-lsp","content":"Start an LSP server for starlark files Usage: buck2-release lsp [OPTIONS] Options: -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"audit","type":0,"sectionRef":"#","url":"/docs/users/commands/audit/","content":"","keywords":""},{"title":"buck audit​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit","content":"Perform lower level queries Usage: buck2-release audit [OPTIONS] &lt;COMMAND&gt; Commands: cell Query information about the [cells] list in .buckconfig. classpath Prints out a target's classpaths if it has one. This command is deprecated and currently available for compatibility with buck1. We will replace this command with something that can audit the entire `TemplatePlaceholderInfo` in the future. config buck audit config configurations prints the constraints for configuration IDs includes list build file extensions imported at parse time. prelude print the interpreter prelude to stdout providers prints out the providers for a target pattern subtargets Print all subtargets analysis-queries buck audit analysis resolving query attrs execution-platform-resolution prints out information about execution platform resolution visibility Verify the visibility for transitive deps of the specified target(s) on the unconfigured target graph starlark Debug Starlark interpreter dep-files prints out the select files for a command deferred-materializer Access and interact with the deferred materializer output Query the action that produced the output artifact. Does not support BXL, test, scratch, or anon artifacts. If the configuration hash of the output path does not match the current platform configuration, the unconfigured target label will be returned. parse Parses the buck-out path into parts that may be useful (ex: config hash, file path to artifact). package-values Inspect package values help Print this message or the help of the given subcommand(s) Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit cell​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-cell","content":"Query information about the [cells] list in .buckconfig. Usage: buck2-release audit cell [OPTIONS] [CELL_ALIASES]... Arguments: [CELL_ALIASES]... Cell aliases to query. These aliases will be resolved in the working directory cell. Options: --json Output in JSON format --paths-only Don't include the cell name in the output --aliases If enabled and no explicit aliases are passed, will query for all aliases in the working directory cell. --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit classpath​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-classpath","content":"Prints out a target's classpaths if it has one. This command is deprecated and currently available for compatibility with buck1. We will replace this command with something that can audit the entire `TemplatePlaceholderInfo` in the future. Usage: buck2-release audit classpath [OPTIONS] [TARGET_PATTERNS]... Arguments: [TARGET_PATTERNS]... Target patterns to audit Options: --json Output in JSON format -h, --help Print help (see a summary with '-h') Target Configuration Options: --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit config​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-config","content":"buck audit config Usage: buck2-release audit config [OPTIONS] [SPECS]... Arguments: [SPECS]... config section/key specs of the form `section` or `section.key`. If any specs are provided, only values matching a spec will be printed (section headers will be printed only for sections with a key matching the spec) Options: --cell &lt;CELL&gt; --all-cells Produce information for all cells that Buck2 knows about --output-format &lt;OUTPUT_FORMAT&gt; [possible values: simple, json] --json --location &lt;LOCATION_STYLE&gt; [default: none] [possible values: none, direct, extended] --value &lt;VALUE_STYLE&gt; [default: resolved] [possible values: resolved, raw, both] --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit configurations​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-configurations","content":"prints the constraints for configuration IDs Usage: buck2-release audit configurations [OPTIONS] [configurations]... Arguments: [configurations]... configurations to audit (example: `cell//package:target-105fe3389fc7e436`). If none provided, will print information about all known configurations. Options: --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit includes​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-includes","content":"list build file extensions imported at parse time. Usage: buck2-release audit includes [OPTIONS] [BUILD_FILES]... Arguments: [BUILD_FILES]... Build files to audit. These are expected to be relative paths from the working dir cell. Options: --json Print json representation of outputs --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit prelude​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-prelude","content":"print the interpreter prelude to stdout Usage: buck2-release audit prelude [OPTIONS] Options: --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit providers​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-providers","content":"prints out the providers for a target pattern Usage: buck2-release audit providers [OPTIONS] &lt;TARGET_PATTERNS&gt;... Arguments: &lt;TARGET_PATTERNS&gt;... Patterns to analyze Options: --quiet -l, --list List the available providers --print-debug Print the providers using debug format (very verbose) -h, --help Print help (see a summary with '-h') Target Configuration Options: -u, --target-universe &lt;TARGET_UNIVERSE&gt; Comma separated list of targets to construct a configured target universe. When the option is specified, command targets are be resolved in this universe. Additionally, `--target-platforms=` and `--modifier=` flags are be used to configure the universe targets, not the command targets. This argument is particularly recommended on most non-trivial cqueries. In the absence of this argument, buck2 will use the target literals in your cquery expression as the value for this argument, which may not be what you want. --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit subtargets​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-subtargets","content":"Print all subtargets Usage: buck2-release audit subtargets [OPTIONS] &lt;TARGET_PATTERNS&gt;... Arguments: &lt;TARGET_PATTERNS&gt;... Patterns to analyze Options: --shallow Do not recursively print all nested subtargets; print only the first level. This is set to false by default --json Print subtargets as JSON -h, --help Print help (see a summary with '-h') Target Configuration Options: -u, --target-universe &lt;TARGET_UNIVERSE&gt; Comma separated list of targets to construct a configured target universe. When the option is specified, command targets are be resolved in this universe. Additionally, `--target-platforms=` and `--modifier=` flags are be used to configure the universe targets, not the command targets. This argument is particularly recommended on most non-trivial cqueries. In the absence of this argument, buck2 will use the target literals in your cquery expression as the value for this argument, which may not be what you want. --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit analysis-queries​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-analysis-queries","content":"buck audit analysis resolving query attrs Usage: buck2-release audit analysis-queries [OPTIONS] [TARGET_PATTERNS]... Arguments: [TARGET_PATTERNS]... Patterns to evaluate. The query attributes for targets matching these patterns will be evaluated Options: --include-outputs Enable to print the outputs for the targets in the resolved queries -h, --help Print help (see a summary with '-h') Target Configuration Options: -u, --target-universe &lt;TARGET_UNIVERSE&gt; Comma separated list of targets to construct a configured target universe. When the option is specified, command targets are be resolved in this universe. Additionally, `--target-platforms=` and `--modifier=` flags are be used to configure the universe targets, not the command targets. This argument is particularly recommended on most non-trivial cqueries. In the absence of this argument, buck2 will use the target literals in your cquery expression as the value for this argument, which may not be what you want. --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit execution-platform-resolution​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-execution-platform-resolution","content":"prints out information about execution platform resolution Usage: buck2-release audit execution-platform-resolution [OPTIONS] [TARGET_PATTERNS]... Arguments: [TARGET_PATTERNS]... Patterns to analyze Options: -h, --help Print help (see a summary with '-h') Target Configuration Options: -u, --target-universe &lt;TARGET_UNIVERSE&gt; Comma separated list of targets to construct a configured target universe. When the option is specified, command targets are be resolved in this universe. Additionally, `--target-platforms=` and `--modifier=` flags are be used to configure the universe targets, not the command targets. This argument is particularly recommended on most non-trivial cqueries. In the absence of this argument, buck2 will use the target literals in your cquery expression as the value for this argument, which may not be what you want. --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit visibility​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-visibility","content":"Verify the visibility for transitive deps of the specified target(s) on the unconfigured target graph Usage: buck2-release audit visibility [OPTIONS] [TARGET_PATTERNS]... Arguments: [TARGET_PATTERNS]... Target pattern(s) to analyze. Options: --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit starlark​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-starlark","content":"Debug Starlark interpreter Usage: buck2-release audit starlark [OPTIONS] &lt;COMMAND&gt; Commands: module Inspect Starlark module by fully qualified import string like foo//bar:baz.bzl package-deps Inspect Starlark package file all bzl dependencies by package name like foo//bar/baz help Print this message or the help of the given subcommand(s) Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  buck audit starlark module​ Inspect Starlark module by fully qualified import string like foo//bar:baz.bzl Usage: buck2-release audit starlark module [OPTIONS] &lt;IMPORT_PATH&gt; Arguments: &lt;IMPORT_PATH&gt; Module import path Options: --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  buck audit starlark package-deps​ Inspect Starlark package file all bzl dependencies by package name like foo//bar/baz Usage: buck2-release audit starlark package-deps [OPTIONS] &lt;PACKAGE&gt; Arguments: &lt;PACKAGE&gt; Package Options: --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit dep-files​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-dep-files","content":"prints out the select files for a command Usage: buck2-release audit dep-files [OPTIONS] &lt;PATTERN&gt; &lt;CATEGORY&gt; [IDENTIFIER] Arguments: &lt;PATTERN&gt; Target to query dep files for &lt;CATEGORY&gt; Action category [IDENTIFIER] Action identifier Options: -h, --help Print help (see a summary with '-h') Target Configuration Options: --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit deferred-materializer​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-deferred-materializer","content":"Access and interact with the deferred materializer Usage: buck2-release audit deferred-materializer [OPTIONS] &lt;COMMAND&gt; Commands: list list-subscriptions fsck refresh get-refresh-log Get the log for TTL refreshes test-iter flush-access-times help Print this message or the help of the given subcommand(s) Options: --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  buck audit deferred-materializer list​ Usage: buck2-release audit deferred-materializer list [OPTIONS] Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  buck audit deferred-materializer list-subscriptions​ Usage: buck2-release audit deferred-materializer list-subscriptions [OPTIONS] Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  buck audit deferred-materializer fsck​ Usage: buck2-release audit deferred-materializer fsck [OPTIONS] Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  buck audit deferred-materializer refresh​ Usage: buck2-release audit deferred-materializer refresh [OPTIONS] &lt;MIN_TTL&gt; Arguments: &lt;MIN_TTL&gt; Minimum TTL to require for actions Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  buck audit deferred-materializer get-refresh-log​ Get the log for TTL refreshes Usage: buck2-release audit deferred-materializer get-refresh-log [OPTIONS] Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  buck audit deferred-materializer test-iter​ Usage: buck2-release audit deferred-materializer test-iter [OPTIONS] Options: --count &lt;COUNT&gt; [default: 1] -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  buck audit deferred-materializer flush-access-times​ Usage: buck2-release audit deferred-materializer flush-access-times [OPTIONS] Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit output​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-output","content":"Query the action that produced the output artifact. Does not support BXL, test, scratch, or anon artifacts. If the configuration hash of the output path does not match the current platform configuration, the unconfigured target label will be returned. Usage: buck2-release audit output [OPTIONS] &lt;OUTPUT_PATH&gt; Arguments: &lt;OUTPUT_PATH&gt; The buck-out path to the build artifact, starting with `buck-out` and including the configuration platform. Options: --json -A, --output-all-attributes Output all attributes, equivalent of --output-attribute ''. Avoid using this flag in automation because it may be expensive to produce certain attributes, and because it makes harder to track which special attributes are used. -B, --output-basic-attributes Output basic attributes, namely those the user can supply, plus rule type and package name -a, --output-attribute &lt;ATTRIBUTE&gt; Regular expressions to match attributes. Regular expressions are used in &quot;search&quot; mode, so for example empty string matches all attributes including special attributes. When using in automation, please specify the regular expression to match the attribute precisely, for example `--output-attribute '^headers$'` to make it easier to track which special attributes are used. --output-attributes &lt;ATTRIBUTE&gt;... Deprecated: Use `--output-attribute` instead. List of space-separated attributes to output, --output-attributes attr1 attr2. -h, --help Print help (see a summary with '-h') Target Configuration Options: --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit parse​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-parse","content":"Parses the buck-out path into parts that may be useful (ex: config hash, file path to artifact). Usage: buck2-release audit parse [OPTIONS] &lt;OUTPUT_PATH&gt; Options: -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format --modifier &lt;VALUE&gt; This option is not used --json --output-attribute &lt;OUTPUT_ATTRIBUTE&gt; &lt;OUTPUT_PATH&gt; The buck-out path to the build artifact, starting with `buck-out` and including the configuration platform. Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck audit package-values​","type":1,"pageTitle":"audit","url":"/docs/users/commands/audit/#buck-audit-package-values","content":"Inspect package values. Package values is the thing set with `write_package_value` function from `PACKAGE` files. Usage: buck2-release audit package-values [OPTIONS] [PACKAGES]... Arguments: [PACKAGES]... Package names to inspect (like `//foo/bar`, no trailing colon) Options: --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"log","type":0,"sectionRef":"#","url":"/docs/users/commands/log/","content":"","keywords":""},{"title":"buck log​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log","content":"Commands for interacting with buck2 logs Usage: buck2-release log [OPTIONS] &lt;COMMAND&gt; Commands: what-ran Output everything Buck2 ran from selected invocation what-failed Outputs every command that failed in the selected invocation path Output the path to the selected log show Outputs the log in JSON format from selected invocation cmd Show buck command line arguments from selected invocation what-up Show the spans that were open when the log ended what-materialized Outputs materializations from selected invocation what-uploaded Outputs stats about uploads to RE from the selected invocation critical-path Show the critical path for a selected build replay Replay an event log show-user Converts the event log from a selected invocation into a user event log, in JSONL format summary Outputs high level statistics about the build help Print this message or the help of the given subcommand(s) Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log what-ran​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-what-ran","content":"Output everything Buck2 ran from selected invocation. The output is presented as a series of tab-delimited records with the following structure: The reason for executing a given command. That's either to build or to test. The identity of this command. This will include the target that ran required it. The executor for this command. This will either be RE or local. Details to reproduce it. For RE, that's the action digest. For local, the command. To reproduce an action that ran on RE, use the following command then follow the instructions. The DIGEST is of the form `hash:size`. frecli cas download-action DIGEST To reproduce an action that ran locally, make sure your working directory is the project root (if unsure, use `buck2 root --kind project` to find it), then run the command. The command is already shell-quoted. Usage: buck2-release log what-ran [OPTIONS] [PATH] Arguments: [PATH] A path to an event-log file to read from Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally --format &lt;OUTPUT&gt; Which output format to use for this command [default: tabulated] [possible values: tabulated, json, csv] --emit-cache-queries --skip-cache-hits --skip-remote-executions --skip-local-executions --filter-category &lt;FILTER_CATEGORY&gt; Regular expression to filter commands by given action category (i.e. type of of actions that are similar but operate on different inputs, such as invocations of a C++ compiler (whose category would be `cxx_compile`)). Matches by full string --failed Show only commands that failed --incomplete Show only commands that were not completed. That is command were running if buck2 process was killed, or command currently running if buck2 is running build now --show-std-err Show also std_err from commands that are run. If the command fails before completing, we display &quot;&lt;command did not finish executing&gt;&quot;. If it finishes but there is no error, we display &quot;&lt;stderr is empty&gt;&quot;. Otherwise, std_err is shown. For JSON, we show raw values and null for non-completion --omit-empty-std-err Omit commands if their std_err is empty -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log what-failed​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-what-failed","content":"Outputs every command that failed in the selected invocation. Look at the help for what-ran to understand the output format. Usage: buck2-release log what-failed [OPTIONS] [PATH] Arguments: [PATH] A path to an event-log file to read from Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally --format &lt;OUTPUT&gt; Which output format to use for this command [default: tabulated] [possible values: tabulated, json, csv] --emit-cache-queries --skip-cache-hits --skip-remote-executions --skip-local-executions --filter-category &lt;FILTER_CATEGORY&gt; Regular expression to filter commands by given action category (i.e. type of of actions that are similar but operate on different inputs, such as invocations of a C++ compiler (whose category would be `cxx_compile`)). Matches by full string -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log path​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-path","content":"Output the path to the selected log Usage: buck2-release log path [OPTIONS] [PATH] Arguments: [PATH] A path to an event-log file to read from Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally --all List all the logs -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log show​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-show","content":"Outputs the log in JSON format from selected invocation Usage: buck2-release log show [OPTIONS] [PATH] Arguments: [PATH] A path to an event-log file to read from Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log cmd​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-cmd","content":"Show buck command line arguments from selected invocation. This command output is not machine readable. Robots, please use `buck2 log show`. Usage: buck2-release log cmd [OPTIONS] [PATH] Arguments: [PATH] A path to an event-log file to read from Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally --expand Show @-expanded command line arguments instead of the original command line -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log what-up​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-what-up","content":"Show the spans that were open when the log ended Usage: buck2-release log what-up [OPTIONS] [PATH] Arguments: [PATH] A path to an event-log file to read from Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally --after &lt;NUMBER&gt; Print the actions that where open after certain amount of milliseconds -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log what-materialized​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-what-materialized","content":"Outputs materializations from selected invocation. The output is a tab-separated list containing the path, the materialization method, the file count, and the total size (after decompression). Usage: buck2-release log what-materialized [OPTIONS] [PATH] Arguments: [PATH] A path to an event-log file to read from Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally -s, --sort-by-size Sort the output by total bytes in ascending order --aggregate-by-ext Aggregates the output by file extension --format &lt;OUTPUT&gt; Which output format to use for this command [default: tabulated] [possible values: tabulated, json, csv] -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log what-uploaded​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-what-uploaded","content":"Outputs stats about uploads to RE from the selected invocation Usage: buck2-release log what-uploaded [OPTIONS] [PATH] Arguments: [PATH] A path to an event-log file to read from Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally --format &lt;OUTPUT&gt; Which output format to use for this command [default: tabulated] [possible values: tabulated, json, csv] --aggregate-by-ext Aggregates the output by file extension -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log critical-path​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-critical-path","content":"Show the critical path for a selected build. This produces tab-delimited output listing every node on the critical path. It includes the kind of node, its name, category and identfier, as well as total duration (runtime of this node), user duration (duration the user can improve) and potential improvement before this node stops being on the critical path. All durations are in microseconds. Usage: buck2-release log critical-path [OPTIONS] [PATH] Arguments: [PATH] A path to an event-log file to read from Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally --format &lt;FORMAT&gt; Which output format to use for this command [default: tabulated] [possible values: tabulated, json, csv] -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log replay​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-replay","content":"Replay an event log. This command allows visualizing an existing event log in a Superconsole. Usage: buck2-release log replay [OPTIONS] [PATH] [OVERRIDE_ARGS]... Arguments: [PATH] A path to an event-log file to read from [OVERRIDE_ARGS]... Override the arguments Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally --speed &lt;NUMBER&gt; Control the playback speed using a float (i.e. 0.5, 2, etc) --preload Preload the event log. This is typically only useful for benchmarking -h, --help Print help (see a summary with '-h') Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log show-user​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-show-user","content":"Converts the event log from a selected invocation into a user event log, in JSONL format Usage: buck2-release log show-user [OPTIONS] [PATH] Arguments: [PATH] A path to an event-log file to read from Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck log summary​","type":1,"pageTitle":"log","url":"/docs/users/commands/log/#buck-log-summary","content":"Outputs high level statistics about the build Usage: buck2-release log summary [OPTIONS] [PATH] Arguments: [PATH] A path to an event-log file to read from Options: --recent &lt;NUMBER&gt; Open the event-log file from a recent command --trace-id &lt;ID&gt; Show log by trace id --allow-remote This option does nothing --no-remote Do not allow downloading the log from manifold if it's not found locally -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"profile","type":0,"sectionRef":"#","url":"/docs/users/commands/profile/","content":"","keywords":""},{"title":"buck profile​","type":1,"pageTitle":"profile","url":"/docs/users/commands/profile/#buck-profile","content":"Run starlark profiler Usage: buck2-release profile [OPTIONS] &lt;COMMAND&gt; Commands: analysis Profile analysis loading Profile `BUCK` file evaluation bxl Profile BXL script help Print this message or the help of the given subcommand(s) Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck profile analysis​","type":1,"pageTitle":"profile","url":"/docs/users/commands/profile/#buck-profile-analysis","content":"Profile analysis Usage: buck2-release profile analysis [OPTIONS] --output &lt;PATH&gt; --mode &lt;MODE&gt; [TARGET_PATTERNS]... Arguments: [TARGET_PATTERNS]... Options: -r, --recursive In analysis profiling, capture the profile of the target and its dependencies, and output the merged profile -o, --output &lt;PATH&gt; Output file path for profile data. File will be created if it does not exist, and overwritten if it does. --mode &lt;MODE&gt; Profile mode. Memory profiling modes have suffixes either `-allocated` or `-retained`. `-retained` means memory kept in frozen starlark heap after analysis complete. `-retained` does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis. `-allocated` means allocated memory, including memory which is later garbage collected. [possible values: time-flame, heap-flame-allocated, heap-flame-retained, heap-summary-allocated, heap-summary-retained, statement, bytecode, bytecode-pairs, typecheck, coverage] -h, --help Print help (see a summary with '-h') Target Configuration Options: -u, --target-universe &lt;TARGET_UNIVERSE&gt; Comma separated list of targets to construct a configured target universe. When the option is specified, command targets are be resolved in this universe. Additionally, `--target-platforms=` and `--modifier=` flags are be used to configure the universe targets, not the command targets. This argument is particularly recommended on most non-trivial cqueries. In the absence of this argument, buck2 will use the target literals in your cquery expression as the value for this argument, which may not be what you want. --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck profile loading​","type":1,"pageTitle":"profile","url":"/docs/users/commands/profile/#buck-profile-loading","content":"Profile `BUCK` file evaluation Usage: buck2-release profile loading [OPTIONS] --output &lt;PATH&gt; --mode &lt;MODE&gt; [TARGET_PATTERNS]... Arguments: [TARGET_PATTERNS]... Options: -r, --recursive In analysis profiling, capture the profile of the target and its dependencies, and output the merged profile -o, --output &lt;PATH&gt; Output file path for profile data. File will be created if it does not exist, and overwritten if it does. --mode &lt;MODE&gt; Profile mode. Memory profiling modes have suffixes either `-allocated` or `-retained`. `-retained` means memory kept in frozen starlark heap after analysis complete. `-retained` does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis. `-allocated` means allocated memory, including memory which is later garbage collected. [possible values: time-flame, heap-flame-allocated, heap-flame-retained, heap-summary-allocated, heap-summary-retained, statement, bytecode, bytecode-pairs, typecheck, coverage] -h, --help Print help (see a summary with '-h') Target Configuration Options: -u, --target-universe &lt;TARGET_UNIVERSE&gt; Comma separated list of targets to construct a configured target universe. When the option is specified, command targets are be resolved in this universe. Additionally, `--target-platforms=` and `--modifier=` flags are be used to configure the universe targets, not the command targets. This argument is particularly recommended on most non-trivial cqueries. In the absence of this argument, buck2 will use the target literals in your cquery expression as the value for this argument, which may not be what you want. --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck profile bxl​","type":1,"pageTitle":"profile","url":"/docs/users/commands/profile/#buck-profile-bxl","content":"Profile BXL script Usage: buck2-release profile bxl [OPTIONS] --output &lt;PATH&gt; --mode &lt;MODE&gt; &lt;BXL label&gt; [-- &lt;BXL INPUT ARGS&gt;...] Arguments: &lt;BXL label&gt; The bxl function to execute as defined by the label of form `&lt;cell&gt;//path/file.bxl:&lt;function&gt;` [BXL INPUT ARGS]... Arguments passed to the bxl script Options: -M, --materializations &lt;MATERIALIZATIONS&gt; Materialize (or skip) the final artifacts, bypassing buckconfig. [possible values: all, none] --user-event-log &lt;PATH&gt; Write user events to this log file. Both user and internal events are written to main event log. If this flag is specified, user events are additionally written to user event log. Log format is JSONL, uncompressed if no known extensions are detected, or you can explicitly specify the compression via the file extension (ex: `.json-lines.gz` would be gzip compressed, `.json-lines.zst` would be zstd compressed). Resulting log is is compatible with `buck2 log show-user` --build-report &lt;PATH&gt; Print a build report `--build-report=-` will print the build report to stdout `--build-report=&lt;filepath&gt;` will write the build report to the file --enable-optional-validations &lt;VALIDATION_NAMES&gt; Comma separated list of validation names to run that are marked optional. By default, validations marked as optional are skipped. This option overrides the behaviour and executes those validations. --build-report-options &lt;BUILD_REPORT_OPTIONS&gt; Comma separated list of build report options. The following options are supported: `fill-out-failures`: fill out failures the same way Buck1 would. `package-project-relative-paths`: emit the project-relative path of packages for the targets that were built. -j, --num-threads &lt;THREADS&gt; Number of threads to use during execution (default is # cores) --local-only Enable only local execution. Will reject actions that cannot execute locally [env: BUCK_OFFLINE_BUILD=] --remote-only Enable only remote execution. Will reject actions that cannot execute remotely --prefer-local Enable hybrid execution. Will prefer executing actions that can execute locally on the local host --prefer-remote Enable hybrid execution. Will prefer executing actions that can execute remotely on RE and will avoid racing local and remote execution --unstable-no-execution Experimental: Disable all execution --no-remote-cache Do not perform remote cache queries or cache writes. If remote execution is enabled, the RE service might still deduplicate actions, so for e.g. benchmarking, using a random isolation dir is preferred [env: BUCK_OFFLINE_BUILD=] --write-to-cache-anyway Could be used to enable the action cache writes on the RE worker when no_remote_cache is specified --eager-dep-files Process dep files when they are generated (i.e. after running a command that produces dep files), rather than when they are used (i.e. before re-running a command that previously produced dep files). Use this when debugging commands that produce dep files. Note that commands that previously produced dep files will not re-run: only dep files produced during this command will be eagerly loaded --upload-all-actions Uploads every action to the RE service, regardless of whether the action needs to execute on RE. This is useful when debugging builds and trying to inspect actions which executed remotely. It's possible that the action result is cached but the action itself has expired. In this case, downloading the action itself would fail. Enabling this option would unconditionally upload all actions, thus you will not hit any expiration issues. --fail-fast If Buck hits an error, do as little work as possible before exiting. To illustrate the effect of this flag, consider an invocation of `build :foo :bar`. The default behavior of buck is to do enough work to get a result for the builds of each of `:foo` and `:bar`, and no more. This means that buck will continue to complete the build of `:bar` after the build of `:foo` has failed; however, once one dependency of `:foo` has failed, other dependencies will be cancelled unless they are needed by `:bar`. This flag changes the behavior of buck to not wait on `:bar` to complete once `:foo` has failed. Generally, this flag only has an effect on builds that specify multiple targets. `--keep-going` changes the behavior of buck to not only wait on `:bar` once one dependency of `:foo` has failed, but to additionally attempt to build other dependencies of `:foo` if possible. --keep-going If Buck hits an error, continue doing as much work as possible before exiting. See `--fail-fast` for more details. --skip-missing-targets If target is missing, then skip building instead of throwing error --skip-incompatible-targets If target is incompatible with the specified configuration, skip building instead of throwing error. This does not apply to targets specified with glob patterns `/...` or `:` which are skipped unconditionally --materialize-failed-inputs Materializes inputs for failed actions which ran on RE -o, --output &lt;PATH&gt; Output file path for profile data. File will be created if it does not exist, and overwritten if it does. --mode &lt;MODE&gt; Profile mode. Memory profiling modes have suffixes either `-allocated` or `-retained`. `-retained` means memory kept in frozen starlark heap after analysis complete. `-retained` does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis. `-allocated` means allocated memory, including memory which is later garbage collected. [possible values: time-flame, heap-flame-allocated, heap-flame-retained, heap-summary-allocated, heap-summary-retained, statement, bytecode, bytecode-pairs, typecheck, coverage] -h, --help Print help (see a summary with '-h') Target Configuration Options: -u, --target-universe &lt;TARGET_UNIVERSE&gt; Comma separated list of targets to construct a configured target universe. When the option is specified, command targets are be resolved in this universe. Additionally, `--target-platforms=` and `--modifier=` flags are be used to configure the universe targets, not the command targets. This argument is particularly recommended on most non-trivial cqueries. In the absence of this argument, buck2 will use the target literals in your cquery expression as the value for this argument, which may not be what you want. --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"root","type":0,"sectionRef":"#","url":"/docs/users/commands/root/","content":"","keywords":""},{"title":"buck root​","type":1,"pageTitle":"root","url":"/docs/users/commands/root/#buck-root","content":"Find buck cell, project or package root Usage: buck2-release root [OPTIONS] Options: -k, --kind &lt;KIND&gt; which root to print [default: cell] [possible values: package, cell, project, daemon] --dir &lt;PATH&gt; determine the root for a specific directory (if not provided, finds the root for the current directory) -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"query","type":0,"sectionRef":"#","url":"/docs/users/commands/query/","content":"","keywords":""},{"title":"buck query​","type":1,"pageTitle":"query","url":"/docs/users/commands/query/#buck-query","content":"Alias for `uquery` Usage: buck2-release query [OPTIONS] &lt;QUERY&gt; [QUERY_ARGS]... Arguments: &lt;QUERY&gt; the query to evaluate [QUERY_ARGS]... list of literals for a multi-query (one containing `%s` or `%Ss`) Options: -A, --output-all-attributes Output all attributes, equivalent of --output-attribute ''. Avoid using this flag in automation because it may be expensive to produce certain attributes, and because it makes harder to track which special attributes are used. -B, --output-basic-attributes Output basic attributes, namely those the user can supply, plus rule type and package name -a, --output-attribute &lt;ATTRIBUTE&gt; Regular expressions to match attributes. Regular expressions are used in &quot;search&quot; mode, so for example empty string matches all attributes including special attributes. When using in automation, please specify the regular expression to match the attribute precisely, for example `--output-attribute '^headers$'` to make it easier to track which special attributes are used. --output-attributes &lt;ATTRIBUTE&gt;... Deprecated: Use `--output-attribute` instead. List of space-separated attributes to output, --output-attributes attr1 attr2. --json Output in JSON format --dot Output in Graphviz Dot format --dot-compact Output in a more compact format than Graphviz Dot --output-format &lt;dot|dot_compact|json|starlark&gt; Output format (default: list). dot - dot graph format. dot_compact - compact alternative to dot format. json - JSON format. starlark - targets are printed like starlark code that would produce them. [possible values: dot, json, dot_compact, starlark] --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"server","type":0,"sectionRef":"#","url":"/docs/users/commands/server/","content":"","keywords":""},{"title":"buck server​","type":1,"pageTitle":"server","url":"/docs/users/commands/server/#buck-server","content":"Start, query, and control the http server Usage: buck2-release server [OPTIONS] Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"run","type":0,"sectionRef":"#","url":"/docs/users/commands/run/","content":"","keywords":""},{"title":"buck run​","type":1,"pageTitle":"run","url":"/docs/users/commands/run/#buck-run","content":"Build and run the selected target. The Build ID for the underlying build execution is made available to the target in the `BUCK_RUN_BUILD_ID` environment variable. Usage: buck2-release run [OPTIONS] &lt;TARGET&gt; [TARGET_ARGS]... Arguments: &lt;TARGET&gt; Target to build and run [TARGET_ARGS]... Additional arguments passed to the target when running it Options: --command-args-file &lt;COMMAND_ARGS_FILE&gt; Write the command to a file instead of executing it. --chdir &lt;CHDIR&gt; Set the current working directory of the executable being run --emit-shell Instead of running the command, print out the command formatted for shell interpolation, use as: $(buck2 run --emit-shell ...) --build-report &lt;PATH&gt; Print a build report `--build-report=-` will print the build report to stdout `--build-report=&lt;filepath&gt;` will write the build report to the file --enable-optional-validations &lt;VALIDATION_NAMES&gt; Comma separated list of validation names to run that are marked optional. By default, validations marked as optional are skipped. This option overrides the behaviour and executes those validations. --build-report-options &lt;BUILD_REPORT_OPTIONS&gt; Comma separated list of build report options. The following options are supported: `fill-out-failures`: fill out failures the same way Buck1 would. `package-project-relative-paths`: emit the project-relative path of packages for the targets that were built. -j, --num-threads &lt;THREADS&gt; Number of threads to use during execution (default is # cores) --local-only Enable only local execution. Will reject actions that cannot execute locally [env: BUCK_OFFLINE_BUILD=] --remote-only Enable only remote execution. Will reject actions that cannot execute remotely --prefer-local Enable hybrid execution. Will prefer executing actions that can execute locally on the local host --prefer-remote Enable hybrid execution. Will prefer executing actions that can execute remotely on RE and will avoid racing local and remote execution --unstable-no-execution Experimental: Disable all execution --no-remote-cache Do not perform remote cache queries or cache writes. If remote execution is enabled, the RE service might still deduplicate actions, so for e.g. benchmarking, using a random isolation dir is preferred [env: BUCK_OFFLINE_BUILD=] --write-to-cache-anyway Could be used to enable the action cache writes on the RE worker when no_remote_cache is specified --eager-dep-files Process dep files when they are generated (i.e. after running a command that produces dep files), rather than when they are used (i.e. before re-running a command that previously produced dep files). Use this when debugging commands that produce dep files. Note that commands that previously produced dep files will not re-run: only dep files produced during this command will be eagerly loaded --upload-all-actions Uploads every action to the RE service, regardless of whether the action needs to execute on RE. This is useful when debugging builds and trying to inspect actions which executed remotely. It's possible that the action result is cached but the action itself has expired. In this case, downloading the action itself would fail. Enabling this option would unconditionally upload all actions, thus you will not hit any expiration issues. --fail-fast If Buck hits an error, do as little work as possible before exiting. To illustrate the effect of this flag, consider an invocation of `build :foo :bar`. The default behavior of buck is to do enough work to get a result for the builds of each of `:foo` and `:bar`, and no more. This means that buck will continue to complete the build of `:bar` after the build of `:foo` has failed; however, once one dependency of `:foo` has failed, other dependencies will be cancelled unless they are needed by `:bar`. This flag changes the behavior of buck to not wait on `:bar` to complete once `:foo` has failed. Generally, this flag only has an effect on builds that specify multiple targets. `--keep-going` changes the behavior of buck to not only wait on `:bar` once one dependency of `:foo` has failed, but to additionally attempt to build other dependencies of `:foo` if possible. --keep-going If Buck hits an error, continue doing as much work as possible before exiting. See `--fail-fast` for more details. --skip-missing-targets If target is missing, then skip building instead of throwing error --skip-incompatible-targets If target is incompatible with the specified configuration, skip building instead of throwing error. This does not apply to targets specified with glob patterns `/...` or `:` which are skipped unconditionally --materialize-failed-inputs Materializes inputs for failed actions which ran on RE -h, --help Print help (see a summary with '-h') Target Configuration Options: --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"status","type":0,"sectionRef":"#","url":"/docs/users/commands/status/","content":"","keywords":""},{"title":"buck status​","type":1,"pageTitle":"status","url":"/docs/users/commands/status/#buck-status","content":"Buckd status Usage: buck2-release status [OPTIONS] Options: --snapshot Whether to include a state snapshot in the output. --all Enable printing status for all running buckd -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"subscribe","type":0,"sectionRef":"#","url":"/docs/users/commands/subscribe/","content":"","keywords":""},{"title":"buck subscribe​","type":1,"pageTitle":"subscribe","url":"/docs/users/commands/subscribe/#buck-subscribe","content":"Open a subscription channel to the Buck2 daemon. This allows you to interact with the Buck2 daemon via the `stdin` and `stdout` of this command: you send requests to the daemon by writing to `stdin`, and you get responses via `stdout`. The protocol used by this command is length-prefixed protobuf. This format is a repeated series of a varint followed by a record of the length indicated by said varint. The protobuf spec for those records is described in `buck2_subscription_proto/subscription.proto`. The client writes `SubscriptionRequest` and reads `SubscriptionResponse`. See the documentation in `subscription.proto` to discover available APIs. This API does not (currently) allow invalid requests and will error out when one is sent. Usage: buck2-release subscribe [OPTIONS] Options: --active-commands Whether to request command snapshots --unstable-json Whether to get output as JSON. The JSON format is deemed unstable so this should only be used for debugging -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"starlark","type":0,"sectionRef":"#","url":"/docs/users/commands/starlark/","content":"","keywords":""},{"title":"buck starlark​","type":1,"pageTitle":"starlark","url":"/docs/users/commands/starlark/#buck-starlark","content":"Run Starlark operations Usage: buck2-release starlark [OPTIONS] &lt;COMMAND&gt; Commands: lint Run the Starlark linter. typecheck Run the Starlark typechecker. debug-attach Run the starlark debug adapter protocol server help Print this message or the help of the given subcommand(s) Options: -h, --help Print help (see a summary with '-h') Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck starlark lint​","type":1,"pageTitle":"starlark","url":"/docs/users/commands/starlark/#buck-starlark-lint","content":"Run the Starlark linter. Usage: buck2-release starlark lint [OPTIONS] &lt;PATH&gt;... Options: -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format &lt;PATH&gt;... Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck starlark typecheck​","type":1,"pageTitle":"starlark","url":"/docs/users/commands/starlark/#buck-starlark-typecheck","content":"Run the Starlark typechecker. Usage: buck2-release starlark typecheck [OPTIONS] &lt;PATH&gt;... Options: -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format &lt;PATH&gt;... Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"buck starlark debug-attach​","type":1,"pageTitle":"starlark","url":"/docs/users/commands/starlark/#buck-starlark-debug-attach","content":"Run the starlark debug adapter protocol server This forwards requests received on stdin to a debug server running in the buck daemon. DAP events and responses are returned from the daemon and sent to this command's stdout. Usage: buck2-release starlark debug-attach [OPTIONS] Options: -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"targets","type":0,"sectionRef":"#","url":"/docs/users/commands/targets/","content":"","keywords":""},{"title":"buck targets​","type":1,"pageTitle":"targets","url":"/docs/users/commands/targets/#buck-targets","content":"Alias for `utargets` Usage: buck2-release targets [OPTIONS] [TARGET_PATTERNS]... Arguments: [TARGET_PATTERNS]... Patterns to interpret Options: --json Print targets as JSON --json-lines Print targets as JSON-lines --stats Print statistics of how many entries were processed --resolve-alias Print the fully-qualified build target for the specified aliases --show-target-hash Print a stable hash of each target after the target name --show-unconfigured-target-hash Print a stable unconfigured hash of each target after the target name --target-hash-file-mode &lt;TARGET_HASH_FILE_MODE&gt; Modifies computation of target hashes. If set to `PATHS_AND_CONTENTS` (the default), the contents of all files referenced from the targets will be used to compute the target hash. If set to `PATHS_ONLY`, only files' paths contribute to the hash. If set to `NONE` no files will be used. See also --target-hash-modified-paths [default: paths_and_contents] [possible values: paths_only, paths_and_contents, none] --target-hash-modified-paths &lt;TARGET_HASH_MODIFIED_PATHS&gt;... Modifies computation of target hashes. Only effective when --target-hash-file-mode is set to `PATHS_ONLY`. If a target or its dependencies reference a file from this set, the target's hash will be different than if this option was omitted. Otherwise, the target's hash will be the same as if this option was omitted --target-hash-function &lt;TARGET_HASH_FUNCTION&gt; Selects either the &quot;fast&quot; or the &quot;strong&quot; target hash function to be used for computing target hashes. While we don't specify the exact algorithm, the &quot;strong&quot; algorithm should be a reasonable cryptographic hash (ex. blake3) while the &quot;fast&quot; function will likely be a non-crypto hash. Both functions are guaranteed to be deterministic and to have the same value across different platforms/architectures [default: fast] [possible values: sha1, sha256, murmur-hash3, fast, strong] --target-hash-recursive &lt;TARGET_HASH_RECURSIVE&gt; When true, emit the hash or target node and all dependencies recursively. When false, hash only the target node [default: true] [possible values: true, false] -A, --output-all-attributes Output all attributes, equivalent of --output-attribute ''. Avoid using this flag in automation because it may be expensive to produce certain attributes, and because it makes harder to track which special attributes are used. -B, --output-basic-attributes Output basic attributes, namely those the user can supply, plus rule type and package name -a, --output-attribute &lt;ATTRIBUTE&gt; Regular expressions to match attributes. Regular expressions are used in &quot;search&quot; mode, so for example empty string matches all attributes including special attributes. When using in automation, please specify the regular expression to match the attribute precisely, for example `--output-attribute '^headers$'` to make it easier to track which special attributes are used. --output-attributes &lt;ATTRIBUTE&gt;... Deprecated: Use `--output-attribute` instead. List of space-separated attributes to output, --output-attributes attr1 attr2. --include-defaults Enables printing of default attributes. This would be attributes in a target that aren't explicitly set in the target but instead use the default set in the rule declaration --show-output Print the path to the output for each of the rules relative to the project root --show-full-output Print the absolute path to the output for each of the rules --show-simple-output Print only the path to the output for each of the rules relative to the project root --show-full-simple-output Print only the absolute path to the output for each of the rules --show-json-output Print the output paths relative to the project root, in JSON format --show-full-json-output Print the output absolute paths, in JSON format --keep-going On loading errors, put buck.error in the output stream and continue --streaming Write output as soon as it is available. The order of the output items is non-deterministic and if multiple patterns cover the same target, may have duplicates --no-cache Don't cache the target information on the build graph --imports Show the imports of each package/import. Shows an additional output per package/import (not per target), including implicit dependencies (e.g. the prelude) but only direct dependencies (not the transitive closure) --package-values Show the package values. Produces an additional attribute representing all the package values for the package containing the target --package-values-regex &lt;VALUES&gt; Regular expressions to match package values. Produces an additional attribute representing package values for the package containing the target. Regular expressions are used in &quot;search&quot; mode so, for example, empty string matches all package values -o, --output &lt;PATH&gt; File to put the output in, rather than sending to stdout. File will be created if it does not exist, and overwritten if it does. --compression &lt;SCHEME&gt; Compress the output [default: none] [possible values: none, gzip, zstd] -j, --num-threads &lt;THREADS&gt; Number of threads to use during execution (default is # cores) -h, --help Print help (see a summary with '-h') Target Configuration Options: --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"test","type":0,"sectionRef":"#","url":"/docs/users/commands/test/","content":"","keywords":""},{"title":"buck test​","type":1,"pageTitle":"test","url":"/docs/users/commands/test/#buck-test","content":"Build and test the specified targets Usage: buck2-release test [OPTIONS] [TARGET_PATTERNS]... [-- &lt;TEST_EXECUTOR_ARGS&gt;...] Arguments: [TARGET_PATTERNS]... Patterns to test [TEST_EXECUTOR_ARGS]... Additional arguments passed to the test executor. Test executor is expected to have `--env` flag to pass environment variables. Can be used like this: buck2 test //foo:bar -- --env PRIVATE_KEY=123 Options: --exclude &lt;EXCLUDE&gt;... Labels on targets to exclude from tests --include &lt;INCLUDE&gt;... Labels on targets to include from tests. Prefixing with `!` means to exclude. First match wins unless overridden by `always-exclude` flag. If include patterns are present, regardless of whether exclude patterns are present, then all targets are by default excluded unless explicitly included. --always-exclude Whether to always exclude if the label appears in `exclude`, regardless of which appears first --build-filtered Whether to build tests that are excluded via labels. --unstable-allow-compatible-tests-on-re Will allow tests that are compatible with RE (setup to run from the repo root and use relative paths) to run from RE --unstable-allow-all-tests-on-re Will run tests to on RE even if they are missing required settings (running from the root + relative paths). Those required settings just get overridden --overall-timeout &lt;TIMEOUT&gt; How long to execute tests for. If the timeout is exceeded, Buck2 will exit as quickly as possible and not run further tests. In-flight tests will be cancelled. The test orchestrator will be allowed to shut down gracefully. The exit code is controlled by the test orchestrator (which normally should report zero for this). The format is a concatenation of time spans (separated by spaces). Each time span is an integer number and a suffix. Relevant supported suffixes: seconds, second, sec, s, minutes, minute, min, m, hours, hour, hr, h For example: `5m 10s`, `500s`. --test-executor-stdout &lt;TEST_EXECUTOR_STDOUT&gt; Writes the test executor stdout to the provided path --test-executor-stdout=- will write to stdout --test-executor-stdout=FILEPATH will write to the provided filepath, overwriting the current file if it exists By default the test executor's stdout stream is captured --ignore-tests-attribute Normally testing will follow the `tests` attribute of all targets, to find their associated tests. When passed, this flag will disable that, and only run the directly supplied targets --test-executor-stderr &lt;TEST_EXECUTOR_STDERR&gt; Writes the test executor stderr to the provided path --test-executor-stderr=- will write to stderr --test-executor-stderr=FILEPATH will write to the provided filepath, overwriting the current file if it exists By default test executor's stderr stream is captured --build-report &lt;PATH&gt; Print a build report `--build-report=-` will print the build report to stdout `--build-report=&lt;filepath&gt;` will write the build report to the file --enable-optional-validations &lt;VALIDATION_NAMES&gt; Comma separated list of validation names to run that are marked optional. By default, validations marked as optional are skipped. This option overrides the behaviour and executes those validations. --build-report-options &lt;BUILD_REPORT_OPTIONS&gt; Comma separated list of build report options. The following options are supported: `fill-out-failures`: fill out failures the same way Buck1 would. `package-project-relative-paths`: emit the project-relative path of packages for the targets that were built. -j, --num-threads &lt;THREADS&gt; Number of threads to use during execution (default is # cores) --local-only Enable only local execution. Will reject actions that cannot execute locally [env: BUCK_OFFLINE_BUILD=] --remote-only Enable only remote execution. Will reject actions that cannot execute remotely --prefer-local Enable hybrid execution. Will prefer executing actions that can execute locally on the local host --prefer-remote Enable hybrid execution. Will prefer executing actions that can execute remotely on RE and will avoid racing local and remote execution --unstable-no-execution Experimental: Disable all execution --no-remote-cache Do not perform remote cache queries or cache writes. If remote execution is enabled, the RE service might still deduplicate actions, so for e.g. benchmarking, using a random isolation dir is preferred [env: BUCK_OFFLINE_BUILD=] --write-to-cache-anyway Could be used to enable the action cache writes on the RE worker when no_remote_cache is specified --eager-dep-files Process dep files when they are generated (i.e. after running a command that produces dep files), rather than when they are used (i.e. before re-running a command that previously produced dep files). Use this when debugging commands that produce dep files. Note that commands that previously produced dep files will not re-run: only dep files produced during this command will be eagerly loaded --upload-all-actions Uploads every action to the RE service, regardless of whether the action needs to execute on RE. This is useful when debugging builds and trying to inspect actions which executed remotely. It's possible that the action result is cached but the action itself has expired. In this case, downloading the action itself would fail. Enabling this option would unconditionally upload all actions, thus you will not hit any expiration issues. --fail-fast If Buck hits an error, do as little work as possible before exiting. To illustrate the effect of this flag, consider an invocation of `build :foo :bar`. The default behavior of buck is to do enough work to get a result for the builds of each of `:foo` and `:bar`, and no more. This means that buck will continue to complete the build of `:bar` after the build of `:foo` has failed; however, once one dependency of `:foo` has failed, other dependencies will be cancelled unless they are needed by `:bar`. This flag changes the behavior of buck to not wait on `:bar` to complete once `:foo` has failed. Generally, this flag only has an effect on builds that specify multiple targets. `--keep-going` changes the behavior of buck to not only wait on `:bar` once one dependency of `:foo` has failed, but to additionally attempt to build other dependencies of `:foo` if possible. --keep-going If Buck hits an error, continue doing as much work as possible before exiting. See `--fail-fast` for more details. --skip-missing-targets If target is missing, then skip building instead of throwing error --skip-incompatible-targets If target is incompatible with the specified configuration, skip building instead of throwing error. This does not apply to targets specified with glob patterns `/...` or `:` which are skipped unconditionally --materialize-failed-inputs Materializes inputs for failed actions which ran on RE -h, --help Print help (see a summary with '-h') Target Configuration Options: --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"uquery","type":0,"sectionRef":"#","url":"/docs/users/commands/uquery/","content":"","keywords":""},{"title":"buck uquery​","type":1,"pageTitle":"uquery","url":"/docs/users/commands/uquery/#buck-uquery","content":"Perform queries on the unconfigured target graph The unconfigured target graph consists of the targets as they are defined in the build files. In this graph, each target appears exactly once and `select()`s are in the unresolved form. For large queries, the unconfigured graph may be much smaller than the configured graph and queries can be much more efficiently performed there. When querying the unconfigured graph, dependencies appearing in all branches of `select()` dictionaries will be treated as dependencies. Run `buck2 docs uquery` or https://buck2.build/docs/users/query/uquery/ for more documentation about the functions available in uquery expressions. Examples: Print all the attributes of a target `buck2 uquery //java/com/example/app:amazing --output-all-attributes List the deps of a target (special characters in a target will require quotes): `buck2 uquery 'deps(&quot;//java/com/example/app:amazing+more&quot;)'` select() encoding: When printed, values with `select()`s use a special json encoding. `1 + select({&quot;//:a&quot;: 1, &quot;DEFAULT&quot;: 2})` will be encoded as: `{&quot;__type&quot;: &quot;concat&quot;, &quot;items&quot;: [1, {&quot;__type&quot;: &quot;selector&quot;, &quot;entries&quot;: {&quot;//:a&quot;: 1, &quot;DEFAULT&quot;: 2}}]}` Usage: buck2-release uquery [OPTIONS] &lt;QUERY&gt; [QUERY_ARGS]... Arguments: &lt;QUERY&gt; the query to evaluate [QUERY_ARGS]... list of literals for a multi-query (one containing `%s` or `%Ss`) Options: -A, --output-all-attributes Output all attributes, equivalent of --output-attribute ''. Avoid using this flag in automation because it may be expensive to produce certain attributes, and because it makes harder to track which special attributes are used. -B, --output-basic-attributes Output basic attributes, namely those the user can supply, plus rule type and package name -a, --output-attribute &lt;ATTRIBUTE&gt; Regular expressions to match attributes. Regular expressions are used in &quot;search&quot; mode, so for example empty string matches all attributes including special attributes. When using in automation, please specify the regular expression to match the attribute precisely, for example `--output-attribute '^headers$'` to make it easier to track which special attributes are used. --output-attributes &lt;ATTRIBUTE&gt;... Deprecated: Use `--output-attribute` instead. List of space-separated attributes to output, --output-attributes attr1 attr2. --json Output in JSON format --dot Output in Graphviz Dot format --dot-compact Output in a more compact format than Graphviz Dot --output-format &lt;dot|dot_compact|json|starlark&gt; Output format (default: list). dot - dot graph format. dot_compact - compact alternative to dot format. json - JSON format. starlark - targets are printed like starlark code that would produce them. [possible values: dot, json, dot_compact, starlark] --modifier &lt;VALUE&gt; This option is not used -h, --help Print help (see a summary with '-h') Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"Why is Buck2 hanging?","type":0,"sectionRef":"#","url":"/docs/users/faq/buck_hanging/","content":"","keywords":""},{"title":"How to debug a “busy” hang​","type":1,"pageTitle":"Why is Buck2 hanging?","url":"/docs/users/faq/buck_hanging/#how-to-debug-a-busy-hang","content":""},{"title":"Getting a stack trace​","type":1,"pageTitle":"Why is Buck2 hanging?","url":"/docs/users/faq/buck_hanging/#getting-a-stack-trace","content":"When debugging a busy hang, the first thing to do is to work out what the process is doing. There are many tools you can use for this (like a profiler), but the absolute simplest one is quickstack: just run quickstack -p $PID, and it’ll show you a stack dump for all the threads in your process. If you prefergdb, you can use gdb -p $PID, then thread apply all bt, and that’s the same thing. Note that a stack trace tells you what the process is doing at a point in time, so don’t just look at the very last frame and call it the culprit. Instead, look at the stack as a whole. If you need more perspective, use a sampling profiler . You can also just grab stack traces at a few points in time and see if they look similar: this is exactly what a sampling profiler does, albeit at a higher frequency. "},{"title":"Interpreting the stack trace​","type":1,"pageTitle":"Why is Buck2 hanging?","url":"/docs/users/faq/buck_hanging/#interpreting-the-stack-trace","content":"Let's consider an example user report with the following stack trace: #01 0x0000000005b1ec26 in &lt;buck2_build_api::artifact_groups::artifact_group_values::TransitiveSetIterator&lt;buck2_build_api::artifact_groups::artifact_group_values::ArtifactGroupValues, (buck2_build_api::actions::artifact::Artifact, buck2_execute::artifact_value::ArtifactValue), buck2_build_api::artifact_groups::artifact_group_values::ArtifactValueIdentity&gt; as core::iter::traits::iterator::Iterator&gt;::next () from ... #02 0x0000000005b23998 in &lt;buck2_build_api::artifact_groups::artifact_group_values::TransitiveSetIterator&lt;buck2_build_api::artifact_groups::artifact_group_values::ArtifactGroupValues, (buck2_build_api::actions::artifact::Artifact, buck2_execute::artifact_value::ArtifactValue), buck2_build_api::artifact_groups::artifact_group_values::ArtifactValueIdentity&gt; as itertools::Itertools&gt;::exactly_one () from ... #03 0x00000000059dbb2c in buck2_server_commands::commands::build::create_unhashed_outputs () from ... #04 0x0000000005c3c677 in &lt;core::future::from_generator::GenFuture&lt;&lt;buck2_server_commands::commands::build::BuildServerCommand as buck2_server_ctx::template::ServerCommandTemplate&gt;::command::{closure#0}&gt; as core::future::future::Future&gt;::poll () from ... #05 0x00000000054c58a3 in &lt;core::future::from_generator::GenFuture&lt;&lt;alloc::boxed::Box&lt;dyn buck2_server_ctx::ctx::ServerCommandContextTrait&gt; as buck2_server_ctx::ctx::ServerCommandDiceContext&gt;::with_dice_ctx&lt;buck2_server_ctx::template::run_server_command&lt;buck2_server_commands::commands::build::BuildServerCommand&gt;::{closure#0}::{closure#0}::{closure#0}, core::pin::Pin&lt;alloc::boxed::Box&lt;dyn core::future::future::Future&lt;Output = core::result::Result&lt;cli_proto::BuildResponse, anyhow::Error&gt;&gt; + core::marker::Send&gt;&gt;, cli_proto::BuildResponse&gt;::{closure#0}&gt; as core::future::future::Future&gt;::poll () from ... #06 0x00000000054c7ae3 in &lt;core::future::from_generator::GenFuture&lt;buck2_server_ctx::template::run_server_command&lt;buck2_server_commands::commands::build::BuildServerCommand&gt;::{closure#0}::{closure#0}&gt; as core::future::future::Future&gt;::poll () from ... #07 0x0000000005370df8 in &lt;buck2_events::dispatch::Span&gt;::call_in_span::&lt;core::task::poll::Poll&lt;(core::result::Result&lt;cli_proto::BuildResponse, anyhow::Error&gt;, buck2_data::CommandEnd)&gt;, &lt;buck2_events::dispatch::EventDispatcher&gt;::span_async&lt;buck2_data::CommandStart, buck2_data::CommandEnd, core::future::from_generator::GenFuture&lt;buck2_server_ctx::template::run_server_command&lt;buck2_server_commands::commands::build::BuildServerCommand&gt;::{closure#0}::{closure#0}&gt;, core::result::Result&lt;cli_proto::BuildResponse, anyhow::Error&gt;&gt;::{closure#0}::{closure#0}::{closure#0}&gt; () from ... #08 0x00000000054f7288 in &lt;core::future::from_generator::GenFuture&lt;&lt;cli::commands::daemon::BuckdServerDependenciesImpl as buck2_server::daemon::server::BuckdServerDependencies&gt;::build::{closure#0}&gt; as core::future::future::Future&gt;::poll () from... ...  At this point, you can look at the code, and note that there is no span around the output symlink creation function (create_unhashed_outputs). This suggests you’ve found your culprit: there is indeed a buck2 bug and we’re spending ages creating unhashed output symlinks, and since you need a span to get any console feedback, the console says nothing is happening. An easy fix: In this particular instance, Thomas spottedan easy optimizationwhich resolved the issue. But, of course, that’s not always possible. If the easy fix hadn't been available, we’d be at a dead end, so what do we do next? A harder fix: If it is not clear what the root-cause is, you can bisect: i.e. do a binary search across commits for the commit that introduced a given breakage/perf degradation. Then, once you identify their commit that caused breakage, investigate what caused the issue. "},{"title":"How to debug a “doing nothing” hang​","type":1,"pageTitle":"Why is Buck2 hanging?","url":"/docs/users/faq/buck_hanging/#how-to-debug-a-doing-nothing-hang","content":"Cycle in dependencies: If buck2 seems to be doing nothing (e.g. CPU usage is 0%), one of the reasons could be a cycle in your dependencies, which may cause buck2 to hang (buck2 does implement a form of cycle detection, but it unfortunately has false negatives). You can confirm this by running buck1, which will report cycles properly. "},{"title":"Common Issues","type":0,"sectionRef":"#","url":"/docs/users/faq/common_issues/","content":"","keywords":""},{"title":"Why is stdin being swallowed?​","type":1,"pageTitle":"Common Issues","url":"/docs/users/faq/common_issues/#why-is-stdin-being-swallowed","content":"Buck2 offers an interactive console by default. To disable either use an env var: BUCK_NO_INTERACTIVE_CONSOLE or a flag:--no-interactive-console "},{"title":"Where is my output file?​","type":1,"pageTitle":"Common Issues","url":"/docs/users/faq/common_issues/#where-is-my-output-file","content":"To find the location of output for a target, usebuck2 build //foo:bar --show-output. This will print the output corresponding to each built target, in this case //foo:bar output_path. To only get the output path (without the target beforehand) you want to usebuck2 build //foo:bar --show-simple-output. The resultant path is relative to the root of the repo (such as~/repo_root/...). For the full path use --show-full-output or--show-full-simple-output. Note: in Buck1, the path is relative to the enclosing cell (such as~/repo_root/cell/...). "},{"title":"Why is Buck2 hanging?​","type":1,"pageTitle":"Common Issues","url":"/docs/users/faq/common_issues/#why-is-buck2-hanging","content":"If Buck2 seems to be doing nothing, it could be caused be a cycle in your dependencies, which may cause Buck2 to hang (Buck2 does implement a form of cycle detection, but it unfortunately has false negatives). You can confirm this by running Buck1, which will report cycles properly. "},{"title":"How do I get the commands Buck2 executed so I can reproduce them in isolation?​","type":1,"pageTitle":"Common Issues","url":"/docs/users/faq/common_issues/#how-do-i-get-the-commands-buck2-executed-so-i-can-reproduce-them-in-isolation","content":"For information, seeFinding Commands that Buck2 Ran. "},{"title":"Are multiple concurrent commands supported?​","type":1,"pageTitle":"Common Issues","url":"/docs/users/faq/common_issues/#are-multiple-concurrent-commands-supported","content":"Yes, they are supported. There are 2 types of concurrent commands: 1) parallel invocations, and 2) recursive invocations. Parallel invocations: If the state of all the commands are the same, then they will run at the same time. &quot;State&quot; is referring to the same configs and source files. If the state is different amongst the commands, then buck2 will block the commands properly such that the states do not interfere with each other. Different states are caused by source file changes or config changes (ex: using a different mode). Recursive invocations: A recursive invocation is when an outer buck2 command ends up calling another buck2 command as it's running. Recursive invocations are most commonly seen with genrules and tests. For example: If you have a genrule where the command contains a buck2 cquery, and you build the genrule with buck2 build, you have a recursive invocation where the outer command is buck2 build and the inner command is buck2 cqueryIf you have a test which contains buck2 build, and you run your test withbuck2 test, you have a recursive invocation where the outer command isbuck2 test and the inner command is buck2 build Recursive invocations should specify an --isolation-dir, or else buck2 will return an error. "},{"title":"Why did my build OOM?​","type":1,"pageTitle":"Common Issues","url":"/docs/users/faq/common_issues/#why-did-my-build-oom","content":"If your build OOMs, you can check the last actions running by usingbuck2 log whatup. This will print the superconsole state at the moment the event log ended, which will indicate what actions were being run (and consuming memory) when your machine ran out of memory. You can also use the --after &lt;millis&gt; option to see all open spans at a certain point in time of the build. "},{"title":"Why does my target not have any outputs?​","type":1,"pageTitle":"Common Issues","url":"/docs/users/faq/common_issues/#why-does-my-target-not-have-any-outputs","content":"If you see that your build succeeded, but the console message stated that your target did not have any outputs, this means that the underlying rule did not declare any outputs artifacts, defined as outputs declared in: default_outputs and/or other_outputs in DefaultInfocmd_args in RunInfocmd_args inside the command in ExternalRunnerTestInfo For example, building a target which uses a python_library rule merely groups source files together and does not generate any output artifacts such as a python executable. You would need to build a python_binary which uses that library in order to get an output. "},{"title":"utargets","type":0,"sectionRef":"#","url":"/docs/users/commands/utargets/","content":"","keywords":""},{"title":"buck utargets​","type":1,"pageTitle":"utargets","url":"/docs/users/commands/utargets/#buck-utargets","content":"Show details about the specified targets. This command is meant to only handle unconfigured targets, but for historical reasons, with certain flags it can also work with configured targets. Usage: buck2-release utargets [OPTIONS] [TARGET_PATTERNS]... Arguments: [TARGET_PATTERNS]... Patterns to interpret Options: --json Print targets as JSON --json-lines Print targets as JSON-lines --stats Print statistics of how many entries were processed --resolve-alias Print the fully-qualified build target for the specified aliases --show-target-hash Print a stable hash of each target after the target name --show-unconfigured-target-hash Print a stable unconfigured hash of each target after the target name --target-hash-file-mode &lt;TARGET_HASH_FILE_MODE&gt; Modifies computation of target hashes. If set to `PATHS_AND_CONTENTS` (the default), the contents of all files referenced from the targets will be used to compute the target hash. If set to `PATHS_ONLY`, only files' paths contribute to the hash. If set to `NONE` no files will be used. See also --target-hash-modified-paths [default: paths_and_contents] [possible values: paths_only, paths_and_contents, none] --target-hash-modified-paths &lt;TARGET_HASH_MODIFIED_PATHS&gt;... Modifies computation of target hashes. Only effective when --target-hash-file-mode is set to `PATHS_ONLY`. If a target or its dependencies reference a file from this set, the target's hash will be different than if this option was omitted. Otherwise, the target's hash will be the same as if this option was omitted --target-hash-function &lt;TARGET_HASH_FUNCTION&gt; Selects either the &quot;fast&quot; or the &quot;strong&quot; target hash function to be used for computing target hashes. While we don't specify the exact algorithm, the &quot;strong&quot; algorithm should be a reasonable cryptographic hash (ex. blake3) while the &quot;fast&quot; function will likely be a non-crypto hash. Both functions are guaranteed to be deterministic and to have the same value across different platforms/architectures [default: fast] [possible values: sha1, sha256, murmur-hash3, fast, strong] --target-hash-recursive &lt;TARGET_HASH_RECURSIVE&gt; When true, emit the hash or target node and all dependencies recursively. When false, hash only the target node [default: true] [possible values: true, false] -A, --output-all-attributes Output all attributes, equivalent of --output-attribute ''. Avoid using this flag in automation because it may be expensive to produce certain attributes, and because it makes harder to track which special attributes are used. -B, --output-basic-attributes Output basic attributes, namely those the user can supply, plus rule type and package name -a, --output-attribute &lt;ATTRIBUTE&gt; Regular expressions to match attributes. Regular expressions are used in &quot;search&quot; mode, so for example empty string matches all attributes including special attributes. When using in automation, please specify the regular expression to match the attribute precisely, for example `--output-attribute '^headers$'` to make it easier to track which special attributes are used. --output-attributes &lt;ATTRIBUTE&gt;... Deprecated: Use `--output-attribute` instead. List of space-separated attributes to output, --output-attributes attr1 attr2. --include-defaults Enables printing of default attributes. This would be attributes in a target that aren't explicitly set in the target but instead use the default set in the rule declaration --show-output Print the path to the output for each of the rules relative to the project root --show-full-output Print the absolute path to the output for each of the rules --show-simple-output Print only the path to the output for each of the rules relative to the project root --show-full-simple-output Print only the absolute path to the output for each of the rules --show-json-output Print the output paths relative to the project root, in JSON format --show-full-json-output Print the output absolute paths, in JSON format --keep-going On loading errors, put buck.error in the output stream and continue --streaming Write output as soon as it is available. The order of the output items is non-deterministic and if multiple patterns cover the same target, may have duplicates --no-cache Don't cache the target information on the build graph --imports Show the imports of each package/import. Shows an additional output per package/import (not per target), including implicit dependencies (e.g. the prelude) but only direct dependencies (not the transitive closure) --package-values Show the package values. Produces an additional attribute representing all the package values for the package containing the target --package-values-regex &lt;VALUES&gt; Regular expressions to match package values. Produces an additional attribute representing package values for the package containing the target. Regular expressions are used in &quot;search&quot; mode so, for example, empty string matches all package values -o, --output &lt;PATH&gt; File to put the output in, rather than sending to stdout. File will be created if it does not exist, and overwritten if it does. --compression &lt;SCHEME&gt; Compress the output [default: none] [possible values: none, gzip, zstd] -j, --num-threads &lt;THREADS&gt; Number of threads to use during execution (default is # cores) -h, --help Print help (see a summary with '-h') Target Configuration Options: --target-platforms &lt;PLATFORM&gt; Configuration target (one) to use to configure targets -m, --modifier &lt;VALUE&gt; A configuration modifier to configure all targets on the command line. This may be a constraint value target. Buckconfig Options: -c, --config &lt;SECTION.OPTION=VALUE&gt; List of config options --config-file &lt;PATH&gt; List of config file paths --fake-host &lt;HOST&gt; [possible values: default, linux, macos, windows] --fake-arch &lt;ARCH&gt; [possible values: default, aarch64, x8664] --fake-xcode-version &lt;VERSION-BUILD&gt; Value must be formatted as: version-build (e.g., 14.3.0-14C18 or 14.1-14B47b) --reuse-current-config Re-uses any `--config` values (inline or via modefiles) if there's a previous command, otherwise the flag is ignored. If there is a previous command and `--reuse-current-config` is set, then the old config is used, ignoring any overrides. If there is no previous command but the flag was set, then the flag is ignored, the command behaves as if the flag was not set at all. --exit-when-different-state Used for exiting a concurrent command when a different state is detected --preemptible &lt;PREEMPTIBLE&gt; Used to configure when this command could be preempted by another command for the same isolation dir. Normally, when you run two commands - from different terminals, say - buck2 will attempt to run them in parallel. However, if the two commands are based on different state, that is they either have different configs or different filesystem states, buck2 cannot run them in parallel. The default behavior in this case is to block the second command until the first completes. Possible values: - never: (default) When another command starts that cannot run in parallel with this one, block that command - always: When another command starts, interrupt this command, *even if they could run in parallel*. There is no good reason to use this other than that it provides slightly nicer superconsole output - ondifferentstate: When another command starts that cannot run in parallel with this one, interrupt this command Starlark Options: --disable-starlark-types Disable runtime type checking in Starlark interpreter. This option is not stable, and can be used only locally to diagnose evaluation performance problems. --stack Record or show target call stacks. Starlark call stacks will be included in duplicate targets error. If a command outputs targets (like `targets` command), starlark call stacks will be printed after the targets. Console Options: --console &lt;super|simple|...&gt; Which console to use for this command [env: BUCK_CONSOLE=] [default: auto] [possible values: simple, simplenotty, simpletty, super, auto, none] --ui &lt;UI&gt;... Configure additional superconsole ui components. Accepts a comma-separated list of superconsole components to add. Possible values are: dice - shows information about evaluated dice nodes debugevents - shows information about the flow of events from buckd These components can be turned on/off interactively. Press 'h' for help when superconsole is active. Possible values: - dice - debugevents - io: I/O panel - re: RE panel --no-interactive-console Disable console interactions [env: BUCK_NO_INTERACTIVE_CONSOLE=] Event Log Options: --event-log &lt;PATH&gt; Write events to this log file --write-build-id &lt;PATH&gt; Write command invocation id into this file --unstable-write-invocation-record &lt;PATH&gt; Write the invocation record (as JSON) to this path. No guarantees whatsoever are made regarding the stability of the format Universal Options: -v, --verbose &lt;VERBOSITY&gt; How verbose buck should be while logging. Values: 0 = Quiet, errors only; 1 = Show status. Default; 2 = more info about errors; 3 = more info about everything; 4 = more info about everything + stderr; It can be combined with specific log items (stderr, full_failed_command, commands, actions, status, stats, success) to fine-tune the verbosity of the log. Example usage &quot;-v=1,stderr&quot; [default: 1] --oncall &lt;ONCALL&gt; The oncall executing this command --client-metadata &lt;CLIENT_METADATA&gt; Metadata key-value pairs to inject into Buck2's logging. Client metadata must be of the form `key=value`, where `key` is a snake_case identifier, and will be sent to backend datasets  "},{"title":"Debugging Excess Starlark Peak Memory","type":0,"sectionRef":"#","url":"/docs/users/faq/starlark_peak_mem/","content":"","keywords":""},{"title":"Wut memory?​","type":1,"pageTitle":"Debugging Excess Starlark Peak Memory","url":"/docs/users/faq/starlark_peak_mem/#wut-memory","content":"Peak memory is the maximum amount of memory used during evaluation of that particular Starlark file. The memory is usually released after we finish the evaluation of the file. Because Starlark is only garbage collected in between top-level statements in the BUCK file, but not garbage collected inside function calls/macros, on large servers with 64 hardware threads (or more), memory usage might accumulate, causing slowdowns or OOMs . To prevent such issues until proper GC is implemented, we have set a hard 2GBmemory limit for Starlark's evaluation of build files. This is a per-file limit. Note that this is different than the actual process memory which might include other things apart from Starlark’s evaluation. "},{"title":"How do I see my build file's peak memory usage?​","type":1,"pageTitle":"Debugging Excess Starlark Peak Memory","url":"/docs/users/faq/starlark_peak_mem/#how-do-i-see-my-build-files-peak-memory-usage","content":"To see the Starlark peak memory usage of a build file, you can inspect the event log for your build file. Here is an example entry from the event log for buck2 uquery target showing that it uses 1.5GB: {&quot;Event&quot;:{...&quot;data&quot;:{&quot;Load&quot;:{&quot;module_id&quot;:&quot;target:BUCK&quot;,&quot;cell&quot;:&quot;...&quot;,&quot;error&quot;:null,&quot;starlark_peak_allocated_bytes&quot;:1610608640}}}}}}  "},{"title":"Profiler to the rescue!​","type":1,"pageTitle":"Debugging Excess Starlark Peak Memory","url":"/docs/users/faq/starlark_peak_mem/#profiler-to-the-rescue","content":"If you want to see more detailed breakdown where the memory is used, you should profile Starlark's evaluation of build files. Seethis page for details of profiling in the loading stage. This is a great starting point for troubleshooting. "},{"title":"How do I reduce memory footprint?​","type":1,"pageTitle":"Debugging Excess Starlark Peak Memory","url":"/docs/users/faq/starlark_peak_mem/#how-do-i-reduce-memory-footprint","content":"There are many reasons why Starlark's evaluation of your build file might use a lot of memory. We list a few common cases below but there might be more cases. High level guidance is to pay attention to loops as a starting point. Are there any unnecessary computations? Can you shave them off? "},{"title":"Repeatedly allocating memory unnecessarily in a loop​","type":1,"pageTitle":"Debugging Excess Starlark Peak Memory","url":"/docs/users/faq/starlark_peak_mem/#repeatedly-allocating-memory-unnecessarily-in-a-loop","content":"A common case where memory usage might accumulate is repeatedly allocating memory in a loop. For instance, below we call a memory intensive function in a loop unnecessarily: for target in huge_target_list: memory_intensive_fun(x,y) ...  Instead, if we know that arguments x and y don't change, we could hoist the call to memory_intensive_fun outside of the loop as follows: memory_intensive_fun(x,y) for target in huge_target_list: ...  "},{"title":"Simply allocating very big data-structures!​","type":1,"pageTitle":"Debugging Excess Starlark Peak Memory","url":"/docs/users/faq/starlark_peak_mem/#simply-allocating-very-big-data-structures","content":"Another reason why Starlark uses a lot of memory could simply be because the build file allocates a very big-data structure. For instance, below we allocate a list with 1 billion integers! million_list = [1 for i in range(1 &lt;&lt; 20)] billion_list = million_list * (1 &lt;&lt; 10)  As a workaround, could you think of splitting the list? "},{"title":"Algorithmically inefficient code​","type":1,"pageTitle":"Debugging Excess Starlark Peak Memory","url":"/docs/users/faq/starlark_peak_mem/#algorithmically-inefficient-code","content":"Another reason could be because memory efficiency of your code is bad, i.e. you are unnecessarily allocating a lot of memory. Let's look at an example where we try to process a bunch of targets inefficiently: targets = generate_targets(n) for target in targets: process(target)  If targets list is big and each target takes a lot of space in memory, memory usage might exceed the limit. Instead, a more efficient version might be to process each target as you generate it: for i in range(n): target = generate_target(i) process(target)  In this version, each target is processed as it is generated so we never need to store more than one target in memory. "},{"title":"Usage of inefficient library calls​","type":1,"pageTitle":"Debugging Excess Starlark Peak Memory","url":"/docs/users/faq/starlark_peak_mem/#usage-of-inefficient-library-calls","content":"A more subtle reason could be unknowingly invoking library calls that allocate each time they are called. A well-known case of this is the dict.items() call. for project, version in constraints.items(): # process each project ....  We do an allocation on every call to constraints.items(). Especially if this is a hot code in Starlark, this could cause an OOM. Instead, a potential fix is to hoist the call out: constraints = constraints.items() for project, version in constraints: # process each project ....  However, you need to ensure that the dictionary is not mutated inside, otherwise you would get functionally different code. A similar case occurs fordict.keys() where it returns a new list for containing the keys. "},{"title":"Allocating for rare cases​","type":1,"pageTitle":"Debugging Excess Starlark Peak Memory","url":"/docs/users/faq/starlark_peak_mem/#allocating-for-rare-cases","content":"Finally, another pattern is allocating memory for the rare cases. For instance, consdier the following example for target in huge_target_list: if memory_intensive_condition([target]) fail(...)  Above program could be optimized as follows: if memory_intensive_condition(huge_target_list) for target in huge_target_list: if memory_intensive_condition([target]) fail(...)  so that in the common non-failure case, we don't end up allocating excessive memory. "},{"title":"I still need more help!​","type":1,"pageTitle":"Debugging Excess Starlark Peak Memory","url":"/docs/users/faq/starlark_peak_mem/#i-still-need-more-help","content":"If you still can not figure out how to reduce Starlark memory footprint of your build files, raisean issue in our Github project. "},{"title":"Aquery Environment","type":0,"sectionRef":"#","url":"/docs/users/query/aquery/","content":"","keywords":""},{"title":"Query Value Types​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#query-value-types","content":"string: For example, non_quoted_string or &quot;quoted string&quot;. integer: Must be positive and fit in u32. target expression: either a literal or the return value of a function This could be a literal build target (&quot;cell//some:target&quot;) or a pattern (&quot;cell//package:&quot; or &quot;cell//recursive/...&quot;) or the result of another function that returns a target expression. For queries in CLI commands (like buck2 query), literals can be relative to the current working dir (like some:target or ...). file expression: either a literal or the return value of a function This could be a file literal like path/to/a.file or the return value of a function that returns files (for example, the buildfile() function). target or file expression: Either a file expression or target expression. This could be a literal like path/to/a.file or &quot;cell//some:target&quot;, or the return value of a function that returns files or targets. query expression: a valid query expression, evaluated in a function-specific context This is used for functions that capture an expression and evaluate it in another context. For example, the deps() function can accept an expression that it uses to find the children of a node to customize the deps traversal. any value: Any query value. "},{"title":"Common query functions​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#common-query-functions","content":"allpaths(from: target expression, to: target expression): Computes all dependency paths. somepath(from: target expression, to: target expression) attrfilter(attr: string, value: string, targets: target expression): The attrfilter(attribute, value, targets) operator evaluates the given target expression and filters the resulting build targets to those where the specified attribute contains the specified value. nattrfilter(attr: string, value: string, targets: target expression) attrregexfilter(attr: string, value: string, targets: target expression) buildfile(targets: target expression) rbuildfiles(universe: file expression, argset: file expression) allbuildfiles(universe: target expression) deps(targets: target expression, depth: ?integer, captured_expr: ?query expression) filter(regex: string, set: target or file expression): Filter using regex partial match. inputs(targets: target expression) kind(regex: string, targets: target expression): The kind(regex, targets) operator evaluates the specified target expression, targets, and returns the targets where the rule type matches the specified regex. labels(attr: string, targets: target expression): This function is not implemented, and won't be, because buck2 query core does not support owner(files: file expression): The owner(inputfile) operator returns the targets that own the specified inputfile. targets_in_buildfile(files: file expression) rdeps(universe: target expression, targets: target expression, depth: ?integer) testsof(targets: target expression) first_order_deps(): A filter function that can be used in the query expression of deps query function. target_deps(): A filter function that can be used in the query expression of deps query function. exec_deps(): A filter function that can be used in the query expression of deps query function. configuration_deps(): A filter function that can be used in the query expression of deps query function. toolchain_deps(): A filter function that can be used in the query expression of deps query function. intersect(left: any value, right: any value): Computes the set intersection over the given arguments. except(left: any value, right: any value): Computes the arguments that are in argument A but not in argument B. union(left: any value, right: any value): Computes the set union over the given arguments. "},{"title":"allpaths(from: target expression, to: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#allpathsfrom-target-expression-to-target-expression","content":"Computes all dependency paths. The allpaths(from, to) function evaluates to the graph formed by paths between the target expressions from and to, following the dependencies between nodes. For example, the value ofbuck query &quot;allpaths('//foo:bar', '//foo/bar/lib:baz')&quot;is the dependency graph rooted at the single target node //foo:bar, that includes all target nodes that depend (transitively) on //foo/bar/lib:baz. The two arguments to allpaths() can themselves be expressions. For example, the command:buck query &quot;allpaths(kind(java_library, '//...'), '//foo:bar')&quot;shows all the paths between any java_library in the repository and the target //foo:bar. We recommend using allpaths() with the --output-format=dot parameter to generate a graphviz file that can then be rendered as an image. For example: $ buck query &quot;allpaths('//foo:bar', '//foo/bar/lib:baz')&quot; --output-format=dot --output-file=result.dot $ dot -Tpng result.dot -o image.png  Graphviz is an open-source graph-visualization software tool. Graphviz uses the dot language to describe graphs. "},{"title":"somepath(from: target expression, to: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#somepathfrom-target-expression-to-target-expression","content":""},{"title":"attrfilter(attr: string, value: string, targets: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#attrfilterattr-string-value-string-targets-target-expression","content":"The attrfilter(attribute, value, targets) operator evaluates the given target expression and filters the resulting build targets to those where the specified attribute contains the specified value. In this context, the term attribute refers to an argument in a build rule, such as name, headers, srcs, or deps. If the attribute is a single value, say name, it is compared to the specified value, and the target is returned if they match.If the attribute is a list, the target is returned if that list contains the specified value.If the attribute is a dictionary, the target is returned if the value exists in either the keys or the values of the dictionary. For example:buck2 query &quot;attrfilter(deps, '//foo:bar', '//...')&quot; returns the build targets in the repository that depend on //foo:bar, or more precisely: those build targets that include //foo:bar in their deps argument list. "},{"title":"nattrfilter(attr: string, value: string, targets: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#nattrfilterattr-string-value-string-targets-target-expression","content":""},{"title":"attrregexfilter(attr: string, value: string, targets: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#attrregexfilterattr-string-value-string-targets-target-expression","content":""},{"title":"buildfile(targets: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#buildfiletargets-target-expression","content":""},{"title":"rbuildfiles(universe: file expression, argset: file expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#rbuildfilesuniverse-file-expression-argset-file-expression","content":""},{"title":"allbuildfiles(universe: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#allbuildfilesuniverse-target-expression","content":""},{"title":"deps(targets: target expression, depth: ?integer, captured_expr: ?query expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#depstargets-target-expression-depth-integer-captured_expr-query-expression","content":""},{"title":"filter(regex: string, set: target or file expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#filterregex-string-set-target-or-file-expression","content":"Filter using regex partial match. Target are matched against their fully qualified name. Files are matched against their repo path like repo//foo/bar/baz.py. "},{"title":"inputs(targets: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#inputstargets-target-expression","content":""},{"title":"kind(regex: string, targets: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#kindregex-string-targets-target-expression","content":"The kind(regex, targets) operator evaluates the specified target expression, targets, and returns the targets where the rule type matches the specified regex. The specified pattern can be a regular expression. For example,buck2 query &quot;kind('java.*', deps('//foo:bar'))&quot; returns the targets that match the rule type java.* (java_library, java_binary, etc.) in the transitive dependencies of //foo:bar. "},{"title":"labels(attr: string, targets: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#labelsattr-string-targets-target-expression","content":"This function is not implemented, and won't be, because buck2 query core does not support returning both files and targets from a single function. In buck1 it returns targets and files referenced by the given attribute in the given targets. Some discussion in T126638795. "},{"title":"owner(files: file expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#ownerfiles-file-expression","content":"The owner(inputfile) operator returns the targets that own the specified inputfile. In this context, own means that the target has the specified file as an input. You could consider the owner() and inputs() operators to be inverses of each other. Example: buck2 query &quot;owner('examples/1.txt')&quot; returns the targets that owns the file examples/1.txt, which could be a value such as //examples:one. It is possible for the specified file to have multiple owners, in which case, owner() returns a set of targets. If no owner for the file is found, owner() outputs the message: No owner was found for &lt;file&gt; "},{"title":"targets_in_buildfile(files: file expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#targets_in_buildfilefiles-file-expression","content":""},{"title":"rdeps(universe: target expression, targets: target expression, depth: ?integer)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#rdepsuniverse-target-expression-targets-target-expression-depth-integer","content":""},{"title":"testsof(targets: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#testsoftargets-target-expression","content":""},{"title":"first_order_deps()​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#first_order_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for the immediate dependencies of the given targets. Output is equivalent to deps(&lt;targets&gt;, 1). Example:buck2 cquery &quot;deps('//foo:bar', 1, first_order_deps())&quot;`` is equivalent to buck2 cquery &quot;deps('//foo:bar', 1)&quot;` "},{"title":"target_deps()​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#target_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the target dependencies of each dependency of the given targets, excluding any configuration, toolchain and execution dependencies (build time dependencies) like compiler used as a part of the build. Example: `buck2 cquery &quot;deps('//foo:bar', 1, target_deps())&quot;`` "},{"title":"exec_deps()​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#exec_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for execution dependencies (build time dependencies), ex. compiler used as a part of the build. Example: `buck2 cquery &quot;deps('//foo:bar', 1, exec_deps())&quot;`` "},{"title":"configuration_deps()​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#configuration_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for configuration dependencies (that appear as conditions in selects). Example: `buck2 cquery &quot;deps('//foo:bar', 1, configuration_deps())&quot;`` "},{"title":"toolchain_deps()​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#toolchain_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for toolchain dependencies. Example: `buck2 cquery &quot;deps('//foo:bar', 1, toolchain_deps())&quot;`` "},{"title":"intersect(left: any value, right: any value)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#intersectleft-any-value-right-any-value","content":"Computes the set intersection over the given arguments. Can be used with the ^ symbol. This operator is commutative. The parser treats this operator as left-associative and of equal precedence, so we recommend that you use parentheses if you need to ensure a specific order of evaluation. A parenthesized expression resolves to the value of the expression it encloses. Example:buck2 aquery &quot;deps('//foo:bar') intersect deps('//baz:lib')&quot; is the same asbuck2 aquery &quot;deps('//foo:bar') ^ deps('//baz:lib')&quot;Both return the targets that appear in the transitive closure of //foo:bar and //baz:lib. "},{"title":"except(left: any value, right: any value)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#exceptleft-any-value-right-any-value","content":"Computes the arguments that are in argument A but not in argument B. Can be used with the - symbol. This operator is NOT commutative. The parser treats this operator as left-associative and of equal precedence, so we recommend that you use parentheses if you need to ensure a specific order of evaluation. A parenthesized expression resolves to the value of the expression it encloses. Example:buck2 aquery &quot;deps('//foo:bar') except deps('//baz:lib')&quot; is the same asbuck2 aquery &quot;deps('//foo:bar') - deps('//baz:lib')&quot;Both return the targets that //foo:bar depends on and that //baz:lib does NOT depend on. "},{"title":"union(left: any value, right: any value)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#unionleft-any-value-right-any-value","content":"Computes the set union over the given arguments. Can be used with the + symbol. This operator is commutative. The parser treats all this operator as left-associative and of equal precedence, so we recommend that you use parentheses if you need to ensure a specific order of evaluation. A parenthesized expression resolves to the value of the expression it encloses. Example:buck2 aquery &quot;deps('//foo:bar') union deps('//baz:lib')&quot; is the same asbuck2 aquery &quot;deps('//foo:bar') + deps('//baz:lib')&quot;Both return the aggregation of the targets that //foo:bar and //baz:lib depend on. "},{"title":"Query functions​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#query-functions","content":"all_outputs(targets: target expression): Obtain the actions for all the outputs provided by the DefaultInfo for the targets passed all_actions(targets: target expression): Obtain all the actions declared within the analysis of a given target. "},{"title":"all_outputs(targets: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#all_outputstargets-target-expression","content":"Obtain the actions for all the outputs provided by the DefaultInfo for the targets passed as input. This includes both the default_outputs and other_outputs. This operation only makes sense on a target literal (it does nothing if passed something else). "},{"title":"all_actions(targets: target expression)​","type":1,"pageTitle":"Aquery Environment","url":"/docs/users/query/aquery/#all_actionstargets-target-expression","content":"Obtain all the actions declared within the analysis of a given target. This operation only makes sense on a target literal (it is a simple passthrough when passed an action). "},{"title":"Cquery Environment","type":0,"sectionRef":"#","url":"/docs/users/query/cquery/","content":"","keywords":""},{"title":"Query Value Types​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#query-value-types","content":"string: For example, non_quoted_string or &quot;quoted string&quot;. integer: Must be positive and fit in u32. target expression: either a literal or the return value of a function This could be a literal build target (&quot;cell//some:target&quot;) or a pattern (&quot;cell//package:&quot; or &quot;cell//recursive/...&quot;) or the result of another function that returns a target expression. For queries in CLI commands (like buck2 query), literals can be relative to the current working dir (like some:target or ...). file expression: either a literal or the return value of a function This could be a file literal like path/to/a.file or the return value of a function that returns files (for example, the buildfile() function). target or file expression: Either a file expression or target expression. This could be a literal like path/to/a.file or &quot;cell//some:target&quot;, or the return value of a function that returns files or targets. query expression: a valid query expression, evaluated in a function-specific context This is used for functions that capture an expression and evaluate it in another context. For example, the deps() function can accept an expression that it uses to find the children of a node to customize the deps traversal. any value: Any query value. "},{"title":"Common query functions​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#common-query-functions","content":"allpaths(from: target expression, to: target expression): Computes all dependency paths. somepath(from: target expression, to: target expression) attrfilter(attr: string, value: string, targets: target expression): The attrfilter(attribute, value, targets) operator evaluates the given target expression and filters the resulting build targets to those where the specified attribute contains the specified value. nattrfilter(attr: string, value: string, targets: target expression) attrregexfilter(attr: string, value: string, targets: target expression) buildfile(targets: target expression) rbuildfiles(universe: file expression, argset: file expression) allbuildfiles(universe: target expression) deps(targets: target expression, depth: ?integer, captured_expr: ?query expression) filter(regex: string, set: target or file expression): Filter using regex partial match. inputs(targets: target expression) kind(regex: string, targets: target expression): The kind(regex, targets) operator evaluates the specified target expression, targets, and returns the targets where the rule type matches the specified regex. labels(attr: string, targets: target expression): This function is not implemented, and won't be, because buck2 query core does not support owner(files: file expression): The owner(inputfile) operator returns the targets that own the specified inputfile. targets_in_buildfile(files: file expression) rdeps(universe: target expression, targets: target expression, depth: ?integer) testsof(targets: target expression) first_order_deps(): A filter function that can be used in the query expression of deps query function. target_deps(): A filter function that can be used in the query expression of deps query function. exec_deps(): A filter function that can be used in the query expression of deps query function. configuration_deps(): A filter function that can be used in the query expression of deps query function. toolchain_deps(): A filter function that can be used in the query expression of deps query function. intersect(left: any value, right: any value): Computes the set intersection over the given arguments. except(left: any value, right: any value): Computes the arguments that are in argument A but not in argument B. union(left: any value, right: any value): Computes the set union over the given arguments. "},{"title":"allpaths(from: target expression, to: target expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#allpathsfrom-target-expression-to-target-expression","content":"Computes all dependency paths. The allpaths(from, to) function evaluates to the graph formed by paths between the target expressions from and to, following the dependencies between nodes. For example, the value ofbuck query &quot;allpaths('//foo:bar', '//foo/bar/lib:baz')&quot;is the dependency graph rooted at the single target node //foo:bar, that includes all target nodes that depend (transitively) on //foo/bar/lib:baz. The two arguments to allpaths() can themselves be expressions. For example, the command:buck query &quot;allpaths(kind(java_library, '//...'), '//foo:bar')&quot;shows all the paths between any java_library in the repository and the target //foo:bar. We recommend using allpaths() with the --output-format=dot parameter to generate a graphviz file that can then be rendered as an image. For example: $ buck query &quot;allpaths('//foo:bar', '//foo/bar/lib:baz')&quot; --output-format=dot --output-file=result.dot $ dot -Tpng result.dot -o image.png  Graphviz is an open-source graph-visualization software tool. Graphviz uses the dot language to describe graphs. "},{"title":"somepath(from: target expression, to: target expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#somepathfrom-target-expression-to-target-expression","content":""},{"title":"attrfilter(attr: string, value: string, targets: target expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#attrfilterattr-string-value-string-targets-target-expression","content":"The attrfilter(attribute, value, targets) operator evaluates the given target expression and filters the resulting build targets to those where the specified attribute contains the specified value. In this context, the term attribute refers to an argument in a build rule, such as name, headers, srcs, or deps. If the attribute is a single value, say name, it is compared to the specified value, and the target is returned if they match.If the attribute is a list, the target is returned if that list contains the specified value.If the attribute is a dictionary, the target is returned if the value exists in either the keys or the values of the dictionary. For example:buck2 query &quot;attrfilter(deps, '//foo:bar', '//...')&quot; returns the build targets in the repository that depend on //foo:bar, or more precisely: those build targets that include //foo:bar in their deps argument list. "},{"title":"nattrfilter(attr: string, value: string, targets: target expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#nattrfilterattr-string-value-string-targets-target-expression","content":""},{"title":"attrregexfilter(attr: string, value: string, targets: target expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#attrregexfilterattr-string-value-string-targets-target-expression","content":""},{"title":"buildfile(targets: target expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#buildfiletargets-target-expression","content":""},{"title":"rbuildfiles(universe: file expression, argset: file expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#rbuildfilesuniverse-file-expression-argset-file-expression","content":""},{"title":"allbuildfiles(universe: target expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#allbuildfilesuniverse-target-expression","content":""},{"title":"deps(targets: target expression, depth: ?integer, captured_expr: ?query expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#depstargets-target-expression-depth-integer-captured_expr-query-expression","content":""},{"title":"filter(regex: string, set: target or file expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#filterregex-string-set-target-or-file-expression","content":"Filter using regex partial match. Target are matched against their fully qualified name. Files are matched against their repo path like repo//foo/bar/baz.py. "},{"title":"inputs(targets: target expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#inputstargets-target-expression","content":""},{"title":"kind(regex: string, targets: target expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#kindregex-string-targets-target-expression","content":"The kind(regex, targets) operator evaluates the specified target expression, targets, and returns the targets where the rule type matches the specified regex. The specified pattern can be a regular expression. For example,buck2 query &quot;kind('java.*', deps('//foo:bar'))&quot; returns the targets that match the rule type java.* (java_library, java_binary, etc.) in the transitive dependencies of //foo:bar. "},{"title":"labels(attr: string, targets: target expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#labelsattr-string-targets-target-expression","content":"This function is not implemented, and won't be, because buck2 query core does not support returning both files and targets from a single function. In buck1 it returns targets and files referenced by the given attribute in the given targets. Some discussion in T126638795. "},{"title":"owner(files: file expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#ownerfiles-file-expression","content":"The owner(inputfile) operator returns the targets that own the specified inputfile. In this context, own means that the target has the specified file as an input. You could consider the owner() and inputs() operators to be inverses of each other. Example: buck2 query &quot;owner('examples/1.txt')&quot; returns the targets that owns the file examples/1.txt, which could be a value such as //examples:one. It is possible for the specified file to have multiple owners, in which case, owner() returns a set of targets. If no owner for the file is found, owner() outputs the message: No owner was found for &lt;file&gt; "},{"title":"targets_in_buildfile(files: file expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#targets_in_buildfilefiles-file-expression","content":""},{"title":"rdeps(universe: target expression, targets: target expression, depth: ?integer)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#rdepsuniverse-target-expression-targets-target-expression-depth-integer","content":""},{"title":"testsof(targets: target expression)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#testsoftargets-target-expression","content":""},{"title":"first_order_deps()​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#first_order_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for the immediate dependencies of the given targets. Output is equivalent to deps(&lt;targets&gt;, 1). Example:buck2 cquery &quot;deps('//foo:bar', 1, first_order_deps())&quot;`` is equivalent to buck2 cquery &quot;deps('//foo:bar', 1)&quot;` "},{"title":"target_deps()​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#target_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the target dependencies of each dependency of the given targets, excluding any configuration, toolchain and execution dependencies (build time dependencies) like compiler used as a part of the build. Example: `buck2 cquery &quot;deps('//foo:bar', 1, target_deps())&quot;`` "},{"title":"exec_deps()​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#exec_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for execution dependencies (build time dependencies), ex. compiler used as a part of the build. Example: `buck2 cquery &quot;deps('//foo:bar', 1, exec_deps())&quot;`` "},{"title":"configuration_deps()​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#configuration_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for configuration dependencies (that appear as conditions in selects). Example: `buck2 cquery &quot;deps('//foo:bar', 1, configuration_deps())&quot;`` "},{"title":"toolchain_deps()​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#toolchain_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for toolchain dependencies. Example: `buck2 cquery &quot;deps('//foo:bar', 1, toolchain_deps())&quot;`` "},{"title":"intersect(left: any value, right: any value)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#intersectleft-any-value-right-any-value","content":"Computes the set intersection over the given arguments. Can be used with the ^ symbol. This operator is commutative. The parser treats this operator as left-associative and of equal precedence, so we recommend that you use parentheses if you need to ensure a specific order of evaluation. A parenthesized expression resolves to the value of the expression it encloses. Example:buck2 aquery &quot;deps('//foo:bar') intersect deps('//baz:lib')&quot; is the same asbuck2 aquery &quot;deps('//foo:bar') ^ deps('//baz:lib')&quot;Both return the targets that appear in the transitive closure of //foo:bar and //baz:lib. "},{"title":"except(left: any value, right: any value)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#exceptleft-any-value-right-any-value","content":"Computes the arguments that are in argument A but not in argument B. Can be used with the - symbol. This operator is NOT commutative. The parser treats this operator as left-associative and of equal precedence, so we recommend that you use parentheses if you need to ensure a specific order of evaluation. A parenthesized expression resolves to the value of the expression it encloses. Example:buck2 aquery &quot;deps('//foo:bar') except deps('//baz:lib')&quot; is the same asbuck2 aquery &quot;deps('//foo:bar') - deps('//baz:lib')&quot;Both return the targets that //foo:bar depends on and that //baz:lib does NOT depend on. "},{"title":"union(left: any value, right: any value)​","type":1,"pageTitle":"Cquery Environment","url":"/docs/users/query/cquery/#unionleft-any-value-right-any-value","content":"Computes the set union over the given arguments. Can be used with the + symbol. This operator is commutative. The parser treats all this operator as left-associative and of equal precedence, so we recommend that you use parentheses if you need to ensure a specific order of evaluation. A parenthesized expression resolves to the value of the expression it encloses. Example:buck2 aquery &quot;deps('//foo:bar') union deps('//baz:lib')&quot; is the same asbuck2 aquery &quot;deps('//foo:bar') + deps('//baz:lib')&quot;Both return the aggregation of the targets that //foo:bar and //baz:lib depend on. "},{"title":"Remote Execution","type":0,"sectionRef":"#","url":"/docs/users/remote_execution/","content":"","keywords":""},{"title":"RE configuration in .buckconfig​","type":1,"pageTitle":"Remote Execution","url":"/docs/users/remote_execution/#re-configuration-in-buckconfig","content":"Configuration for remote execution can be found under [buck2_re_client] in.buckconfig. Keys supported include: engine_address - address to your RE's engine.action_cache_address - address to your action cache endpoint.cas_address - address to your content-addressable storage (CAS) endpoint.tls_ca_certs - path to a CA certificates bundle. This must be PEM-encoded. If none is set, a default bundle will be used. This path contains environment variables using shell interpolation syntax (i.e. $VAR). They will be substituted before reading the file.tls_client_cert - path to a client certificate (and intermediate chain), as well as its associated private key. This must be PEM-encoded. This path can contain environment variables using shell interpolation syntax (i.e. $VAR). They will be substituted before reading the file.http_headers - HTTP headers to inject in all requests to RE. This is a comma-separated list of Header: Value pairs. Minimal validation of those headers is done here. This can contain environment variables using shell interpolation syntax ($VAR). They will be substituted before reading the file.instance_name - an instance name to pass on execution, action cache, and CAS requests. Buck2 uses SHA256 for all its hashing by default. If your RE engine requires something else, this can be configured in .buckconfig as follows: [buck2] # Accepts BLAKE3, SHA1, or SHA256 digest_algorithms = BLAKE3  "},{"title":"RE platform configuration​","type":1,"pageTitle":"Remote Execution","url":"/docs/users/remote_execution/#re-platform-configuration","content":"Next, your build will need anexecution platformthat specifies how and where actions should be executed. For a sample platform definition that sets up an execution platform to utilize RE, take a look at theEngFlow example,BuildBarn example, or theBuildBuddy example. To enable remote execution, configure the following fields inCommandExecutorConfigas follows: remote_enabled - set to True.local_enabled - set to True if you also want to run actions locally.use_limited_hybrid - set to False unless you want to exclusively run remotely when possible.remote_execution_properties - other additional properties. If the RE engine requires a container image, this can be done by settingcontainer-image to an image URL, as is done in the example above. "},{"title":"Uquery Environment","type":0,"sectionRef":"#","url":"/docs/users/query/uquery/","content":"","keywords":""},{"title":"Query Value Types​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#query-value-types","content":"string: For example, non_quoted_string or &quot;quoted string&quot;. integer: Must be positive and fit in u32. target expression: either a literal or the return value of a function This could be a literal build target (&quot;cell//some:target&quot;) or a pattern (&quot;cell//package:&quot; or &quot;cell//recursive/...&quot;) or the result of another function that returns a target expression. For queries in CLI commands (like buck2 query), literals can be relative to the current working dir (like some:target or ...). file expression: either a literal or the return value of a function This could be a file literal like path/to/a.file or the return value of a function that returns files (for example, the buildfile() function). target or file expression: Either a file expression or target expression. This could be a literal like path/to/a.file or &quot;cell//some:target&quot;, or the return value of a function that returns files or targets. query expression: a valid query expression, evaluated in a function-specific context This is used for functions that capture an expression and evaluate it in another context. For example, the deps() function can accept an expression that it uses to find the children of a node to customize the deps traversal. any value: Any query value. "},{"title":"Common query functions​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#common-query-functions","content":"allpaths(from: target expression, to: target expression): Computes all dependency paths. somepath(from: target expression, to: target expression) attrfilter(attr: string, value: string, targets: target expression): The attrfilter(attribute, value, targets) operator evaluates the given target expression and filters the resulting build targets to those where the specified attribute contains the specified value. nattrfilter(attr: string, value: string, targets: target expression) attrregexfilter(attr: string, value: string, targets: target expression) buildfile(targets: target expression) rbuildfiles(universe: file expression, argset: file expression) allbuildfiles(universe: target expression) deps(targets: target expression, depth: ?integer, captured_expr: ?query expression) filter(regex: string, set: target or file expression): Filter using regex partial match. inputs(targets: target expression) kind(regex: string, targets: target expression): The kind(regex, targets) operator evaluates the specified target expression, targets, and returns the targets where the rule type matches the specified regex. labels(attr: string, targets: target expression): This function is not implemented, and won't be, because buck2 query core does not support owner(files: file expression): The owner(inputfile) operator returns the targets that own the specified inputfile. targets_in_buildfile(files: file expression) rdeps(universe: target expression, targets: target expression, depth: ?integer) testsof(targets: target expression) first_order_deps(): A filter function that can be used in the query expression of deps query function. target_deps(): A filter function that can be used in the query expression of deps query function. exec_deps(): A filter function that can be used in the query expression of deps query function. configuration_deps(): A filter function that can be used in the query expression of deps query function. toolchain_deps(): A filter function that can be used in the query expression of deps query function. intersect(left: any value, right: any value): Computes the set intersection over the given arguments. except(left: any value, right: any value): Computes the arguments that are in argument A but not in argument B. union(left: any value, right: any value): Computes the set union over the given arguments. "},{"title":"allpaths(from: target expression, to: target expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#allpathsfrom-target-expression-to-target-expression","content":"Computes all dependency paths. The allpaths(from, to) function evaluates to the graph formed by paths between the target expressions from and to, following the dependencies between nodes. For example, the value ofbuck query &quot;allpaths('//foo:bar', '//foo/bar/lib:baz')&quot;is the dependency graph rooted at the single target node //foo:bar, that includes all target nodes that depend (transitively) on //foo/bar/lib:baz. The two arguments to allpaths() can themselves be expressions. For example, the command:buck query &quot;allpaths(kind(java_library, '//...'), '//foo:bar')&quot;shows all the paths between any java_library in the repository and the target //foo:bar. We recommend using allpaths() with the --output-format=dot parameter to generate a graphviz file that can then be rendered as an image. For example: $ buck query &quot;allpaths('//foo:bar', '//foo/bar/lib:baz')&quot; --output-format=dot --output-file=result.dot $ dot -Tpng result.dot -o image.png  Graphviz is an open-source graph-visualization software tool. Graphviz uses the dot language to describe graphs. "},{"title":"somepath(from: target expression, to: target expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#somepathfrom-target-expression-to-target-expression","content":""},{"title":"attrfilter(attr: string, value: string, targets: target expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#attrfilterattr-string-value-string-targets-target-expression","content":"The attrfilter(attribute, value, targets) operator evaluates the given target expression and filters the resulting build targets to those where the specified attribute contains the specified value. In this context, the term attribute refers to an argument in a build rule, such as name, headers, srcs, or deps. If the attribute is a single value, say name, it is compared to the specified value, and the target is returned if they match.If the attribute is a list, the target is returned if that list contains the specified value.If the attribute is a dictionary, the target is returned if the value exists in either the keys or the values of the dictionary. For example:buck2 query &quot;attrfilter(deps, '//foo:bar', '//...')&quot; returns the build targets in the repository that depend on //foo:bar, or more precisely: those build targets that include //foo:bar in their deps argument list. "},{"title":"nattrfilter(attr: string, value: string, targets: target expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#nattrfilterattr-string-value-string-targets-target-expression","content":""},{"title":"attrregexfilter(attr: string, value: string, targets: target expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#attrregexfilterattr-string-value-string-targets-target-expression","content":""},{"title":"buildfile(targets: target expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#buildfiletargets-target-expression","content":""},{"title":"rbuildfiles(universe: file expression, argset: file expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#rbuildfilesuniverse-file-expression-argset-file-expression","content":""},{"title":"allbuildfiles(universe: target expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#allbuildfilesuniverse-target-expression","content":""},{"title":"deps(targets: target expression, depth: ?integer, captured_expr: ?query expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#depstargets-target-expression-depth-integer-captured_expr-query-expression","content":""},{"title":"filter(regex: string, set: target or file expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#filterregex-string-set-target-or-file-expression","content":"Filter using regex partial match. Target are matched against their fully qualified name. Files are matched against their repo path like repo//foo/bar/baz.py. "},{"title":"inputs(targets: target expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#inputstargets-target-expression","content":""},{"title":"kind(regex: string, targets: target expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#kindregex-string-targets-target-expression","content":"The kind(regex, targets) operator evaluates the specified target expression, targets, and returns the targets where the rule type matches the specified regex. The specified pattern can be a regular expression. For example,buck2 query &quot;kind('java.*', deps('//foo:bar'))&quot; returns the targets that match the rule type java.* (java_library, java_binary, etc.) in the transitive dependencies of //foo:bar. "},{"title":"labels(attr: string, targets: target expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#labelsattr-string-targets-target-expression","content":"This function is not implemented, and won't be, because buck2 query core does not support returning both files and targets from a single function. In buck1 it returns targets and files referenced by the given attribute in the given targets. Some discussion in T126638795. "},{"title":"owner(files: file expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#ownerfiles-file-expression","content":"The owner(inputfile) operator returns the targets that own the specified inputfile. In this context, own means that the target has the specified file as an input. You could consider the owner() and inputs() operators to be inverses of each other. Example: buck2 query &quot;owner('examples/1.txt')&quot; returns the targets that owns the file examples/1.txt, which could be a value such as //examples:one. It is possible for the specified file to have multiple owners, in which case, owner() returns a set of targets. If no owner for the file is found, owner() outputs the message: No owner was found for &lt;file&gt; "},{"title":"targets_in_buildfile(files: file expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#targets_in_buildfilefiles-file-expression","content":""},{"title":"rdeps(universe: target expression, targets: target expression, depth: ?integer)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#rdepsuniverse-target-expression-targets-target-expression-depth-integer","content":""},{"title":"testsof(targets: target expression)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#testsoftargets-target-expression","content":""},{"title":"first_order_deps()​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#first_order_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for the immediate dependencies of the given targets. Output is equivalent to deps(&lt;targets&gt;, 1). Example:buck2 cquery &quot;deps('//foo:bar', 1, first_order_deps())&quot;`` is equivalent to buck2 cquery &quot;deps('//foo:bar', 1)&quot;` "},{"title":"target_deps()​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#target_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the target dependencies of each dependency of the given targets, excluding any configuration, toolchain and execution dependencies (build time dependencies) like compiler used as a part of the build. Example: `buck2 cquery &quot;deps('//foo:bar', 1, target_deps())&quot;`` "},{"title":"exec_deps()​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#exec_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for execution dependencies (build time dependencies), ex. compiler used as a part of the build. Example: `buck2 cquery &quot;deps('//foo:bar', 1, exec_deps())&quot;`` "},{"title":"configuration_deps()​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#configuration_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for configuration dependencies (that appear as conditions in selects). Example: `buck2 cquery &quot;deps('//foo:bar', 1, configuration_deps())&quot;`` "},{"title":"toolchain_deps()​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#toolchain_deps","content":"A filter function that can be used in the query expression of deps query function. Returns the output of deps function for toolchain dependencies. Example: `buck2 cquery &quot;deps('//foo:bar', 1, toolchain_deps())&quot;`` "},{"title":"intersect(left: any value, right: any value)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#intersectleft-any-value-right-any-value","content":"Computes the set intersection over the given arguments. Can be used with the ^ symbol. This operator is commutative. The parser treats this operator as left-associative and of equal precedence, so we recommend that you use parentheses if you need to ensure a specific order of evaluation. A parenthesized expression resolves to the value of the expression it encloses. Example:buck2 aquery &quot;deps('//foo:bar') intersect deps('//baz:lib')&quot; is the same asbuck2 aquery &quot;deps('//foo:bar') ^ deps('//baz:lib')&quot;Both return the targets that appear in the transitive closure of //foo:bar and //baz:lib. "},{"title":"except(left: any value, right: any value)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#exceptleft-any-value-right-any-value","content":"Computes the arguments that are in argument A but not in argument B. Can be used with the - symbol. This operator is NOT commutative. The parser treats this operator as left-associative and of equal precedence, so we recommend that you use parentheses if you need to ensure a specific order of evaluation. A parenthesized expression resolves to the value of the expression it encloses. Example:buck2 aquery &quot;deps('//foo:bar') except deps('//baz:lib')&quot; is the same asbuck2 aquery &quot;deps('//foo:bar') - deps('//baz:lib')&quot;Both return the targets that //foo:bar depends on and that //baz:lib does NOT depend on. "},{"title":"union(left: any value, right: any value)​","type":1,"pageTitle":"Uquery Environment","url":"/docs/users/query/uquery/#unionleft-any-value-right-any-value","content":"Computes the set union over the given arguments. Can be used with the + symbol. This operator is commutative. The parser treats all this operator as left-associative and of equal precedence, so we recommend that you use parentheses if you need to ensure a specific order of evaluation. A parenthesized expression resolves to the value of the expression it encloses. Example:buck2 aquery &quot;deps('//foo:bar') union deps('//baz:lib')&quot; is the same asbuck2 aquery &quot;deps('//foo:bar') + deps('//baz:lib')&quot;Both return the aggregation of the targets that //foo:bar and //baz:lib depend on. "},{"title":"Rules","type":0,"sectionRef":"#","url":"/docs/prelude/globals/","content":"","keywords":""},{"title":"android_aar​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_aar","content":"def android_aar( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _is_building_android_binary: bool = _, _is_force_single_cpu: bool = _, _is_force_single_default_cpu: bool = _, _java_toolchain: str = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, abi_generation_mode: None | str = _, annotation_processing_tool: None | str = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, build_config_values: list[str] = _, build_config_values_file: None | str = _, compress_asset_libraries: bool = _, contacts: list[str] = _, cpu_filters: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, enable_relinker: bool = _, excluded_java_deps: list[str] = _, extra_arguments: list[str] = _, extra_kotlinc_arguments: list[str] = _, friend_paths: list[str] = _, include_build_config_class: bool = _, java_version: None | str = _, javac: None | str = _, kotlin_compiler_plugins: dict[str, dict[str, str]] = _, labels: list[str] = _, language: None | str = _, licenses: list[str] = _, manifest: None | str = _, manifest_file: None | str = _, manifest_skeleton: str, maven_coords: None | str = _, min_sdk_version: None | int = _, native_library_merge_code_generator: None | str = _, native_library_merge_glue: None | str = _, native_library_merge_linker_args: None | dict[str, list[str]] = _, native_library_merge_localized_symbols: None | list[str] = _, native_library_merge_map: None | dict[str, list[str]] = _, native_library_merge_sequence: None | list[typing.Any] = _, native_library_merge_sequence_blocklist: None | list[str] = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, package_asset_libraries: bool = _, package_resources: bool = _, plugins: list[str] = _, proguard_config: None | str = _, relinker_extra_deps: list[str] = _, relinker_whitelist: list[str] = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resource_union_package: None | str = _, resources: list[str] = _, resources_root: None | str = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, srcs: list[str] = _, strip_libraries: bool = _, target: None | str = _, use_jvm_abi_gen: None | bool = _ ) -&gt; None  An android_aar() rule is used to generate an Android AAR. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onebuild_config_values: See the documentation on the values argument for android_build_config().include_build_config_class: Whether to include the BuildConfig class files in the final .aar file. Needs to be set to True if any build_config_values are specified. This is normally only needed if the build tool that is consuming the .aar file does not generate BuildConfig classes. Note: the AAR format does not specify a way to pass defaults that should be injected into the final BuildConfig class, therefore that information might need to be replicated manually in the build that's consuming the .aar file.manifest_skeleton: The skeleton manifest file used to generate the final AndroidManifest.xml . May either be a file or an android_manifest() target.remove_classes: List of classes to remove from the output aar. It removes classes from the target's own sources, and its dependencies. Details​ See the official Android documentation for details about the .aar format. Examples:  android_resource( name = 'res', res = 'res', assets = 'assets', package = 'com.example', ) android_library( name = 'lib', srcs = glob(['**/*.java']), ) android_aar( name = 'app', manifest_skeleton = 'AndroidManifestSkeleton.xml', deps = [ ':res', ':lib', ], )   "},{"title":"android_app_modularity​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_app_modularity","content":"def android_app_modularity( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, application_module_blacklist: None | list[str] = _, application_module_configs: dict[str, list[str]] = _, application_module_dependencies: None | dict[str, list[str]] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, no_dx: list[str] = _, should_include_classes: bool = _, should_include_libraries: bool = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"android_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_binary","content":"def android_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _dex_toolchain: str = _, _exec_os_type: str = _, _is_building_android_binary: bool = _, _is_force_single_cpu: bool = _, _is_force_single_default_cpu: bool = _, _java_toolchain: str = _, aapt2_keep_raw_values: bool = _, aapt2_locale_filtering: bool = _, aapt2_preferred_density: None | str = _, aapt_mode: str = _, additional_aapt_params: list[str] = _, allow_r_dot_java_in_secondary_dex: bool = _, allowed_duplicate_resource_types: list[str] = _, android_sdk_proguard_config: None | str = _, application_module_blacklist: None | list[str] = _, application_module_configs: dict[str, list[str]] = _, application_module_dependencies: None | dict[str, list[str]] = _, asset_compression_algorithm: None | str = _, banned_duplicate_resource_types: list[str] = _, buck2_compatibility: str = _, build_config_values: list[str] = _, build_config_values_file: None | str = _, build_string_source_map: bool = _, compress_asset_libraries: bool = _, constraint_overrides: list[str] = _, contacts: list[str] = _, cpu_filters: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, dex_compression: None | str = _, dex_group_lib_limit: int = _, dex_tool: str = _, disable_pre_dex: bool = _, duplicate_resource_behavior: str = _, duplicate_resource_whitelist: None | str = _, enable_relinker: bool = _, exopackage_modes: list[str] = _, extra_filtered_resources: list[str] = _, extra_no_compress_asset_extensions: list[str] = _, field_ref_count_buffer_space: int = _, ignore_aapt_proguard_config: bool = _, includes_vector_drawables: bool = _, is_cacheable: bool = _, is_voltron_language_pack_enabled: bool = _, keystore: str, labels: list[str] = _, licenses: list[str] = _, linear_alloc_hard_limit: int = _, locales: list[str] = _, manifest: None | str = _, manifest_entries: dict[str, typing.Any] = _, manifest_skeleton: None | str = _, method_ref_count_buffer_space: int = _, min_sdk_version: None | int = _, minimize_primary_dex_size: bool = _, module_manifest_skeleton: None | str = _, native_library_merge_code_generator: None | str = _, native_library_merge_glue: None | str = _, native_library_merge_linker_args: None | dict[str, list[str]] = _, native_library_merge_localized_symbols: None | list[str] = _, native_library_merge_map: None | dict[str, list[str]] = _, native_library_merge_sequence: None | list[typing.Any] = _, native_library_merge_sequence_blocklist: None | list[str] = _, no_auto_add_overlay_resources: bool = _, no_auto_version_resources: bool = _, no_dx: list[str] = _, no_version_transitions_resources: bool = _, optimization_passes: int = _, package_asset_libraries: bool = _, package_type: str = _, packaged_locales: list[str] = _, packaging_options: dict[str, list[str]] = _, post_filter_resources_cmd: None | str = _, preprocess_java_classes_bash: None | str = _, preprocess_java_classes_cmd: None | str = _, preprocess_java_classes_deps: list[str] = _, primary_dex_patterns: list[str] = _, proguard_config: None | str = _, proguard_jvm_args: list[str] = _, relinker_extra_deps: list[str] = _, relinker_whitelist: list[str] = _, resource_compression: str = _, resource_filter: list[str] = _, resource_stable_ids: None | str = _, resource_union_package: None | str = _, secondary_dex_weight_limit: None | int = _, skip_crunch_pngs: None | bool = _, skip_proguard: bool = _, strip_libraries: bool = _, trim_resource_ids: bool = _, use_split_dex: bool = _, validation_deps: list[str] = _, xz_compression_level: int = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"android_build_config​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_build_config","content":"def android_build_config( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _is_building_android_binary: bool = _, _java_toolchain: str = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, package: str = _, values: list[str] = _, values_file: None | str = _ ) -&gt; None  An android_build_config() rule is used to generate a BuildConfig class with global configuration variables that other android_library() rules can compile against. Currently, the only variable exposed by BuildConfig is a global boolean named DEBUG, much like the BuildConfig.java generated by the official Android build tools based on Gradle. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one package: Name of the Java package to use in the generated BuildConfig.java file. Most developers set this to the application id declared in the manifest via &lt;manifest package=&quot;APP_ID&quot;&gt;. Example: com.facebook.orca. values: List of strings that defines additional fields (and values) that should be declared in the generated BuildConfig.java file. Like DEBUG, the values will be non-constant-expressions that evaluate to the value specified in the file at compilation time. To override the values in an APK, specify build_config_values or build_config_values_file in android_binary(). values_file: Optional path to a file that defines additional fields (and values) that should be declared in the generated BuildConfig.java file. Like DEBUG, the values will be non-constant-expressions that evaluate to the value specified in the file at compilation time. To override the values in an APK, specify build_config_values or build_config_values_file in android_binary(). Note that values_file can be a generated file, as can build_config_values_file as demonstrated in the example below. Details​ The fields in the generated BuildConfig class will be non-constant-expressions (see JLS 15.28). However, if BuildConfig is packaged into an APK, it will be replaced with a new version where: The fields will be set to literal values (i.e., constant expressions).The boolean BuildConfig.DEBUG field will correspond to that of the package_type argument to the android_binary() rule that is packaging it. This transformation is done before ProGuard is applied (if applicable), so that it can propagate constants from BuildConfig and eliminate dead code. Examples: Here is an example of an android_build_config() rule that is transitively included by both debug and release versions of an android_binary() rule. The value of com.example.pkg.BuildConfig.DEBUG will be different in each APK even though they both transitively depend on the same :build_config rule.  android_build_config( name = 'build_config', package = 'com.example.pkg', values = [ 'String COMMIT_ID = &quot;0000000000000000000000000000000000000000&quot;', ], ) # The .java files in this library may contain references to the boolean # com.example.pkg.BuildConfig.DEBUG because :build_config is in the deps. # It could also reference BuildConfig.COMMIT_ID. android_library( name = 'mylib', srcs = glob(['src/**/*.java']), deps = [ ':build_config', ], ) android_binary( name = 'debug', package_type = 'DEBUG', keystore = '//keystores:debug', manifest = 'AndroidManifest.xml', target = 'Google Inc.:Google APIs:19', deps = [ ':mylib', ], ) # The contents of the file generated by this rule might be: # # String COMMIT_ID = &quot;7bf804bdf71fdbfc99cce3b155b3643f022c6fa4&quot; # # Note that the output of :build_config_release_values will be cached by Buck. # Assuming that generate_release_build_config.py depends on state that is not # expressed by its deps (which violates a fundamental invariant in Buck!), a # workaround is to ensure that the inputs to :build_config_release_values are # changed in some way before :release is built to ensure that the output from # :build_config_release_values is not pulled from cache. For example: # # $ buck build :release # $ uuidgen &gt; dummy_state_file.txt # $ buck build :release # # This makes sure that generate_release_build_config.py is re-run before # :release is rebuilt. This is much cheaper than deleting your build cache # before rebuilding. genrule( name = 'build_config_release_values', srcs = [ 'generate_release_build_config.py', 'dummy_state_file.txt' ], bash = 'generate_release_build_config.py $OUT', out = 'build_config_release_values.txt', ) android_binary( name = 'release', package_type = 'RELEASE', keystore = '//keystores:release', manifest = 'AndroidManifest.xml', target = 'Google Inc.:Google APIs:19', build_config_values_file = ':build_config_release_values', deps = [ ':mylib', ], )   "},{"title":"android_bundle​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_bundle","content":"def android_bundle( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _dex_toolchain: str = _, _exec_os_type: str = _, _is_building_android_binary: bool = _, _is_force_single_cpu: bool = _, _is_force_single_default_cpu: bool = _, _java_toolchain: str = _, aapt2_keep_raw_values: bool = _, aapt2_locale_filtering: bool = _, aapt2_preferred_density: None | str = _, aapt_mode: str = _, additional_aapt_params: list[str] = _, allow_r_dot_java_in_secondary_dex: bool = _, allowed_duplicate_resource_types: list[str] = _, android_sdk_proguard_config: None | str = _, application_module_blacklist: None | list[str] = _, application_module_configs: dict[str, list[str]] = _, application_module_dependencies: None | dict[str, list[str]] = _, asset_compression_algorithm: None | str = _, banned_duplicate_resource_types: list[str] = _, buck2_compatibility: str = _, build_config_values: list[str] = _, build_config_values_file: None | str = _, build_string_source_map: bool = _, bundle_config_file: None | str = _, compress_asset_libraries: bool = _, contacts: list[str] = _, cpu_filters: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, dex_compression: None | str = _, dex_group_lib_limit: int = _, dex_tool: str = _, disable_pre_dex: bool = _, duplicate_resource_behavior: str = _, duplicate_resource_whitelist: None | str = _, enable_relinker: bool = _, exopackage_modes: list[str] = _, extra_filtered_resources: list[str] = _, extra_no_compress_asset_extensions: list[str] = _, field_ref_count_buffer_space: int = _, ignore_aapt_proguard_config: bool = _, includes_vector_drawables: bool = _, is_cacheable: bool = _, is_voltron_language_pack_enabled: bool = _, keystore: str, labels: list[str] = _, licenses: list[str] = _, linear_alloc_hard_limit: int = _, locales: list[str] = _, manifest: None | str = _, manifest_entries: dict[str, typing.Any] = _, manifest_skeleton: None | str = _, method_ref_count_buffer_space: int = _, min_sdk_version: None | int = _, minimize_primary_dex_size: bool = _, module_manifest_skeleton: None | str = _, native_library_merge_code_generator: None | str = _, native_library_merge_glue: None | str = _, native_library_merge_linker_args: None | dict[str, list[str]] = _, native_library_merge_localized_symbols: None | list[str] = _, native_library_merge_map: None | dict[str, list[str]] = _, native_library_merge_sequence: None | list[typing.Any] = _, native_library_merge_sequence_blocklist: None | list[str] = _, no_auto_add_overlay_resources: bool = _, no_auto_version_resources: bool = _, no_dx: list[str] = _, no_version_transitions_resources: bool = _, optimization_passes: int = _, package_asset_libraries: bool = _, package_type: str = _, packaged_locales: list[str] = _, packaging_options: dict[str, list[str]] = _, post_filter_resources_cmd: None | str = _, preprocess_java_classes_bash: None | str = _, preprocess_java_classes_cmd: None | str = _, preprocess_java_classes_deps: list[str] = _, primary_dex_patterns: list[str] = _, proguard_config: None | str = _, proguard_jvm_args: list[str] = _, relinker_extra_deps: list[str] = _, relinker_whitelist: list[str] = _, resource_compression: str = _, resource_filter: list[str] = _, resource_stable_ids: None | str = _, resource_union_package: None | str = _, secondary_dex_weight_limit: None | int = _, skip_crunch_pngs: None | bool = _, skip_proguard: bool = _, trim_resource_ids: bool = _, use_derived_apk: bool = _, use_split_dex: bool = _, validation_deps: list[str] = _, xz_compression_level: int = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"android_instrumentation_apk​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_instrumentation_apk","content":"def android_instrumentation_apk( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _dex_toolchain: str = _, _exec_os_type: str = _, _is_building_android_binary: bool = _, _is_force_single_cpu: bool = _, _is_force_single_default_cpu: bool = _, _java_toolchain: str = _, aapt_mode: str = _, apk: str, buck2_compatibility: str = _, contacts: list[str] = _, cpu_filters: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, dex_tool: str = _, disable_pre_dex: bool = _, includes_vector_drawables: bool = _, is_self_instrumenting: bool = _, labels: list[str] = _, licenses: list[str] = _, manifest: None | str = _, manifest_skeleton: None | str = _, min_sdk_version: None | int = _, native_library_merge_map: None | dict[str, list[str]] = _, native_library_merge_sequence: None | list[typing.Any] = _, preprocess_java_classes_bash: None | str = _, preprocess_java_classes_cmd: None | str = _, preprocess_java_classes_deps: list[str] = _, primary_dex_patterns: list[str] = _, use_split_dex: None | bool = _ ) -&gt; None  An android_instrumentation_apk() rule is used to generate an Android Instrumentation APK. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one Details​ Android's Testing Fundamentals documentation includes a diagram that shows the relationship between an &quot;application package&quot; and a &quot;test package&quot; when running a test. This rule corresponds to a test package. Note that a test package has an interesting quirk where it is compiled against an application package, but must not include the resources or Java classes of the application package. Therefore, this class takes responsibility for making sure the appropriate bits are excluded. Failing to do so will generate mysterious runtime errors when running the test. Examples: Here is an example of an android_instrumentation_apk() rule that tests an android_binary(), and depends on a test package.  android_library( name = 'test', srcs = glob(['test/**/*.java']), ) android_binary( name = 'messenger', manifest = 'AndroidManifest.xml', keystore = '//keystores:prod', package_type = 'release', proguard_config = 'proguard.cfg', deps = [ ... ], ) # Building this rule will produce a file named messenger_test.apk android_instrumentation_apk( name = 'messenger_test', manifest = 'AndroidInstrumentationManifest.xml', apk = ':messenger', deps = [ ':test', ], )   "},{"title":"android_instrumentation_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_instrumentation_test","content":"def android_instrumentation_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _exec_os_type: str = _, _inject_test_env: str = _, _java_test_toolchain: str = _, _java_toolchain: str = _, apk: str, buck2_compatibility: str = _, clear_package_data: bool = _, collect_tombstones: bool = _, contacts: list[str] = _, default_host_platform: None | str = _, disable_animations: bool = _, env: dict[str, str] = _, extra_instrumentation_args: None | dict[str, str] = _, instrumentation_test_listener: None | str = _, instrumentation_test_listener_class: None | str = _, is_self_instrumenting: bool = _, labels: list[str] = _, licenses: list[str] = _, log_extractors: dict[str, str] = _, re_caps: None | dict[str, dict[str, str]] = _, re_use_case: None | dict[str, str] = _, record_video: bool = _, test_rule_timeout_ms: None | int = _ ) -&gt; None  An android_instrumentation_test() rule is used to define apks that should be used to run Android instrumentation tests. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneapk: The APK containing the tests. Can be an android_binary(), an apk_genrule() or an android_instrumentation_apk().clear_package_data: Runs pm clear on the app and test packages before the test run if set to True.collect_tombstones: Checks whether the test generated any tombstones, and downloads them from the emulator if true.disable_animations: Disables animations on the emulator if set to True.labels: A list of labels to be applied to these tests. These labels are arbitrary text strings and have no meaning within buck itself. They can, however, have meaning for you as a test author (e.g., smoke or fast). A label can be used to filter or include a specific test rule when executing buck testrecord_video: Record video of test run and collect it as TRAtest_rule_timeout_ms: If set specifies the maximum amount of time (in milliseconds) in which all of the tests in this rule should complete. This overrides the default rule_timeout if any has been specified in .buckconfig . Details​ Examples: Here is an example of an android_instrumentation_test()rule that tests an android_binary().  android_binary( name = 'messenger', manifest = 'AndroidManifest.xml', keystore = '//keystores:prod', package_type = 'release', proguard_config = 'proguard.cfg', deps = [ ... ], ) android_instrumentation_apk( name = 'messenger_test', manifest = 'AndroidInstrumentationManifest.xml', apk = ':messenger', deps = [ ... ], ) android_instrumentation_test( name = 'messenger_instrumentation_test', apk = ':messenger_test', )   "},{"title":"android_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_library","content":"def android_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _compose_stability_config: None | str = _, _dex_min_sdk_version: None | int = _, _dex_toolchain: str = _, _exec_os_type: str = _, _is_building_android_binary: bool = _, _java_toolchain: str = _, _kotlin_toolchain: str = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, abi_generation_mode: None | str = _, android_optional_jars: None | list[str] = _, annotation_processing_tool: None | str = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, exported_deps: list[str] = _, exported_provided_deps: list[str] = _, extra_arguments: list[str] = _, extra_kotlinc_arguments: list[str] = _, friend_paths: list[str] = _, incremental: bool = _, jar_postprocessor: None | str = _, java_version: None | str = _, javac: None | str = _, k2: bool = _, kotlin_compiler_plugins: dict[str, dict[str, str]] = _, labels: list[str] = _, language: None | str = _, licenses: list[str] = _, manifest: None | str = _, manifest_file: None | str = _, maven_coords: None | str = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, plugins: list[str] = _, proguard_config: None | str = _, provided_deps: list[str] = _, provided_deps_query: None | str = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resource_union_package: None | str = _, resources: list[str] = _, resources_root: None | str = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, srcs: list[str] = _, target: None | str = _, use_jvm_abi_gen: None | bool = _, validation_deps: list[str] = _ ) -&gt; None  An android_library() rule is used to define a set of Java files that can be compiled together against the Android SDK. The main output of an android_library() rule is a single JAR file containing all of the compiled class files and resources. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one annotation_processing_tool: Specifies the tool to use for annotation processing. Possible values: &quot;kapt&quot; or &quot;javac&quot;. &quot;kapt&quot; allows running Java annotation processors against Kotlin sources while backporting it for Java sources too. &quot;javac&quot; works only against Java sources, Kotlin sources won't have access to generated classes at compile time. deps: Rules (usually other android_library rules) that are used to generate the classpath required to compile this android_library. exported_deps: Other rules that depend on this rule will also include its exported_deps in their classpaths. This is useful when the public API of a rule has return types or checked exceptions that are defined in another rule, which would otherwise require callers to add an extra dependency. It's also useful for exposing e.g. a collection of prebuilt_jar rules as a single target for callers to depend on. Targets in exported_deps are implicitly included in the deps of this rule, so they don't need to be repeated there. exported_provided_deps: This is a combination of provided_deps and exported_deps. Rules listed in this parameter will be added to classpath of rules that depend on this rule, but they will not be included in a binary if binary depends on a such target. extra_arguments: List of additional arguments to pass into the Java compiler. These arguments follow the ones specified in .buckconfig. extra_kotlinc_arguments: List of additional arguments to pass into the Kotlin compiler. incremental: Enables Kotlin incremental compilation. k2: Enables the Kotlin K2 compiler. manifest: An optional Android Manifest for the to declare any permissions or intents it may need or want to handle. May either be a file or an android_manifest() target. provided_deps: These represent dependencies that are known to be provided at run time, but are required in order for the code to compile. Examples of provided_deps include the JEE servlet APIs. When this rule is included in a , the provided_deps will not be packaged into the output. provided_deps_query: Status: experimental/unstable. The provided deps query functions in the same way as the deps query, but the referenced deps using $declared are the provided deps of the target, and the results of the query are appended to the declared provided deps. remove_classes: List of classes to remove from the output jar. It only removes classes from the target's own sources, not from any of its dependencies. required_for_source_only_abi: Indicates that this rule must be present on the classpath during source-only ABI generation of any rule that depends on it. Typically this is done when a rule contains annotations, enums, constants, or interfaces. Having rules present on the classpath during source-only ABI generation prevents Buck from completely flattening the build graph, thus reducing the performance win from source-only ABI generation. These rules should be kept small (ideally just containing annotations, constants, enums, and interfaces) and with minimal dependencies of their own. resources: Static files to include among the compiled .class files. These files can be loaded via Class.getResource(). Note: Buck uses the src_roots property in.buckconfigto help determine where resources should be placed within the generated JAR file. source: Specifies the version of Java (as a string) to interpret source files as. Overrides the value in &quot;source_level&quot; in the &quot;java&quot; section of .buckconfig. source_only_abi_deps: These are dependencies that must be present during source-only ABI generation. Typically such dependencies are added when some property of the code in this rule prevents source-only ABI generation from being correct without these dependencies being present. Having source_only_abi_deps prevents Buck from completely flattening the build graph, thus reducing the performance win from source-only ABI generation. They should be avoided when possible. Often only a small code change is needed to avoid them. For more information on such code changes, read aboutsource-only ABI generation. srcs: The set of .java files to compile for this rule. target: Specifies the version of Java (as a string) for which to generate code. Overrides the value in &quot;target_level&quot; in the &quot;java&quot; section of .buckconfig. Details​ Examples: An android_library rule used in concert with anandroid_resource() rule. This would be a common arrangement for a standard Android Library project as defined byhttp://developer.android.com/tools/projects/index.html  android_resource( name = 'res', res = 'res', package = 'com.example', ) android_library( name = 'my_library', srcs = glob(['src/**/*.java']), deps = [ ':res', ], )   "},{"title":"android_manifest​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_manifest","content":"def android_manifest( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, skeleton: str ) -&gt; None  An android_manifest() rule is used to generate an Android Manifest to be used by android_binary() and android_aar() rules. This rule takes a skeleton manifest, and merges it with manifests found in any deps. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onedeps: A collection of dependencies that includes android_library rules. The manifest files of the android_library() rules will be filtered out to become dependent source files for the manifest.skeleton: Either a build target or a path to a file representing the manifest that will be merged with any manifests associated with this rule's deps. Details​ Examples: Here's an example of an android_manifest() that has no deps.  android_manifest( name = 'my-manifest', skeleton = 'AndroidManifestSkeleton.xml', )  This is what AndroidManifestSkeleton.xml looks like.  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot;&gt; &lt;uses-sdk targetSdkVersion=&quot;19&quot; minSdkVersion=&quot;17&quot;/&gt; &lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt; &lt;activity android:name=&quot;MyActivity&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt;  You could also use a genrule() to generate the manifest file and reference thebuild target in the skeleton argument.  "},{"title":"android_platform​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_platform","content":"def android_platform( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, base_platform: str, buck2_compatibility: str = _, native_platforms: dict[str, str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"android_prebuilt_aar​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_prebuilt_aar","content":"def android_prebuilt_aar( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _dex_min_sdk_version: None | int = _, _dex_toolchain: str = _, _exec_os_type: str = _, _java_toolchain: str = _, aar: str, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, desugar_deps: list[str] = _, for_primary_apk: bool = _, javadoc_url: None | str = _, labels: list[str] = _, licenses: list[str] = _, maven_coords: None | str = _, required_for_source_only_abi: bool = _, source_jar: None | str = _, use_system_library_loader: bool = _ ) -&gt; None  An android_prebuilt_aar() rule takes an .aar file and makes it available as an Android dependency. As expected, an android_binary() that transitively depends on an android_prebuilt_aar() will include its contents in the generated APK. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneaar: Path to the .aar file. This may also be a build target to a rule (such as a genrule()) whose output is an .aar file.javadoc_url: URL to the Javadoc for the .class files in the aar.source_jar: Path to a JAR file that contains the .java files to create the .class in the aar. This is frequently provided for debugging purposes.use_system_library_loader: If this .aar file contains native prebuilt .so libraries and the Java code uses these libraries via a call to System.loadLibrary(), then many optimizations—such as exopackage, compression, or asset packaging—may not be compatible with these prebuilt libs. Setting this parameter to True causes all of these optimizations to skip the prebuilt .so files originating from this .aar file. The .so files will always be packaged directly into the main .apk. Details​ See the official Android documentation for details about the .aar format. Examples:  android_prebuilt_aar( name = 'play-services', aar = 'play-services-4.0.30.aar', source_jar = 'play-services-4.0.30-sources.jar', javadoc_url = 'file:///opt/android-sdk/extras/google/google_play_services/docs/reference', ) android_library( name = 'lib', # This Java code can compile against Play services and reference its resources. srcs = glob(['*.java']), deps = [ ':play-services' ], )   "},{"title":"android_resource​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#android_resource","content":"def android_resource( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _java_toolchain: str = _, allowlisted_locales: None | list[str] = _, assets: None | str | dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, has_whitelisted_strings: bool = _, labels: list[str] = _, licenses: list[str] = _, manifest: None | str = _, package: None | str = _, project_assets: None | str = _, project_res: None | str = _, res: None | str | dict[str, str] = _, resource_union: bool = _ ) -&gt; None  An android_resource() rule is used to bundle Android resources that are traditionally stored in res and assets directories. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onedeps: Other android_resource rules to include via -S when running aapt.manifest: An optional Android Manifest for the to declare any permissions or intents it may need or want to handle. May either be a file or an android_manifest() target.package: Java package for the R.java file that will be generated for these resources. Details​ The output of an android_resource() is an R.txt file generated via aapt --output-text-symbols. Examples: Most of the time, an android_resource rule defines only name, res, and package. By convention, such simple rules are often named res:  android_resource( name = 'res', res = subdir_glob([('res', '**')]), package = 'com.example', )   "},{"title":"apk_genrule​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apk_genrule","content":"def apk_genrule( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _exec_os_type: str = _, _genrule_toolchain: str = _, _java_toolchain: str = _, aab: None | str = _, always_print_stderr: bool = _, apk: None | str = _, bash: None | str = _, buck2_compatibility: str = _, cacheable: None | bool = _, cmd: None | str = _, cmd_exe: None | str = _, contacts: list[str] = _, default_host_platform: None | str = _, default_outs: None | list[str] = _, enable_sandbox: None | bool = _, environment_expansion_separator: None | str = _, is_cacheable: bool = _, keystore: None | str = _, labels: list[str] = _, licenses: list[str] = _, metadata_env_var: None | str = _, metadata_path: None | str = _, need_android_tools: bool = _, no_outputs_cleanup: bool = _, out: None | str = _, outs: None | dict[str, list[str]] = _, remote: None | bool = _, remote_execution_dependencies: list[dict[str, str]] = _, srcs: list[str] | dict[str, str] = _, type: str = _, use_derived_apk: bool = _, weight: None | int = _ ) -&gt; None  An apk_genrule() rule is used to post-process an APK. What separates an apk_genrule from a genrule is apk_genrules are known by BUCK to produce APKs, so commands like buck install or buck uninstall still work. Additionally, apk_genrule() rules can be inputs to other apk_genrule() rules. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one aab: The input android_binary() rule. The path to the AAB can be accessed with the $AAB shell variable. Only one of apk or aab can be provided. apk: The input android_binary() rule. The path to the APK can be accessed with the $APK shell variable. Only one of apk or aab can be provided. bash: A platform-specific version of the shell command parameter cmd. It runs on Linux and UNIX systems—including OSX—on which bash is installed. It has a higher priority than cmd. The bash argument is run with /usr/bin/env bash -c. It has access to the same set of macros and variables as the cmd argument. cmd: The shell command to run to generate the output file. It is the fallback for bash and cmd_exe arguments. The following environment variables are populated by Buck and available to the shell command. They are accessed using the syntax: ${&lt;variable&gt;} Example: ${SRCS} ${SRCS} A string expansion of the srcs argument delimited by the environment_expansion_separator argument where each element of srcs will be translated into a relative path. ${SRCDIR} The relative path to a directory to which sources are copied prior to running the command. ${OUT} The output file or directory for the genrule(). This variable will have whatever value is specified by the out argument if not using named outputs. If using named outputs, this variable will be the output directory. The value should be a valid filepath. The semantics of the shell command determine whether this filepath is treated as a file or a directory. If the filepath is a directory, then the shell command needs to create it if not using named outputs. Otherwise, it will be automatically created. All outputs (directories and files) must be readable, writable, and (in the case of directories) executable by the current user. The file or directory specified by this variable must always be written by this command. If not, the execution of this rule will be considered a failure, halting the build process. ${TMP} A temporary directory which can be used for intermediate results and will not be bundled into the output. cmd_exe: A platform-specific version of the shell command parameter cmd. It runs on Windows and has a higher priority than cmd. The cmd_exe argument is run with cmd.exe /v:off /c. It has access to the same set of macros and variables as the cmd argument. environment_expansion_separator: The delimiter between paths in environment variables, such as SRCS, that can contain multiple paths. It can be useful to specify this parameter if the paths could contain spaces. out: The name of the output file or directory. The complete path to this argument is provided to the shell command through the OUT environment variable. Only one of out or outs may be present. For an apk_genrule the output should be a '.apk' or '.aab' file. srcs: Either a list or a map of the source files which Buck makes available to the shell command at the path in the SRCDIR environment variable. If you specify a list, the source files are the names in the list. If you specify a map, the source files are made available as the names in the keys of the map, where the values of the map are the original source file names. weight: How many local slots these genrule should take when executing locally. Details​ Examples: Here is an example of a couple apk_genrule() open up an APK, do some super signing, and then zipalign that APK again.  # Building this rule will produce a file named messenger.apk. android_binary( name = 'messenger', manifest = 'AndroidManifest.xml', target = 'Google Inc.:Google APIs:16', keystore = '//keystores:prod', package_type = 'release', proguard_config = 'proguard.cfg', deps = [ ':res', ':src', ], ) apk_genrule( name = 'messenger_super_sign_unalign', apk = ':messenger', bash = '$(exe //java/com/facebook/sign:super_sign) --input $APK --output $OUT', cmd_exe = '$(exe //java/com/facebook/sign:super_sign) --input %APK% --output %OUT%', out = 'messenger_super_sign_unalign.apk', ) apk_genrule( name = 'messenger_super_sign', apk = ':messenger_super_sign_unalign', bash = '$ANDROID_HOME/tools/zipalign -f 4 $APK $OUT', cmd_exe = '%ANDROID_HOME%\\tools\\zipalign -f 4 %APK% %OUT%', out = 'messenger_super_sign.apk', )   "},{"title":"apple_asset_catalog​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_asset_catalog","content":"def apple_asset_catalog( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, app_icon: None | str = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, dirs: list[str] = _, labels: list[str] = _, launch_image: None | str = _, licenses: list[str] = _, skip_universal_resource_dedupe: bool = _ ) -&gt; None  An apple_asset_catalog() rule contains resources stored in Apple asset catalog directories. This rule does not have any output on its own and can be built only as a dependency (either direct or transitive) of an apple_bundle() rule, in which case all apple_asset_catalog() rules that the bundle rule depends on are merged and placed into the final output bundle together. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneapp_icon: An optional reference to a .appiconset containing a image set representing an application icon. (The extension itself should not be included.) This parameter may be specified at most once in a given apple_bundle's transitive dependencies.launch_image: An optional reference to a .launchimage containing a image set representing an application launch image. (The extension itself should not be included.) This parameter may be specified at most once in a given apple_bundle's transitive dependencies. Details​ Examples:  apple_asset_catalog( name = 'MyAssetCatalog', dirs = [ 'MyResources.xcassets', ], ) # A asset catalog with a app icon and launch image apple_asset_catalog( name = 'AssetCatalog', dirs = [ 'AssetCatalog.xcassets' ], app_icon = 'Icon', launch_image = 'LaunchImage', )   "},{"title":"apple_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_binary","content":"def apple_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _apple_toolchain: str = _, _apple_tools: str = _, _apple_xctoolchain: str = _, _apple_xctoolchain_bundle_id: str = _, _dsymutil_extra_flags: list[str], _enable_library_evolution: bool = _, _stripped_default: bool = _, allow_cache_upload: None | bool = _, attrs_validators: None | list[str] = _, binary_linker_flags: list[str] = _, bridging_header: None | str = _, buck2_compatibility: str = _, can_be_asset: None | bool = _, compiler_flags: list[str] = _, contacts: list[str] = _, cxx_runtime_type: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, defaults: dict[str, str] = _, deps: list[str] = _, devirt_enabled: bool = _, diagnostics: dict[str, str] = _, dist_thin_lto_codegen_flags: list[str] = _, enable_cxx_interop: bool = _, enable_distributed_thinlto: bool = _, enable_library_evolution: None | bool = _, entitlements_file: None | str = _, executable_name: None | str = _, exported_deps: list[str] = _, exported_header_style: str = _, exported_headers: list[str] | dict[str, str] = _, exported_lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, exported_lang_preprocessor_flags: dict[str, list[str]] = _, exported_linker_flags: list[str] = _, exported_platform_deps: list[(str, list[str])] = _, exported_platform_headers: list[(str, list[str] | dict[str, str])] = _, exported_platform_linker_flags: list[(str, list[str])] = _, exported_platform_preprocessor_flags: list[(str, list[str])] = _, exported_post_linker_flags: list[str] = _, exported_post_platform_linker_flags: list[(str, list[str])] = _, exported_preprocessor_flags: list[str] = _, extra_xcode_files: list[str] = _, extra_xcode_sources: list[str] = _, fat_lto: bool = _, focused_list_target: None | str = _, force_static: None | bool = _, frameworks: list[str] = _, header_namespace: None | str = _, header_path_prefix: None | str = _, headers: list[str] | dict[str, str] = _, headers_as_raw_headers_mode: None | str = _, import_obj_c_forward_declarations: bool = _, include_directories: list[str] = _, info_plist: None | str = _, info_plist_substitutions: dict[str, str] = _, labels: list[str] = _, lang_compiler_flags: dict[str, list[str]] = _, lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = _, lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, lang_preprocessor_flags: dict[str, list[str]] = _, libraries: list[str] = _, licenses: list[str] = _, link_execution_preference: None | str = _, link_group: None | str = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_group_public_deps_label: None | str = _, link_ordering: None | str = _, link_style: None | str = _, link_whole: None | bool = _, linker_extra_outputs: list[str] = _, linker_flags: list[str] = _, modular: bool = _, module_name: None | str = _, module_requires_cxx: bool = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, platform_linker_flags: list[(str, list[str])] = _, platform_preprocessor_flags: list[(str, list[str])] = _, platform_srcs: list[(str, list[str | (str, list[str])])] = _, post_linker_flags: list[str] = _, post_platform_linker_flags: list[(str, list[str])] = _, precompiled_header: None | str = _, prefer_stripped_objects: bool = _, preferred_linkage: str = _, prefix_header: None | str = _, preprocessor_flags: list[str] = _, propagated_target_sdk_version: None | str = _, public_include_directories: list[str] = _, public_system_include_directories: list[str] = _, raw_headers: list[str] = _, reexport_all_header_dependencies: None | bool = _, sanitizer_runtime_enabled: None | bool = _, sdk_modules: list[str] = _, serialize_debugging_options: bool = _, soname: None | str = _, srcs: list[str | (str, list[str])] = _, static_library_basename: None | str = _, stripped: None | bool = _, supported_platforms_regex: None | str = _, supports_merged_linking: None | bool = _, swift_compilation_mode: str = _, swift_compiler_flags: list[str] = _, swift_module_skip_function_bodies: bool = _, swift_package_name: None | str = _, swift_version: None | str = _, target_sdk_version: None | str = _, thin_lto: bool = _, use_submodules: bool = _, uses_cxx_explicit_modules: bool = _, uses_explicit_modules: bool = _, uses_modules: bool = _, validation_deps: list[str] = _ ) -&gt; None  An apple_binary() rule builds a native executable - such as an iOS or OSX app - from the supplied set of Objective-C/C++ source files and dependencies. It is similar to a cxx_binary() rule with which it shares many attributes. In addition to those common attributes, apple_binary() has a some additional attributes that are specific to binaries intended to be built using the Apple toolchain. Note, however, that apple_binary() and cxx_binary() differ in the way that they import header files, in order to better accommodate existing conventions. See the sections for the headers and exported_headers attributes for more details. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one allow_cache_upload: Whether to allow uploading the output of this rule to be uploaded to cache when the action is executed locally if the configuration allows (i.e. there is a cache configured and the client has permission to write to it). compiler_flags: Flags to use when compiling any of the above sources (which require compilation). entitlements_file: An optional name of a plist file to be embedded in the binary. Some platforms like iphonesimulator require this to run properly. exported_headers: The set of header files that are made available for inclusion to the source files in this target and all targets that transitively depend on this one. These should be specified as either a list of header files or a dictionary of header names to header files. The header names can contain forward slashes (/). If a list of header files is specified, the headers can be imported with #import &quot;$HEADER_PATH_PREFIX/$HEADER_NAME&quot; or, if a header file that belongs to the same rule is being imported, with #import &quot;$HEADER_NAME&quot;, where $HEADER_PATH_PREFIX is the value of the target's header_path_prefix attribute, and $HEADER_NAME is the filename of the header file. If a dictionary is specified, each header can be imported with #import &quot;$HEADER_NAME&quot;, where $HEADER_NAME is the key corresponding to this file. In this case, the header_path_prefix attribute is ignored. In either case, quotes in the import statements can be replaced with angle brackets. exported_linker_flags: Flags to add to the linker command line when the output from this rule, or the output from any rule that transitively depends on this rule, is used in a link operation. extra_xcode_files: When the project is generated, this is the list of files that will added to the project. Those files won't be added to the build phase &quot;Compile Sources&quot;. frameworks: A list of system frameworks that the code in this target uses. Each entry should be a path starting with $SDKROOT or $PLATFORM_DIR to denote that the rest of the path is relative to the root of the SDK used for the build or to the platform toolchain directory. header_path_prefix: A path prefix when including headers of this target. For example, headers from a library defined using apple_library( name = &quot;Library&quot;, headers = glob([&quot;**/*.h&quot;]), header_path_prefix = &quot;Lib&quot;, ) can be imported using following mapping Library/SubDir/Header1.h -&gt; Lib/Header1.h Library/Header2.h -&gt; Lib/Header2.h Defaults to the short name of the target. Can contain forward slashes (/), but cannot start with one. See headers for more information. headers: The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header names can contain forward slashes (/). If a list of header files is specified, the headers can be imported with #import &quot;$HEADER_PATH_PREFIX/$HEADER_NAME&quot; or #import &quot;$HEADER_NAME&quot;, where $HEADER_PATH_PREFIX is the value of the target's header_path_prefix attribute, and $HEADER_NAME is the filename of the header file. If a dictionary is specified, each header can be imported with #import &quot;$HEADER_NAME&quot;, where $HEADER_NAME is the key corresponding to this file. In this case, the header_path_prefix attribute is ignored. In either case, quotes in the import statements can be replaced with angle brackets. link_execution_preference: The execution preference for linking. Options are: any : No preference is set, and the link action will be performed based on buck2's executor configuration.full_hybrid : The link action will execute both locally and remotely, regardless of buck2's executor configuration (if the executor is capable of hybrid execution). The use_limited_hybrid setting of the hybrid executor is ignored.local : The link action will execute locally if compatible on current host platform.local_only : The link action will execute locally, and error if the current platform is not compatible.remote : The link action will execute remotely if a compatible remote platform exists, otherwise locally. The default is None, expressing that no preference has been set on the target itself. link_group_public_deps_label: Surface nodes with this label as &quot;public&quot; nodes in the main executable when linking with with link groups. link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared. linker_extra_outputs: Declares extra outputs that the linker emits. These identifiers can be used in $(output ...) macros in linker_flags to interpolate the output path into the linker command line. Useful for custom linkers that emit extra output files. linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library. platform_compiler_flags: Platform specific compiler flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when compiling the target's sources. See compiler_flags for more information. platform_linker_flags: Platform-specific linker flags. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use java.util.regex.Pattern syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule is used in a link operation. platform_srcs: Platform specific source files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of source files or a list of tuples of source files and a list of compilation flags to be preprocessed, compiled and assembled if the platform matches the regex. See srcs for more information. preprocessor_flags: Flags to use when preprocessing any of the above sources (which require preprocessing). srcs: The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the GCC documentation for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. '') or a tuple of a string specifying a source file and a list of compilation flags (e.g. ('', ['-Wall', '-Werror']) ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable). target_sdk_version: The minimum OS version that the library target should support, overriding the minimum set in .buckconfig. When set, Buck will automatically add flags to both Objective-C and Swift compilation that will allow the use of the new APIs without guarding code inside availability checks. Details​ Buck enables you to override components of the Apple toolchain with alternate tools, either from the Xcode search paths or from directories that you specify. See .buckconfigand .buckconfigfor more information. Examples:  apple_binary( name = 'MyBinary', deps = [ ':MyLibrary', '//Libraries:AnotherLibrary', ], preprocessor_flags = ['-fobjc-arc'], headers = [ 'MyHeader.h', ], srcs = [ 'MySource.m', ], frameworks = [ '$SDKROOT/System/Library/Frameworks/UIKit.framework', '$SDKROOT/System/Library/Frameworks/Foundation.framework', ], )   "},{"title":"apple_bundle​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_bundle","content":"def apple_bundle( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _apple_toolchain: str = _, _apple_tools: str = _, _apple_xctoolchain: str = _, _apple_xctoolchain_bundle_id: str = _, _bundling_cache_buster: None | str = _, _bundling_log_file_enabled: bool = _, _bundling_log_file_level: None | str = _, _code_signing_configuration: None | str = _, _codesign_entitlements: None | str = _, _codesign_identities_command_override: None | str = _, _codesign_type: None | str = _, _compile_resources_locally_override: None | bool = _, _dsymutil_extra_flags: list[str], _embed_provisioning_profile_when_adhoc_code_signing: None | bool = _, _fast_adhoc_signing_enabled_default: bool = _, _fast_provisioning_profile_parsing_enabled: bool = _, _incremental_bundling_enabled: bool = _, _info_plist_identify_build_system_default: bool = _, _profile_bundling_enabled: bool = _, _provisioning_profiles: str = _, _resource_bundle: None | str = _, _strict_provisioning_profile_search_default: bool = _, _use_entitlements_when_adhoc_code_signing: None | bool = _, asset_catalogs_compilation_options: dict[str, typing.Any] = _, binary: None | str = _, buck2_compatibility: str = _, bundle_type: None | str = _, codesign_flags: list[str] = _, codesign_identity: None | str = _, codesign_type: None | str = _, contacts: list[str] = _, copy_public_framework_headers: None | bool = _, debug_artifacts_validators: dict[str, (str, str)] = _, default_host_platform: None | str = _, default_platform: None | str = _, deps: list[str] = _, embed_provisioning_profile_when_adhoc_code_signing: bool = _, extension: str, fast_adhoc_signing_enabled: None | bool = _, ibtool_flags: None | list[str] = _, ibtool_module_flag: None | bool = _, incremental_bundling_enabled: None | bool = _, info_plist: str, info_plist_identify_build_system: None | bool = _, info_plist_substitutions: dict[str, str] = _, labels: list[str] = _, licenses: list[str] = _, module_map: None | str = _, platform_binary: None | list[(str, str)] = _, privacy_manifest: None | str = _, product_name: None | str = _, propagated_target_sdk_version: None | str = _, provisioning_profile_filter: None | str = _, resource_group: None | str = _, resource_group_map: None | str = _, selective_debugging: None | str = _, skip_copying_swift_stdlib: None | bool = _, split_arch_dsym: bool = _, strict_provisioning_profile_search: None | bool = _, try_skip_code_signing: None | bool = _, universal: None | bool = _, use_entitlements_when_adhoc_code_signing: bool = _, validation_deps: list[str] = _, versioned_macos_bundle: bool = _, xcode_product_type: None | str = _ ) -&gt; None  An apple_bundle() rule takes an Apple binary and all of the resources and asset catalogs in the rule's transitive dependencies and generates a bundle containing all of those files. Optionally the generated bundle can also be signed using specified provisioning profiles. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one asset_catalogs_compilation_options: A dict holding parameters for asset catalogs compiler (actool). Its options include: notices (defaults to True)warnings (defaults to True)errors (defaults to True)compress_pngs (defaults to True)optimization (defaults to 'space')output_format (defaults to 'human-readable-text')extra_flags (defaults to []) deps: A list of dependencies of this bundle as build targets. You can embed application extensions by specifying the extension's bundle target. To include a WatchKit app, append the flavor #watch to the target specification. Buck will automatically substitute the appropriate platform flavor (either watchsimulator or watchos) based on the parent. extension: The extension of the generated bundle. For example 'app' for an application bundle or 'appex' for an application extension bundle. ibtool_flags: List of flags to be passed to ibtool during interface builder file compilation. info_plist: A path to an Info.plist file that will be placed in the bundle. The specified file will be processed by substituting variable names with their values (see info_plist_substitutions for more information). info_plist_substitutions: A dictionary that assigns variable names to their values. It is used for variable substitution when processing the file specified in info_plist. For example if this argument is set to {'VAR': 'MyValue'}, then each occurrence of $(VAR) or ${VAR} in the file will be replaced by MyValue. privacy_manifest: A path to an .xcprivacy file that will be placed in the bundle. product_name: The name of the resulting bundle and binary. The setting behaves like PRODUCT_NAME Xcode build setting. For example, if your rule is named &quot;MyApp&quot; and extension is &quot;app&quot;, by default buck will generate MyApp.app bundle. But if you will set product name to &quot;SuperApp&quot;, bundle will get &quot;SuperApp.app&quot; name. Details​ Code signing will embed entitlements pointed to by the entitlements_file arg in the bundle's apple_binary. This is the preferred way to specify entitlements when building with Buck. If the entitlements file is not present, it falls back to the CODE_SIGN_ENTITLEMENTS entry ininfo_plist_substitutions. If after these checks, an entitlements file is still not specified, it will be derived based on the entitlements of the selected provisioning profile. Provisioning profiles will be selected from profiles pointed to by apple.provisioning_profile_search_path, based on a non-expired profile that matches the bundle id and entitlements. Code signing will embed entitlements pointed to by the CODE_SIGN_ENTITLEMENTS entry ininfo_plist_substitutions. If an entitlements file is omitted, it will be derived based on the entitlements of the selected provisioning profile. Provisioning profiles will be selected from profiles pointed to by apple.provisioning_profile_search_path, based on a non-expired profile that matches the bundle id and entitlements. Examples:  apple_bundle( name = 'AppBundle', binary = ':MyBinary', extension = 'app', info_plist = 'Info.plist', )   # iOS app with embedded WatchOS 2.0 app/extension apple_bundle( name = 'DemoWatchAppExtension', binary = ':DemoWatchAppExtensionBinary', extension = 'appex', info_plist = 'WatchExtension/Resources/Info.plist', ) apple_bundle( name = 'DemoWatchApp', binary = ':DemoWatchAppBinary', deps = [':DemoWatchAppResources', ':DemoWatchAppExtension'], extension = 'app', info_plist = 'WatchApplication/Info.plist', ) apple_bundle( name = 'DemoApp', binary = ':DemoAppBinary', deps = [':DemoWatchApp#watch'], extension = 'app', info_plist = 'Info.plist', )   # iOS app using safeAreaInsets delivering to iOS 9.x apple_bundle( name = 'DemoIBApp', binary = ':DemoIBAppBinary', deps = [':DemoIBAppResources'], extension = 'app', ibtool_flags = [&quot;--minimum-deployment-target&quot;, &quot;9.0&quot;], info_plist = 'Info.plist', )   "},{"title":"apple_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_library","content":"def apple_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _apple_toolchain: str = _, _apple_tools: str = _, _apple_xctoolchain: str = _, _apple_xctoolchain_bundle_id: str = _, _archive_objects_locally_override: None | bool = _, _dsymutil_extra_flags: list[str], _enable_library_evolution: bool = _, _stripped_default: bool = _, allow_cache_upload: None | bool = _, attrs_validators: None | list[str] = _, bridging_header: None | str = _, buck2_compatibility: str = _, can_be_asset: None | bool = _, compiler_flags: list[str] = _, contacts: list[str] = _, cxx_runtime_type: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, defaults: dict[str, str] = _, deps: list[str] = _, devirt_enabled: bool = _, diagnostics: dict[str, str] = _, dist_thin_lto_codegen_flags: list[str] = _, enable_cxx_interop: bool = _, enable_distributed_thinlto: bool = _, enable_library_evolution: None | bool = _, executable_name: None | str = _, exported_deps: list[str] = _, exported_header_style: str = _, exported_headers: list[str] | dict[str, str] = _, exported_lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, exported_lang_preprocessor_flags: dict[str, list[str]] = _, exported_linker_flags: list[str] = _, exported_platform_deps: list[(str, list[str])] = _, exported_platform_headers: list[(str, list[str] | dict[str, str])] = _, exported_platform_linker_flags: list[(str, list[str])] = _, exported_platform_preprocessor_flags: list[(str, list[str])] = _, exported_post_linker_flags: list[str] = _, exported_post_platform_linker_flags: list[(str, list[str])] = _, exported_preprocessor_flags: list[str] = _, extra_xcode_files: list[str] = _, extra_xcode_sources: list[str] = _, fat_lto: bool = _, focused_list_target: None | str = _, force_static: None | bool = _, frameworks: list[str] = _, header_mode: None | str = _, header_namespace: None | str = _, header_path_prefix: None | str = _, headers: list[str] | dict[str, str] = _, headers_as_raw_headers_mode: None | str = _, import_obj_c_forward_declarations: bool = _, include_directories: list[str] = _, info_plist: None | str = _, info_plist_substitutions: dict[str, str] = _, labels: list[str] = _, lang_compiler_flags: dict[str, list[str]] = _, lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = _, lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, lang_preprocessor_flags: dict[str, list[str]] = _, libraries: list[str] = _, licenses: list[str] = _, link_execution_preference: None | str = _, link_group: None | str = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_ordering: None | str = _, link_style: None | str = _, link_whole: None | bool = _, linker_extra_outputs: list[str] = _, linker_flags: list[str] = _, modular: bool = _, module_name: None | str = _, module_requires_cxx: bool = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, platform_linker_flags: list[(str, list[str])] = _, platform_preprocessor_flags: list[(str, list[str])] = _, platform_srcs: list[(str, list[str | (str, list[str])])] = _, post_linker_flags: list[str] = _, post_platform_linker_flags: list[(str, list[str])] = _, precompiled_header: None | str = _, preferred_linkage: str = _, prefix_header: None | str = _, preprocessor_flags: list[str] = _, propagated_target_sdk_version: None | str = _, public_framework_headers: list[str] | dict[str, str] = _, public_include_directories: list[str] = _, public_system_include_directories: list[str] = _, raw_headers: list[str] = _, reexport_all_header_dependencies: None | bool = _, sdk_modules: list[str] = _, serialize_debugging_options: bool = _, shared_library_macho_file_type: str = _, soname: None | str = _, srcs: list[str | (str, list[str])] = _, static_library_basename: None | str = _, stripped: None | bool = _, supported_platforms_regex: None | str = _, supports_header_symlink_subtarget: bool = _, supports_merged_linking: None | bool = _, supports_shlib_interfaces: bool = _, swift_compilation_mode: str = _, swift_compiler_flags: list[str] = _, swift_module_skip_function_bodies: bool = _, swift_package_name: None | str = _, swift_version: None | str = _, target_sdk_version: None | str = _, thin_lto: bool = _, use_archive: None | bool = _, use_submodules: bool = _, uses_cxx_explicit_modules: bool = _, uses_explicit_modules: bool = _, uses_modules: bool = _, validation_deps: list[str] = _ ) -&gt; None  An apple_library() rule represents a set of Objective-C/C++/Swift source files and is similar to a cxx_library() rule with which it shares many attributes. In addition to those common attributes, apple_library() has a some additional attributes that are specific to binaries intended to be built using the Apple toolchain. Note, however, that apple_library() and cxx_library() differ in the way that they import header files, in order to better accommodate existing conventions. See the sections for the headers and exported_headers attributes for more details. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one allow_cache_upload: Whether to allow uploading the output of this rule to be uploaded to cache when the action is executed locally if the configuration allows (i.e. there is a cache configured and the client has permission to write to it). compiler_flags: Flags to use when compiling any of the above sources (which require compilation). exported_deps: Dependencies that will also appear to belong to any rules that depend on this one. This has two effects: Exported dependencies will also be included in the link line of dependents of this rules, but normal dependencies will not. When reexport_all_header_dependencies = False, only exported headers of the rules specified here are re-exported. exported_headers: The set of header files that are made available for inclusion to the source files in this target and all targets that transitively depend on this one. These should be specified as either a list of header files or a dictionary of header names to header files. The header names can contain forward slashes (/). If a list of header files is specified, the headers can be imported with #import &quot;$HEADER_PATH_PREFIX/$HEADER_NAME&quot; or, if a header file that belongs to the same rule is being imported, with #import &quot;$HEADER_NAME&quot;, where $HEADER_PATH_PREFIX is the value of the target's header_path_prefix attribute, and $HEADER_NAME is the filename of the header file. If a dictionary is specified, each header can be imported with #import &quot;$HEADER_NAME&quot;, where $HEADER_NAME is the key corresponding to this file. In this case, the header_path_prefix attribute is ignored. In either case, quotes in the import statements can be replaced with angle brackets. exported_linker_flags: Flags to add to the linker command line when the output from this rule, or the output from any rule that transitively depends on this rule, is used in a link operation. exported_platform_linker_flags: Platform-specific linker flags for this rule and for all rules that transitively depend on this rule. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use java.util.regex.Pattern syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule, or the output from any rule that transitively depends on this rule, is used in a link operation. extra_xcode_files: When the project is generated, this is the list of files that will added to the project. Those files won't be added to the build phase &quot;Compile Sources&quot;. frameworks: A list of system frameworks that the code in this target uses. Each entry should be a path starting with $SDKROOT or $PLATFORM_DIR to denote that the rest of the path is relative to the root of the SDK used for the build or to the platform toolchain directory. header_namespace: A path prefix when including headers of this target. Defaults to the path from the root of the repository to the directory where this target is defined. Can contain forward slashes (/), but cannot start with one. See headers for more information. header_path_prefix: A path prefix when including headers of this target. For example, headers from a library defined using apple_library( name = &quot;Library&quot;, headers = glob([&quot;**/*.h&quot;]), header_path_prefix = &quot;Lib&quot;, ) can be imported using following mapping Library/SubDir/Header1.h -&gt; Lib/Header1.h Library/Header2.h -&gt; Lib/Header2.h Defaults to the short name of the target. Can contain forward slashes (/), but cannot start with one. See headers for more information. headers: The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header names can contain forward slashes (/). If a list of header files is specified, the headers can be imported with #import &quot;$HEADER_PATH_PREFIX/$HEADER_NAME&quot; or #import &quot;$HEADER_NAME&quot;, where $HEADER_PATH_PREFIX is the value of the target's header_path_prefix attribute, and $HEADER_NAME is the filename of the header file. If a dictionary is specified, each header can be imported with #import &quot;$HEADER_NAME&quot;, where $HEADER_NAME is the key corresponding to this file. In this case, the header_path_prefix attribute is ignored. In either case, quotes in the import statements can be replaced with angle brackets. link_execution_preference: The execution preference for linking. Options are: any : No preference is set, and the link action will be performed based on buck2's executor configuration.full_hybrid : The link action will execute both locally and remotely, regardless of buck2's executor configuration (if the executor is capable of hybrid execution). The use_limited_hybrid setting of the hybrid executor is ignored.local : The link action will execute locally if compatible on current host platform.local_only : The link action will execute locally, and error if the current platform is not compatible.remote : The link action will execute remotely if a compatible remote platform exists, otherwise locally. The default is None, expressing that no preference has been set on the target itself. link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared. linker_extra_outputs: Declares extra outputs that the linker emits. These identifiers can be used in $(output ...) macros in linker_flags to interpolate the output path into the linker command line. Useful for custom linkers that emit extra output files. linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library. platform_compiler_flags: Platform specific compiler flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when compiling the target's sources. See compiler_flags for more information. platform_srcs: Platform specific source files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of source files or a list of tuples of source files and a list of compilation flags to be preprocessed, compiled and assembled if the platform matches the regex. See srcs for more information. preprocessor_flags: Flags to use when preprocessing any of the above sources (which require preprocessing). reexport_all_header_dependencies: Whether to automatically re-export the exported headers of all dependencies. When this is set to false, only exported headers fromexported_deps are re-exported. srcs: The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the GCC documentation for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. '') or a tuple of a string specifying a source file and a list of compilation flags (e.g. ('', ['-Wall', '-Werror']) ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable). target_sdk_version: The minimum OS version that the library target should support, overriding the minimum set in .buckconfig. When set, Buck will automatically add flags to both Objective-C and Swift compilation that will allow the use of the new APIs without guarding code inside availability checks. Details​ Buck enables you to override components of the Apple toolchain with alternate tools, either from the Xcode search paths or from directories that you specify. See .buckconfigand .buckconfigfor more information. Examples:  apple_library( name = 'MyLibrary', deps = [ ':OtherLibrary', '//Libraries:YetAnotherLibrary', ], preprocessor_flags = ['-fobjc-arc'], headers = [ 'MyHeader.h', ], srcs = [ 'MySource.m', 'MySource.swift', ], frameworks = [ '$SDKROOT/System/Library/Frameworks/UIKit.framework', '$SDKROOT/System/Library/Frameworks/Foundation.framework', ], )   "},{"title":"apple_package​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_package","content":"def apple_package( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _apple_tools: str = _, _ipa_compression_level: str, _ipa_package: str, buck2_compatibility: str = _, bundle: str, contacts: list[str] = _, default_host_platform: None | str = _, default_platform: None | str = _, ext: str = _, labels: list[str] = _, licenses: list[str] = _, need_android_tools: bool = _, package_name: None | str = _, packager: None | str = _, packager_args: list[str] = _, prepackaged_validators: list[str | (str, list[str])] = _ ) -&gt; None  An apple_package() rule takes the output of an apple_bundle() rule and compresses it in an IPA (iOS App Store Package) file. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one Details​ This rule can be customized using the config options .buckconfigand .buckconfig. Examples:  apple_package( name = 'AppPackage', bundle = ':AppBundle', )   "},{"title":"apple_resource​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_resource","content":"def apple_resource( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, codesign_entitlements: None | str = _, codesign_flags_override: None | list[str] = _, codesign_on_copy: bool = _, contacts: list[str] = _, content_dirs: list[str] = _, default_host_platform: None | str = _, destination: None | str = _, dirs: list[str] = _, files: list[str] = _, labels: list[str] = _, licenses: list[str] = _, named_variants: dict[str, list[str]] = _, resources_from_deps: list[str] = _, skip_universal_resource_dedupe: bool = _, variants: list[str] = _ ) -&gt; None  An apple_resource() rule contains sets of resource directories, files and file variants that can be bundled in an application bundle. This rule does not have any output on its own and can be built only as a dependency (either direct or transitive) of an apple_bundle() rule. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one destination: Specifies the destination in the final application bundle where resource will be copied. Possible values: &quot;resources&quot;, &quot;frameworks&quot;, &quot;executables&quot;, &quot;plugins&quot;, &quot;xpcservices&quot;. named_variants: Mapping from a variant name to the list of resource file paths which should be placed in an application bundle. Those files will be placed in a directory with name equal to the corresponding key in this mapping. Keys should end with .lproj suffix. (e.g. Base.lproj, en.lproj). resources_from_deps: Set of build targets whose transitive apple_resources should be considered as part of the current resource when collecting resources for bundles. Usually, an apple_bundle collects all apple_resource rules transitively reachable through apple_library rules. This field allows for resources which are not reachable using the above traversal strategy to be considered for inclusion in the bundle. variants: Set of paths of resource file variants that should be placed in an application bundle. The files mentioned here should be placed in a directory named $VARIANT_NAME.lproj, where $VARIANT_NAME is the name of the variant (e.g. Base, en). This argument makes it possible to use different resource files based on the active locale. Details​ Examples:  apple_resource( name = 'Images', files = glob([ '*.png', ]), dirs = [ 'PrettyImages', ], )   "},{"title":"apple_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_test","content":"def apple_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _apple_toolchain: str = _, _apple_tools: str = _, _apple_xctoolchain: str = _, _apple_xctoolchain_bundle_id: str = _, _bundling_cache_buster: None | str = _, _bundling_log_file_enabled: bool = _, _bundling_log_file_level: None | str = _, _code_signing_configuration: None | str = _, _codesign_identities_command_override: None | str = _, _codesign_type: None | str = _, _compile_resources_locally_override: None | bool = _, _dsymutil_extra_flags: list[str], _embed_provisioning_profile_when_adhoc_code_signing: None | bool = _, _enable_library_evolution: bool = _, _fast_adhoc_signing_enabled_default: bool = _, _fast_provisioning_profile_parsing_enabled: bool = _, _incremental_bundling_enabled: bool = _, _info_plist_identify_build_system_default: bool = _, _inject_test_env: str = _, _ios_booted_simulator: str = _, _ios_unbooted_simulator: str = _, _macos_idb_companion: str = _, _profile_bundling_enabled: bool = _, _provisioning_profiles: str = _, _resource_bundle: None | str = _, _strict_provisioning_profile_search_default: bool = _, _use_entitlements_when_adhoc_code_signing: None | bool = _, allow_cache_upload: None | bool = _, asset_catalogs_compilation_options: dict[str, typing.Any] = _, attrs_validators: None | list[str] = _, binary: None | str = _, bridging_header: None | str = _, buck2_compatibility: str = _, can_be_asset: None | bool = _, codesign_flags: list[str] = _, codesign_identity: None | str = _, codesign_type: None | str = _, compiler_flags: list[str] = _, contacts: list[str] = _, cxx_runtime_type: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, defaults: dict[str, str] = _, deps: list[str] = _, destination_specifier: dict[str, str] = _, devirt_enabled: bool = _, diagnostics: dict[str, str] = _, embed_provisioning_profile_when_adhoc_code_signing: bool = _, enable_cxx_interop: bool = _, enable_library_evolution: None | bool = _, entitlements_file: None | str = _, env: None | dict[str, str] = _, executable_name: None | str = _, exported_deps: list[str] = _, exported_header_style: str = _, exported_headers: list[str] | dict[str, str] = _, exported_lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, exported_lang_preprocessor_flags: dict[str, list[str]] = _, exported_linker_flags: list[str] = _, exported_platform_deps: list[(str, list[str])] = _, exported_platform_headers: list[(str, list[str] | dict[str, str])] = _, exported_platform_linker_flags: list[(str, list[str])] = _, exported_platform_preprocessor_flags: list[(str, list[str])] = _, exported_post_linker_flags: list[str] = _, exported_post_platform_linker_flags: list[(str, list[str])] = _, exported_preprocessor_flags: list[str] = _, extension: str, extra_xcode_files: list[str] = _, extra_xcode_sources: list[str] = _, fast_adhoc_signing_enabled: None | bool = _, fat_lto: bool = _, focused_list_target: None | str = _, force_static: None | bool = _, frameworks: list[str] = _, header_namespace: None | str = _, header_path_prefix: None | str = _, headers: list[str] | dict[str, str] = _, headers_as_raw_headers_mode: None | str = _, import_obj_c_forward_declarations: bool = _, include_directories: list[str] = _, incremental_bundling_enabled: None | bool = _, info_plist: str, info_plist_identify_build_system: None | bool = _, info_plist_substitutions: dict[str, str] = _, is_ui_test: bool = _, labels: list[str] = _, lang_compiler_flags: dict[str, list[str]] = _, lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = _, lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, lang_preprocessor_flags: dict[str, list[str]] = _, libraries: list[str] = _, licenses: list[str] = _, link_execution_preference: None | str = _, link_group: None | str = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_ordering: None | str = _, link_style: str = _, link_whole: None | bool = _, linker_extra_outputs: list[str] = _, linker_flags: list[str] = _, modular: bool = _, module_name: None | str = _, module_requires_cxx: bool = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, platform_linker_flags: list[(str, list[str])] = _, platform_preprocessor_flags: list[(str, list[str])] = _, platform_srcs: list[(str, list[str | (str, list[str])])] = _, post_linker_flags: list[str] = _, post_platform_linker_flags: list[(str, list[str])] = _, precompiled_header: None | str = _, preferred_linkage: str = _, prefix_header: None | str = _, preprocessor_flags: list[str] = _, propagated_target_sdk_version: None | str = _, provisioning_profile_filter: None | str = _, public_include_directories: list[str] = _, public_system_include_directories: list[str] = _, raw_headers: list[str] = _, reexport_all_header_dependencies: None | bool = _, resource_group: None | str = _, resource_group_map: None | str = _, run_test_separately: bool = _, runner: None | str = _, sanitizer_runtime_enabled: None | bool = _, sdk_modules: list[str] = _, serialize_debugging_options: bool = _, skip_copying_swift_stdlib: None | bool = _, snapshot_reference_images_path: None | str = _, soname: None | str = _, specs: None | str = _, srcs: list[str | (str, list[str])] = _, static_library_basename: None | str = _, strict_provisioning_profile_search: None | bool = _, stripped: bool = _, supported_platforms_regex: None | str = _, supports_merged_linking: None | bool = _, swift_compilation_mode: str = _, swift_compiler_flags: list[str] = _, swift_module_skip_function_bodies: bool = _, swift_package_name: None | str = _, swift_version: None | str = _, target_sdk_version: None | str = _, test_host_app: None | str = _, test_re_capabilities: None | dict[str, str] = _, test_re_use_case: None | str = _, test_rule_timeout_ms: None | int = _, thin_lto: bool = _, try_skip_code_signing: None | bool = _, ui_test_target_app: None | str = _, use_entitlements_when_adhoc_code_signing: bool = _, use_submodules: bool = _, uses_cxx_explicit_modules: bool = _, uses_explicit_modules: bool = _, uses_modules: bool = _, validation_deps: list[str] = _, versioned_macos_bundle: bool = _, xcode_product_type: None | str = _ ) -&gt; None  An apple_test() rule contains Objective-C/C++ code which can be built and used to test code contained in other rules. The tests can be executed by running buck test. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one allow_cache_upload: Whether to allow uploading the output of this rule to be uploaded to cache when the action is executed locally if the configuration allows (i.e. there is a cache configured and the client has permission to write to it). compiler_flags: Flags to use when compiling any of the above sources (which require compilation). extra_xcode_files: When the project is generated, this is the list of files that will added to the project. Those files won't be added to the build phase &quot;Compile Sources&quot;. frameworks: A list of system frameworks that the code in this target uses. Each entry should be a path starting with $SDKROOT or $PLATFORM_DIR to denote that the rest of the path is relative to the root of the SDK used for the build or to the platform toolchain directory. header_path_prefix: A path prefix when including headers of this target. For example, headers from a library defined using apple_library( name = &quot;Library&quot;, headers = glob([&quot;**/*.h&quot;]), header_path_prefix = &quot;Lib&quot;, ) can be imported using following mapping Library/SubDir/Header1.h -&gt; Lib/Header1.h Library/Header2.h -&gt; Lib/Header2.h Defaults to the short name of the target. Can contain forward slashes (/), but cannot start with one. See headers for more information. headers: The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header names can contain forward slashes (/). If a list of header files is specified, the headers can be imported with #import &quot;$HEADER_PATH_PREFIX/$HEADER_NAME&quot; or #import &quot;$HEADER_NAME&quot;, where $HEADER_PATH_PREFIX is the value of the target's header_path_prefix attribute, and $HEADER_NAME is the filename of the header file. If a dictionary is specified, each header can be imported with #import &quot;$HEADER_NAME&quot;, where $HEADER_NAME is the key corresponding to this file. In this case, the header_path_prefix attribute is ignored. In either case, quotes in the import statements can be replaced with angle brackets. info_plist: A path to an Info.plist file that will be placed in the bundle. The specified file will be processed by substituting variable names with their values (see info_plist_substitutions for more information). info_plist_substitutions: A dictionary that assigns variable names to their values. It is used for variable substitution when processing the file specified in info_plist. For example if this argument is set to {'VAR': 'MyValue'}, then each occurrence of $(VAR) or ${VAR} in the file will be replaced by MyValue. labels: A list of labels to be applied to these tests. These labels are arbitrary text strings and have no meaning within buck itself. They can, however, have meaning for you as a test author (e.g., smoke or fast). A label can be used to filter or include a specific test rule when executing buck test link_execution_preference: The execution preference for linking. Options are: any : No preference is set, and the link action will be performed based on buck2's executor configuration.full_hybrid : The link action will execute both locally and remotely, regardless of buck2's executor configuration (if the executor is capable of hybrid execution). The use_limited_hybrid setting of the hybrid executor is ignored.local : The link action will execute locally if compatible on current host platform.local_only : The link action will execute locally, and error if the current platform is not compatible.remote : The link action will execute remotely if a compatible remote platform exists, otherwise locally. The default is None, expressing that no preference has been set on the target itself. linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library. platform_compiler_flags: Platform specific compiler flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when compiling the target's sources. See compiler_flags for more information. platform_srcs: Platform specific source files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of source files or a list of tuples of source files and a list of compilation flags to be preprocessed, compiled and assembled if the platform matches the regex. See srcs for more information. preprocessor_flags: Flags to use when preprocessing any of the above sources (which require preprocessing). srcs: The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the GCC documentation for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. '') or a tuple of a string specifying a source file and a list of compilation flags (e.g. ('', ['-Wall', '-Werror']) ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable). target_sdk_version: The minimum OS version that the library target should support, overriding the minimum set in .buckconfig. When set, Buck will automatically add flags to both Objective-C and Swift compilation that will allow the use of the new APIs without guarding code inside availability checks. test_host_app: A build target identifying an apple_bundle() rule that builds an application bundle. Output of the specified rule will be used as a test host of this test. This implies run_test_separately. Since symbols that are defined in the test host application and its dependencies will not be linked into the test binary, to make those symbols accessible to the test target they need to be specified as a dependency of this target and ['-undefined', 'dynamic_lookup'] needs to be added to this target's linker_flags (this will suppress undefined reference errors during compilation, but if the symbols do not exist, it might result in runtime crashes). test_re_capabilities: An optional dictionary with the RE capabilities for the test execution. Overrides a default selection mechanism. test_re_use_case: An optional name of the RE use case for the test execution. Overrides a default selection mechanism. Details​ Examples:  apple_test( name = 'MyTest', info_plist = 'MyTest-Info.plist', preprocessor_flags = ['-fobjc-arc'], srcs = [ 'MyTest.m', ], deps = [ ':MyLibrary', ], frameworks = [ '$SDKROOT/System/Library/Frameworks/Foundation.framework', '$SDKROOT/System/Library/Frameworks/UIKit.framework', '$PLATFORM_DIR/Developer/Library/Frameworks/XCTest.framework', ], )   "},{"title":"apple_toolchain​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_toolchain","content":"def apple_toolchain( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _internal_platform_path: None | str = _, _internal_sdk_path: None | str = _, actool: str, architecture: str = _, buck2_compatibility: str = _, build_version: None | str = _, codesign: str, codesign_allocate: str, codesign_identities_command: None | str = _, compile_resources_locally: bool = _, contacts: list[str] = _, copy_scene_kit_assets: str, cxx_toolchain: str, default_host_platform: None | str = _, developer_path: None | str = _, dsymutil: str, dwarfdump: None | str = _, extra_linker_outputs: list[str] = _, ibtool: str, installer: str = _, labels: list[str] = _, libtool: str, licenses: list[str] = _, lipo: str, mapc: None | str = _, merge_index_store: str = _, min_version: str = _, momc: str, objdump: None | str = _, placeholder_tool: None | str = _, platform_path: None | str = _, requires_xcode_version_match: bool = _, sdk_environment: None | str = _, sdk_name: str = _, sdk_path: None | str = _, swift_toolchain: None | str = _, version: None | str = _, watch_kit_stub_binary: None | str = _, work_around_dsymutil_lto_stack_overflow_bug: None | bool = _, xcode_build_version: None | str = _, xcode_version: None | str = _, xctest: str ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"apple_toolchain_set​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_toolchain_set","content":"def apple_toolchain_set( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, apple_toolchains: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"apple_universal_executable​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_universal_executable","content":"def apple_universal_executable( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _apple_toolchain: str = _, _apple_tools: str = _, _dsymutil_extra_flags: list[str], buck2_compatibility: str = _, executable: str, executable_name: None | str = _, labels: list[str] = _, split_arch_dsym: bool = _, universal: None | bool = _ ) -&gt; None  An apple_universal_executable() rule takes a target via its binary attribute, builds it for multiple architectures and combines the result into a single binary using lipo. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one executable: A build target identifying the binary which will be built for multiple architectures. The target will be transitioned into different configurations, with distinct architectures. The target can be one of: apple_binary() and cxx_binary()[shared] subtarget of apple_library() and cxx_library()apple_library() and cxx_library() which have preferred_linkage = shared attribute executable_name: By default, the name of the universal executable is same as the name of the binary from the binary target attribute. Set executable_name to override the default. split_arch_dsym: If enabled, each architecture gets its own dSYM binary. Use this if the combined universal dSYM binary exceeds 4GiB. universal: Controls whether the output is universal binary. Any value overrides the presence of the config//cpu/constraints:universal-enabled constraint. Read the rule docs for more information on resolution. Details​ The output of the rule is a universal binary: If config//cpu/constraints:universal-enabled is present in the target platform.If the universal attribute is set to True. If none of the conditions are met, then the rule acts as a nop alias(). The universal attribute, if present, takes precedence over constraint. For example, if universal = False, then the presence of the constraint would not affect the output. apple_bundle() supports building of universal binaries,apple_universal_executable() is only needed if you have a standalone binary target which is not embedded in an apple_bundle() (usually a CLI tool).  "},{"title":"apple_xcframework​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_xcframework","content":"def apple_xcframework( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _apple_tools: str = _, buck2_compatibility: str = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"apple_xcuitest​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#apple_xcuitest","content":"def apple_xcuitest( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _apple_toolchain: str = _, _apple_tools: str = _, _apple_xctoolchain: str = _, _apple_xctoolchain_bundle_id: str = _, _bundling_cache_buster: None | str = _, _bundling_log_file_enabled: bool = _, _bundling_log_file_level: None | str = _, _code_signing_configuration: None | str = _, _codesign_identities_command_override: None | str = _, _codesign_type: None | str = _, _compile_resources_locally_override: None | bool = _, _embed_provisioning_profile_when_adhoc_code_signing: None | bool = _, _enable_library_evolution: bool = _, _fast_adhoc_signing_enabled_default: bool = _, _fast_provisioning_profile_parsing_enabled: bool = _, _incremental_bundling_enabled: bool = _, _info_plist_identify_build_system_default: bool = _, _profile_bundling_enabled: bool = _, _provisioning_profiles: str = _, _resource_bundle: None | str = _, _strict_provisioning_profile_search_default: bool = _, _use_entitlements_when_adhoc_code_signing: None | bool = _, binary: None | str = _, buck2_compatibility: str = _, codesign_identity: None | str = _, codesign_type: None | str = _, embed_provisioning_profile_when_adhoc_code_signing: bool = _, enable_library_evolution: None | bool = _, entitlements_file: None | str = _, extension: str = _, fast_adhoc_signing_enabled: None | bool = _, incremental_bundling_enabled: bool = _, info_plist: str, info_plist_identify_build_system: None | bool = _, info_plist_substitutions: dict[str, str] = _, provisioning_profile_filter: None | str = _, strict_provisioning_profile_search: None | bool = _, target_sdk_version: None | str = _, test_bundle: str, use_entitlements_when_adhoc_code_signing: bool = _, validation_deps: list[str] = _, versioned_macos_bundle: bool = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"cgo_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#cgo_library","content":"def cgo_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _asan: bool = _, _coverage_mode: None | str = _, _cxx_toolchain: str = _, _exec_os_type: str = _, _go_stdlib: str = _, _go_toolchain: str = _, _race: bool = _, _tags: list[str] = _, allow_cache_upload: None | bool = _, assembler_flags: list[str] = _, buck2_compatibility: str = _, compiler_flags: list[str] = _, contacts: list[str] = _, cxx_compiler_flags: list[str] = _, cxx_preprocessor_flags: list[str] = _, default_host_platform: None | str = _, default_platform: None | str = _, deps: list[str] = _, embedcfg: None | str = _, exported_deps: list[str] = _, generate_exported_header: bool = _, header_namespace: None | str = _, headers: list[str] | dict[str, str] = _, labels: list[str] = _, licenses: list[str] = _, link_style: None | str = _, package_name: None | str = _, package_root: None | str = _, srcs: list[str] = _ ) -&gt; None  A cgo_library() rule builds an object from the supplied set of Go/C source files and dependencies. The outputs are linked into go executable in the last step (compile). Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneallow_cache_upload: Whether to allow uploading the output of this rule to be uploaded to cache when the action is executed locally if the configuration allows (i.e. there is a cache configured and the client has permission to write to it).assembler_flags: The set of additional assembler flags to pass to go tool asm.compiler_flags: The set of additional compiler flags to pass to go tool compile.cxx_compiler_flags: GCC/Clang flags to use when compiling any of the above C/C++ sources (which require compilation).cxx_preprocessor_flags: GCC/Clang flags to use when preprocessing any of the above C/C++ sources (which require preprocessing).generate_exported_header: Generate header file with declaration for functions exported with //export The header name for target cell//foo/bar:lib will be foo/bar/lib.hheader_namespace: A path prefix when including headers of this target. Defaults to the path from the root of the repository to the directory where this target is defined. Can contain forward slashes (/), but cannot start with one. See headers for more information.headers: The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header name can contain forward slashes (/). The headers can be included with #include &quot;$HEADER_NAMESPACE/$HEADER_NAME&quot; or #include &lt;$HEADER_NAMESPACE/$HEADER_NAME&gt; , where $HEADER_NAMESPACE is the value of the target's header_namespace attribute, and $HEADER_NAME is the header name if specified, and the filename of the header file otherwise. See header_namespace for more information.link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared.package_name: Sets the full name of the package being compiled. This defaults to the path from the buck root. (e.g. given a ./.buckconfig, a rule in ./a/b/BUCK defaults to package &quot;a/b&quot;)package_root: Sets Go package direactory (relative to BUCK file). By default (or if None passes) package_root is being detected automatically. Empty string of Go package is on the same level as BUCK file otherwise the subdirectory name. Example for srcs = [&quot;foo/bar.go&quot;], package_root = &quot;foo&quot;srcs: The set of source files to be compiled by this rule. .go files will be compiled with the Go compiler, .s files will be compiled with the assembler, and everything else is assumed to be files that may be #included by the assembler. Details​ The 'go build' command would collect the cgo directives from the source files, however with buck the flags needs to be passed in the cgo_library manually This rule borrows from cxx_binary() since C/C++ sources are being compiled. Examples:  # A rule that builds a Go native executable with linked cgo library based on # C/C++ util library. go_binary( name = &quot;bin&quot;, srcs = [&quot;main.go&quot;], deps = [&quot;:lib&quot;] ) cgo_library( name = &quot;lib&quot;, srcs = [&quot;cgo_source.go&quot;], deps = [&quot;:util&quot;], ) cxx_library( name = &quot;util&quot;, srcs = [&quot;util.c&quot;], headers = [&quot;util.h&quot;], )   "},{"title":"command_alias​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#command_alias","content":"def command_alias( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _exec_os_type: str = _, _target_os_type: str = _, args: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, env: dict[str, str] = _, exe: None | str = _, labels: list[str] = _, licenses: list[str] = _, platform_exe: dict[str, str] = _, resources: list[str] = _ ) -&gt; None  The command_alias rule enables you to wrap build rules that create binaries and to pre-apply command-line arguments and environment variables. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one args: A string of arguments that is passed to the executable specified by exe at startup. These arguments support a subset of Buck's string parameter macros . Only the $(location ...) and $(exe ...) macros are supported currently. env: A map of environment variables that will be passed to the executable represented by exe on startup. Environment variables support the same macros as arguments. exe: A build target for a rule that outputs an executable, such as an sh_binary(), or an executable source file. platform_exe: A mapping from platforms to build target. enables you to override exe per host platform. If present, exe will be used as a fallback on host platforms that are not specified in platform_exe. It is possible to omit exe when providing platform_exe. In that case, the build will fail if the command is invoked on a platform not specified in the mapping. Valid platforms are all values of the Platform enum : FREEBSDLINUXMACOSWINDOWS Details​ Example uses include running a command written in a scripting language with a specific interpreter, and transparently wrapping sub-commands of a binary. You can reference a command_alias target in the cmd parameter of a genrule() by using the exe macro:  $(exe //path/to:target)  Examples:  # Combining an interpreter and a script cxx_binary( name = &quot;node-js&quot;, srcs = [ # ... ], headers = [ # ... ], ) export_file( name = &quot;scripts&quot; ) command_alias( name = &quot;server&quot;, exe = &quot;:node-js&quot;, args = [ &quot;$(location :scripts)/start-server.js&quot;, ], )   # Exposing sub commands export_file( name = &quot;yarn&quot;, src = &quot;yarn.sh&quot;, ) command_alias( name = &quot;add&quot;, exe = &quot;:yarn&quot;, args = [&quot;add&quot;], ) command_alias( name = &quot;install&quot;, exe = &quot;:yarn&quot;, args = [&quot;install&quot;], ) command_alias( name = &quot;run&quot;, exe = &quot;:yarn&quot;, args = [&quot;run&quot;], )   # Platform specific commands export_file( name = &quot;node-windows&quot;, src = &quot;windows/node.exe&quot;, ) export_file( name = &quot;node-linux&quot;, src = &quot;linux/node&quot;, ) export_file( name = &quot;node-macos&quot;, src = &quot;macos/node&quot;, ) command_alias( name = &quot;node&quot;, platform_exe = { &quot;windows&quot;: &quot;:node-windows&quot;, &quot;linux&quot;: &quot;:node-linux&quot;, &quot;macos&quot;: &quot;:node-macos&quot;, }, )   "},{"title":"config_setting​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#config_setting","content":"def config_setting( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, constraint_values: list[str] = _, values: dict[str, str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"configuration_alias​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#configuration_alias","content":"def configuration_alias( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, actual: str, buck2_compatibility: str = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"configured_alias​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#configured_alias","content":"def configured_alias( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, actual: str, buck2_compatibility: str = _, configured_actual: None | (str, str) = _, contacts: list[str] = _, default_host_platform: None | str = _, fallback_actual: None | str = _, labels: list[str] = _, licenses: list[str] = _, platform: None | str = _, propagate_flavors: bool = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"constraint_setting​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#constraint_setting","content":"def constraint_setting( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"constraint_value​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#constraint_value","content":"def constraint_value( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, constraint_setting: str ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"core_data_model​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#core_data_model","content":"def core_data_model( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, module: None | str = _, path: str ) -&gt; None  An core_data_model() rule contains models for Apple's Core Data framework. This rule does not have any output on its own and can be built only as a dependency (either direct or transitive) of an apple_bundle() rule in which case all core_data_model() rules that the bundle rule depends on are merged and placed into the final output bundle together. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one Details​ Examples:  core_data_model( name = 'MyCoreDataModel', path = 'MyCoreDataModel.xcdatamodeld', )   "},{"title":"csharp_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#csharp_library","content":"def csharp_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _csharp_toolchain: str = _, buck2_compatibility: str = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, dll_name: str = _, framework_ver: str, labels: list[str] = _, licenses: list[str] = _, resources: dict[str, str] = _, srcs: list[str] = _ ) -&gt; None  A csharp_library() rule builds a .Net library from the supplied set of C# source files and dependencies by invoking csc. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onecompiler_flags: The set of additional compiler flags to pass to the compiler.deps: The set of targets or system-provided assemblies to rely on. Any values that are targets must be either csharp_library or prebuilt_dotnet_library instances.dll_name: The output name of the dll. This allows you to specify the name of the dll exactly. When this is not set, the dll will be named after the short name of the target.framework_ver: The version of the .Net framework that this library targets. This is one of 'net35', 'net40', 'net45' and 'net46'.resources: Resources that should be embedded within the built DLL. The format is the name of the resource once mapped into the DLL as the key, and the value being the resource that should be merged. This allows non-unique keys to be identified quickly.srcs: The collection of source files to compile. Details​ Examples: For more examples, check out our integration tests.  csharp_library( name = 'simple', dll_name = 'Cake.dll', framework_ver = 'net46', srcs = [ 'Hello.cs', ], resources = { 'greeting.txt': '//some:target', }, deps=[ ':other', 'System.dll', ], ) prebuilt_dotnet_library( name = 'other', assembly = 'other-1.0.dll', )   "},{"title":"cxx_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#cxx_binary","content":"def cxx_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_hacks: str = _, _cxx_toolchain: str = _, allow_cache_upload: None | bool = _, anonymous_link_groups: bool = _, auto_link_groups: bool = _, binary_linker_flags: list[str] = _, bolt_flags: list[str] = _, bolt_profile: None | str = _, buck2_compatibility: str = _, compiler_flags: list[str] = _, constraint_overrides: list[str] = _, contacts: list[str] = _, coverage_instrumentation_compiler_flags: list[str] = _, cxx_runtime_type: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, defaults: dict[str, str] = _, deps: list[str] = _, deps_query: None | str = _, devirt_enabled: bool = _, distributed_thinlto_partial_split_dwarf: bool = _, enable_distributed_thinlto: bool = _, executable_name: None | str = _, exported_needs_coverage_instrumentation: bool = _, fat_lto: bool = _, focused_list_target: None | str = _, frameworks: list[str] = _, header_namespace: None | str = _, headers: list[str] | dict[str, str] = _, headers_as_raw_headers_mode: None | str = _, include_directories: list[str] = _, labels: list[str] = _, lang_compiler_flags: dict[str, list[str]] = _, lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = _, lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, lang_preprocessor_flags: dict[str, list[str]] = _, libraries: list[str] = _, licenses: list[str] = _, link_deps_query_whole: bool = _, link_execution_preference: None | str = _, link_group: None | str = _, link_group_deps: list[str] = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_group_min_binary_node_count: None | int = _, link_group_public_deps_label: None | str = _, link_ordering: None | str = _, link_style: None | str = _, link_whole: bool = _, linker_extra_outputs: list[str] = _, linker_flags: list[str] = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, platform_linker_flags: list[(str, list[str])] = _, platform_preprocessor_flags: list[(str, list[str])] = _, platform_srcs: list[(str, list[str | (str, list[str])])] = _, post_linker_flags: list[str] = _, post_platform_linker_flags: list[(str, list[str])] = _, precompiled_header: None | str = _, prefer_stripped_objects: bool = _, prefix_header: None | str = _, preprocessor_flags: list[str] = _, raw_headers: list[str] = _, resources: list[str] | dict[str, str] = _, srcs: list[str | (str, list[str])] = _, thin_lto: bool = _, version_universe: None | str = _, weak_framework_names: list[str] = _ ) -&gt; None  A cxx_binary() rule builds a native executable from the supplied set of C/C++ source files and dependencies. If C/C++ library dependencies are listed, the generated native executable will request and link against their static archives (which are *not* built using PIC). Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one allow_cache_upload: Whether to allow uploading the output of this rule to be uploaded to cache when the action is executed locally if the configuration allows (i.e. there is a cache configured and the client has permission to write to it). compiler_flags: Flags to use when compiling any of the above sources (which require compilation). deps_query: Status: experimental/unstable. The deps query takes a query string that accepts the following query functions, and appends the output of the query to the declared deps: attrfilterdepsexceptintersectfilterkindsetunion The macro $declared_deps may be used anywhere a target literal pattern is expected in order to refer to the explicit deps of this rule as they appear in the rule's definition. For example, if your build rule declares android_library( name = 'lib', deps = ['//foo:foo'], deps_query = '$declared_deps', ) then the macro $declared_deps would be expanded to a literal set(//foo:foo). Some example queries: &quot;filter({name_regex}, $declared_deps)&quot;.format(name_regex='//.*') &quot;attrfilter(annotation_processors, com.foo.Processor, $declared_deps)&quot; &quot;deps('//foo:foo', 1)&quot; Note: any targets included in this query must also be present in deps. header_namespace: A path prefix when including headers of this target. Defaults to the path from the root of the repository to the directory where this target is defined. Can contain forward slashes (/), but cannot start with one. See headers for more information. headers: The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header name can contain forward slashes (/). The headers can be included with #include &quot;$HEADER_NAMESPACE/$HEADER_NAME&quot; or #include &lt;$HEADER_NAMESPACE/$HEADER_NAME&gt; , where $HEADER_NAMESPACE is the value of the target's header_namespace attribute, and $HEADER_NAME is the header name if specified, and the filename of the header file otherwise. See header_namespace for more information. include_directories: A list of include directories (with raw_headers) to be added to the compile command for compiling this target (via -I). An include directory is relative to the current package. link_execution_preference: The execution preference for linking. Options are: any : No preference is set, and the link action will be performed based on buck2's executor configuration.full_hybrid : The link action will execute both locally and remotely, regardless of buck2's executor configuration (if the executor is capable of hybrid execution). The use_limited_hybrid setting of the hybrid executor is ignored.local : The link action will execute locally if compatible on current host platform.local_only : The link action will execute locally, and error if the current platform is not compatible.remote : The link action will execute remotely if a compatible remote platform exists, otherwise locally. The default is None, expressing that no preference has been set on the target itself. link_group_deps: Additional targets to traverse when building link groups, but which should not be direct dependencies of the main executable. link_group_public_deps_label: Surface nodes with this label as &quot;public&quot; nodes in the main executable when linking with with link groups. link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared. linker_extra_outputs: Declares extra outputs that the linker emits. These identifiers can be used in $(output ...) macros in linker_flags to interpolate the output path into the linker command line. Useful for custom linkers that emit extra output files. linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library. platform_compiler_flags: Platform specific compiler flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when compiling the target's sources. See compiler_flags for more information. platform_headers: Platform specific header files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of header files or a dictionary of header names to header files that will be made available for inclusion to the source files in the target if the platform matches the regex. See headers for more information. platform_linker_flags: Platform-specific linker flags. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use java.util.regex.Pattern syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule is used in a link operation. platform_preprocessor_flags: Platform specific preprocessor flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when preprocessing the target's sources. See preprocessor_flags for more information. platform_srcs: Platform specific source files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of source files or a list of tuples of source files and a list of compilation flags to be preprocessed, compiled and assembled if the platform matches the regex. See srcs for more information. preprocessor_flags: Flags to use when preprocessing any of the above sources (which require preprocessing). raw_headers: The set of header files that can be used for inclusion to the source files in the target and all targets that transitively depend on it. Buck doesn't add raw headers to the search path of a compiler/preprocessor automatically. include_directories and public_include_directories are the recommended way to add raw headers to the search path (they will be added via -I). compiler_flags, preprocessor_flags and exported_preprocessor_flags can also be used to add such raw headers to the search path if inclusion via -isystem or -iquote is needed. raw_headers cannot be used together with headers or exported_headers in the same target. srcs: The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the GCC documentation for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. '') or a tuple of a string specifying a source file and a list of compilation flags (e.g. ('', ['-Wall', '-Werror']) ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable). Details​ Examples:  # A rule that builds a C/C++ native executable from a single .cpp file # its corresponding header, and a C/C++ library dependency. cxx_binary( name = 'echo', srcs = [ 'echo.cpp', ], headers = [ 'echo.h', ], deps = [ ':util', ], ) cxx_library( name = 'util', srcs = [ 'util.cpp', ], headers = [ 'util.h', ], ) # To build without stripping: buck build :echo # To build with stripping debug symbols only: buck build :echo#strip-debug   "},{"title":"cxx_genrule​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#cxx_genrule","content":"def cxx_genrule( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _cxx_toolchain: str = _, _exec_os_type: str = _, _genrule_toolchain: str = _, always_print_stderr: bool = _, bash: None | str = _, buck2_compatibility: str = _, cacheable: None | bool = _, cmd: None | str = _, cmd_exe: None | str = _, contacts: list[str] = _, default_host_platform: None | str = _, default_outs: None | list[str] = _, enable_sandbox: None | bool = _, env: dict[str, str] = _, environment_expansion_separator: None | str = _, labels: list[str] = _, licenses: list[str] = _, metadata_env_var: None | str = _, metadata_path: None | str = _, need_android_tools: bool = _, no_outputs_cleanup: bool = _, out: None | str = _, outs: None | dict[str, list[str]] = _, remote: None | bool = _, remote_execution_dependencies: list[dict[str, str]] = _, srcs: list[str] | dict[str, str] = _, type: None | str = _, weight: None | int = _ ) -&gt; None  A cxx_genrule() enables you to run shell commands as part of the Buck build process. A cxx_genrule() exposes - through a set of string parameter macros and variables - information about the tools and configuration options used by the Buck environment, specifically those related to the C/C++ toolchain. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one bash: A platform-specific version of the shell command parameter cmd. It runs on Linux and UNIX systems—including OSX—on which bash is installed. It has a higher priority than cmd. The bash argument is run with /usr/bin/env bash -c. It has access to the same set of macros and variables as the cmd argument. cmd: The shell command to run to generate the output file. It is the fallback of bash and cmd_exe. The shell command can access information about the buck build environment through a set of macros, parameterized macros, and variables. Macros​ The following macros are available to the shell command and are accessed using the following syntax. $(&lt;macro&gt;) Example: $(cc) $(cc)Path to the C compiler. $(cxx)Path to the C++ compiler. $(cflags)Flags passed to the C compiler. $(cppflags)Flags passed to the C preprocessor. $(cxxflags)Flags passed to the C++ compiler. $(cxxppflags)Flags to pass to the C++ preprocessor. $(ld)Path to the linker. $(ldflags-pic)Flags passed to the linker for binaries that use position-independent code (PIC). $(ldflags-pic-filter &lt;pattern&gt;)Flags passed to the linker for binaries that use position-independent code (PIC). Use the pattern parameter to specify a regular expression that matches the build targets that use these flags. $(ldflags-shared)Flags passed to the linker for shared libraries, such as dynamic-link libraries (DLLs). $(ldflags-shared-filter &lt;pattern&gt;)Flags passed to the linker for shared libraries, such as dynamic-link libraries (DLLs). Use the pattern parameter to specify a regular expression that matches the build targets that use these flags. $(ldflags-static)Flags passed to the linker for statically-linked libraries. $(ldflags-static-filter &lt;pattern&gt;)Flags passed to the linker for statically-linked libraries. Use the pattern parameter to specify a regular expression that matches the build targets that use these flags. $(platform-name)The platform flavor with which this cxx_genrule was specified. Parameterized Macros​ It is also possible to expand references to other rules within the shell command, using the following subset of the builtin string parameter macros. Note that all build rules expanded in the command are automatically considered to be dependencies of the genrule(). Note that the paths returned by these macros are absolute paths. You should convert these paths to be relative paths before embedding them in, for example, a shell script or batch file. Using relative paths ensures that your builds are hermetic, that is, they are reproducible across different machine environments. Additionally, if you embed these paths in a shell script, you should execute that script using the sh_binary() rule and include the targets for these paths in the resources argument of that sh_binary rule. These are the same targets that you pass to the string parameter macros. $(exe //path/to:target)Expands to the commands necessary to run the executable generated by the specified build rule. For a C++ executable, this will typically just be the name of the output executable itself, such as main. If the specified build rule does not generate an executable output, an exception will be thrown and the build will fail. $(location //path/to:target)Expands to the path of the output of the build rule. This means that you can refer to these without needing to be aware of how Buck is storing data on the disk mid-build. Variables​ Finally, Buck adds the following variables to the environment in which the shell command runs. They are accessed using the following syntax. Note the use of braces rather than parentheses. ${&lt;variable&gt;} Example: ${SRCS} ${SRCS}A string expansion of the srcs argument delimited by the environment_expansion_separator argument where each element of srcs will be translated into an absolute path. ${SRCDIR}The absolute path to the to which sources are copied prior to running the command. ${OUT}The output file for the genrule(). The file specified by this variable must always be written by this command. If not, the execution of this rule will be considered a failure, halting the build process. ${TMP}A temporary directory which can be used for intermediate results and will not be bundled into the output. cmd_exe: A platform-specific version of the shell command parameter cmd. It runs on Windows and has a higher priority than cmd. The cmd_exe argument is run with cmd.exe /v:off /c. It has access to the same set of macros and variables as the cmd argument. enable_sandbox: Whether this target should be executed in a sandbox or not. env: A map of variables to be set in the environment where the shell command is run. environment_expansion_separator: The delimiter between paths in environment variables, such as SRCS, that can contain multiple paths. It can be useful to specify this parameter if the paths could contain spaces. out: The name of the output file or directory. The complete path to this argument is provided to the shell command through the OUT environment variable. srcs: Either a list or a map of the source files which Buck makes available to the shell command at the path in the SRCDIR environment variable. If you specify a list, the source files are the names in the list. If you specify a map, the source files are made available as the names in the keys of the map, where the values of the map are the original source file names. type: Specifies the type of this genrule. This is used for logging and is particularly useful for grouping genrules that share an underlying logical &quot;type&quot;. For example, if you have the following cxx_genrule defined in the root directory of your Buck project cxx_genrule( name = 'cxx_gen', type = 'epilog', cmd = 'touch finish.txt; cp finish.txt $OUT', out = 'finish.txt' ) then the following buck query command buck query &quot;attrfilter( type, 'epilog', '//...' )&quot; returns //:cxx_gen weight: How many local slots these genrule should take when executing locally. Details​ The information exposed through these tools and configuration options is a reflection of: Buck's built-in settings, the settings in .buckconfigand .buckconfig.local, and the result of various command-line overrides specified through the common_parameters command-line option. This information is available only to the shell commands specified in the cxx_genrule. The information is not available to other arguments of the rule. A cxx_genrule() can be an input to another cxx_genrule(). Note that if you specify the cxx_genrule as a command-line target to buck build, you must include a platform flavor. For example:  buck build :cxx_gr_name#iphonesimulator-x86_64  You could also just specify the default platform flavor explicitly:  buck build :cxx_gr_name#default   "},{"title":"cxx_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#cxx_library","content":"def cxx_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_hacks: str = _, _cxx_toolchain: str = _, _is_building_android_binary: bool = _, allow_cache_upload: None | bool = _, auto_link_groups: bool = _, bridging_header: None | str = _, buck2_compatibility: str = _, can_be_asset: None | bool = _, compiler_flags: list[str] = _, contacts: list[str] = _, coverage_instrumentation_compiler_flags: list[str] = _, cxx_runtime_type: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, defaults: dict[str, str] = _, deffile: None | str = _, deps: list[str] = _, deps_query: None | str = _, devirt_enabled: bool = _, diagnostics: dict[str, str] = _, executable_name: None | str = _, exported_deps: list[str] = _, exported_header_style: str = _, exported_headers: list[str] | dict[str, str] = _, exported_lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, exported_lang_preprocessor_flags: dict[str, list[str]] = _, exported_linker_flags: list[str] = _, exported_needs_coverage_instrumentation: bool = _, exported_platform_deps: list[(str, list[str])] = _, exported_platform_headers: list[(str, list[str] | dict[str, str])] = _, exported_platform_linker_flags: list[(str, list[str])] = _, exported_platform_preprocessor_flags: list[(str, list[str])] = _, exported_post_linker_flags: list[str] = _, exported_post_platform_linker_flags: list[(str, list[str])] = _, exported_preprocessor_flags: list[str] = _, extra_xcode_files: list[str] = _, extra_xcode_sources: list[str] = _, fat_lto: bool = _, focused_list_target: None | str = _, force_static: None | bool = _, frameworks: list[str] = _, header_mode: None | str = _, header_namespace: None | str = _, headers: list[str] | dict[str, str] = _, headers_as_raw_headers_mode: None | str = _, include_directories: list[str] = _, include_in_android_merge_map_output: bool = _, labels: list[str] = _, lang_compiler_flags: dict[str, list[str]] = _, lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = _, lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, lang_preprocessor_flags: dict[str, list[str]] = _, libraries: list[str] = _, licenses: list[str] = _, link_deps_query_whole: bool = _, link_execution_preference: None | str = _, link_group: None | str = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_ordering: None | str = _, link_style: None | str = _, link_whole: None | bool = _, linker_extra_outputs: list[str] = _, linker_flags: list[str] = _, local_linker_flags: list[str] = _, module_name: None | str = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, platform_linker_flags: list[(str, list[str])] = _, platform_preprocessor_flags: list[(str, list[str])] = _, platform_srcs: list[(str, list[str | (str, list[str])])] = _, post_linker_flags: list[str] = _, post_platform_linker_flags: list[(str, list[str])] = _, precompiled_header: None | str = _, prefer_stripped_objects: bool = _, preferred_linkage: str = _, prefix_header: None | str = _, preprocessor_flags: list[str] = _, public_include_directories: list[str] = _, public_system_include_directories: list[str] = _, raw_headers: list[str] = _, reexport_all_header_dependencies: None | bool = _, resources: list[str] | dict[str, str] = _, sdk_modules: list[str] = _, soname: None | str = _, srcs: list[str | (str, list[str])] = _, static_library_basename: None | str = _, supported_platforms_regex: None | str = _, supports_header_symlink_subtarget: bool = _, supports_merged_linking: None | bool = _, supports_python_dlopen: None | bool = _, supports_shlib_interfaces: bool = _, thin_lto: bool = _, use_archive: None | bool = _, used_by_wrap_script: bool = _, uses_cxx_explicit_modules: bool = _, uses_explicit_modules: bool = _, version_universe: None | str = _, weak_framework_names: list[str] = _ ) -&gt; None  A cxx_library() rule specifies a set of C/C++ source files and also provides flags that specify how those files should be built. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one allow_cache_upload: Whether to allow uploading the output of this rule to be uploaded to cache when the action is executed locally if the configuration allows (i.e. there is a cache configured and the client has permission to write to it). compiler_flags: Flags to use when compiling any of the above sources (which require compilation). deffile: Specifies the *.def file used on windows to modify a dll's exports in place of explicit __declspec(dllexport) declarations. The default is to not use a defile. exported_deps: Dependencies that will also appear to belong to any rules that depend on this one. This has two effects: Exported dependencies will also be included in the link line of dependents of this rules, but normal dependencies will not. When reexport_all_header_dependencies = False, only exported headers of the rules specified here are re-exported. exported_header_style: How dependents should include exported headers from this rule. Can be either local (e.g. -I) or system (e.g. -isystem). exported_headers: The set of header files that are made available for inclusion to the source files in the target and all targets that transitively depend on it. These should be specified as either a list of header files or a dictionary of header names to header files. The headers can be included with #include &quot;$HEADER_NAMESPACE/$HEADER_NAME&quot; or #include &lt;$HEADER_NAMESPACE/$HEADER_NAME&gt;, where $HEADER_NAMESPACE is the value of the target's header_namespace attribute, and $HEADER_NAME is the header name if specified, and the filename of the header file otherwise. Note that the header name can contain forward slashes (/). See header_namespace for more information. exported_lang_platform_preprocessor_flags: Just as lang_platform_preprocessor_flags, but these flags also apply to rules that transitively depend on this rule. exported_lang_preprocessor_flags: Just as lang_preprocessor_flags, but these flags also apply to rules that transitively depend on this rule. exported_linker_flags: Flags to add to the linker command line when the output from this rule, or the output from any rule that transitively depends on this rule, is used in a link operation. exported_platform_deps: Platform specific dependencies that will also appear to belong to any rules that depend on this one. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of external dependencies (same format as exported_deps) that are exported if the platform matches the regex. See exported_deps for more information. exported_platform_headers: Platform specific header files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of header files or a dictionary of header names to header files that will be made available for inclusion to the source files in the target and all targets that transitively depend on it if the platform matches the regex. See headers for more information. exported_platform_linker_flags: Platform-specific linker flags for this rule and for all rules that transitively depend on this rule. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use java.util.regex.Pattern syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule, or the output from any rule that transitively depends on this rule, is used in a link operation. exported_platform_preprocessor_flags: Platform specific exported preprocessor flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when preprocessing the source files in the target and all targets that transitively depend on it if the platform matches the regex. See exported_preprocessor_flags for more information. exported_post_linker_flags: Flags to add to the linker command line when the output from this rule, or the output from any rule that transitively depends on this rule, is used in a link operation—with the additional feature that these flags are guaranteed to be placed after the compiled object (.o) files on the linker command line. exported_post_platform_linker_flags: Platform-specific linker flags for this rule and for all rules that transitively depend on this rule—and that are guaranteed to be placed after the compiled object (.o) files on the linker command line. In other respects, the syntax and semantics of this argument are the same as for the exported_platform_linker_flags argument. extra_xcode_files: When the project is generated, this is the list of files that will added to the project. Those files won't be added to the build phase &quot;Compile Sources&quot;. header_namespace: A path prefix when including headers of this target. Defaults to the path from the root of the repository to the directory where this target is defined. Can contain forward slashes (/), but cannot start with one. See headers for more information. headers: The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header name can contain forward slashes (/). The headers can be included with #include &quot;$HEADER_NAMESPACE/$HEADER_NAME&quot; or #include &lt;$HEADER_NAMESPACE/$HEADER_NAME&gt; , where $HEADER_NAMESPACE is the value of the target's header_namespace attribute, and $HEADER_NAME is the header name if specified, and the filename of the header file otherwise. See header_namespace for more information. include_directories: A list of include directories (with raw_headers) to be added to the compile command for compiling this target (via -I). An include directory is relative to the current package. lang_compiler_flags: Language-specific compiler flags. These should be specified as a map of C-family language short names to lists of flags and is used to target flags to sources files for a specific language in the C-family (C, C++, assembler, etc.). The keys in the map can be: cpp-output for C c++-cpp-output for C++ objective-c-cpp-output for Objective-C objective-c++-cpp-output for Objective-C++ cuda-cpp-output for Cuda assembler for Assembly * asm for ASM lang_platform_compiler_flags: Language- and platform-specific compiler flags. These should be specified as a map of C-family language short names, as described in lang_compiler_flags, to lists of pairs, as described in platform_compiler_flags. lang_platform_preprocessor_flags: Language- and platform-specific preprocessor flags. These should be specified as a map of C-family language short names, as described in lang_preprocessor_flags, to lists of pairs, as described in platform_preprocessor_flags. lang_preprocessor_flags: Language-specific preprocessor flags. These should be specified as a map of C-family language short names to lists of flags and is used to target flags to sources files for a specific language in the C-family (C, C++, assembler, etc.). The keys in the map can be: c for C c++ for C++ objective-c for Objective-C objective-c++ for Objective-C++ cuda for Cuda assembler-with-cpp for Assembly * asm-with-cpp for ASM link_execution_preference: The execution preference for linking. Options are: any : No preference is set, and the link action will be performed based on buck2's executor configuration.full_hybrid : The link action will execute both locally and remotely, regardless of buck2's executor configuration (if the executor is capable of hybrid execution). The use_limited_hybrid setting of the hybrid executor is ignored.local : The link action will execute locally if compatible on current host platform.local_only : The link action will execute locally, and error if the current platform is not compatible.remote : The link action will execute remotely if a compatible remote platform exists, otherwise locally. The default is None, expressing that no preference has been set on the target itself. link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared. linker_extra_outputs: Declares extra outputs that the linker emits. These identifiers can be used in $(output ...) macros in linker_flags to interpolate the output path into the linker command line. Useful for custom linkers that emit extra output files. linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library. local_linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation driven by this rule (e.g. when this rule links a shared library, but not when the output is linked into a shared library by another rule's link group links). platform_compiler_flags: Platform specific compiler flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when compiling the target's sources. See compiler_flags for more information. platform_headers: Platform specific header files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of header files or a dictionary of header names to header files that will be made available for inclusion to the source files in the target if the platform matches the regex. See headers for more information. platform_linker_flags: Platform-specific linker flags. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use java.util.regex.Pattern syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule is used in a link operation. platform_preprocessor_flags: Platform specific preprocessor flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when preprocessing the target's sources. See preprocessor_flags for more information. platform_srcs: Platform specific source files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of source files or a list of tuples of source files and a list of compilation flags to be preprocessed, compiled and assembled if the platform matches the regex. See srcs for more information. preferred_linkage: Determines what linkage is used when the library is depended on by another target. To control how the dependencies of this library are linked, use link_style instead. preprocessor_flags: Flags to use when preprocessing any of the above sources (which require preprocessing). public_include_directories: A list of include directories (with raw_headers) to be added to the compile command for compiling this target and every target that depends on it (via -I). An include directory is relative to the current package. public_system_include_directories: A list of include directories (with raw_headers) to be added to the compile command for compiling this target and every target that depends on it (via -isystem if the compiler supports it of via -I otherwise). An include directory is relative to the current package. raw_headers: The set of header files that can be used for inclusion to the source files in the target and all targets that transitively depend on it. Buck doesn't add raw headers to the search path of a compiler/preprocessor automatically. include_directories and public_include_directories are the recommended way to add raw headers to the search path (they will be added via -I). compiler_flags, preprocessor_flags and exported_preprocessor_flags can also be used to add such raw headers to the search path if inclusion via -isystem or -iquote is needed. raw_headers cannot be used together with headers or exported_headers in the same target. reexport_all_header_dependencies: Whether to automatically re-export the exported headers of all dependencies. When this is set to false, only exported headers fromexported_deps are re-exported. soname: Sets the soname (&quot;shared object name&quot;) of any shared library produced from this rule. The default value is based on the full rule name. The macro $(ext) will be replaced with a platform-appropriate extension. An argument can be provided, which is a library version. For example soname = 'libfoo.$(ext 2.3)' will be libfoo.2.3.dylib on Mac and libfoo.so.2.3 on Linux. srcs: The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the GCC documentation for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. '') or a tuple of a string specifying a source file and a list of compilation flags (e.g. ('', ['-Wall', '-Werror']) ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable). supported_platforms_regex: If present, an un-anchored regex (in java.util.regex.Pattern syntax) that matches all platforms that this library supports. It will not be built for other platforms. used_by_wrap_script: When using an exopackage Android, if this parameter is set to True, then the library is included in the primary APK even if native libraries would otherwise not be placed in it. This is intended for native libraries that are used by a wrap.sh script, which must be placed in the primary APK. Only one of can_be_asset and used_by_wrap_script can be set for a rule. Details​ Building requires a specified top-level target​ Whether a Buck command builds the cxx_library is determined by the inclusion of a top-level target, such as a cxx_binary() or android_binary(), that transitively depends on the cxx_library. The set of targets specified to the Buck command (buck build, buck run, etc) must include one of these top-level targets in order for Buck to build the cxx_library. Note that you could specify the top-level target implicitly using a build target pattern or you could also specify the top-level target using a buckconfig alias defined in .buckconfig. How Buck builds the library also depends on the specified top-level target. For example, a C/C++ binary (cxx_binary) would require a static non-PIC build of the library, whereas an Android APK (android_binary) would require a shared PIC-enabled build. (PIC stands for position-independent code.) Dependencies of the cxx_library also require a top-level target​ Similarly, in order for Buck to build a target that the cxx_library depends on, such as a cxx_genrule(), you must specify in the Buck command a top-level target that depends on the cxx_library. For example, you could specify to build a cxx_binary that depends on the cxx_library. If you specify as your build target the cxx_library itself, the build targets that the cxx_library depends on might not be built. Examples:  # A rule that includes a single .cpp file and its corresponding header and # also supplies an additional flag for compilation. cxx_library( name = 'fileutil', srcs = [ 'fileutil.cpp', ], exported_headers = [ 'fileutil.h', ], compiler_flags = [ '-fno-omit-frame-pointer', ], ) # A rule that defines explicit names for its headers cxx_library( name = 'mathutils', header_namespace = 'math', srcs = [ 'trig/src/cos.cpp', 'trig/src/tan.cpp', ], exported_headers = { # These are included as &lt;math/trig/cos.h&gt; and &lt;math/trig/tan.h&gt; 'trig/cos.h': 'trig/include/cos.h', 'trig/tan.h': 'trig/include/tan.h', }, compiler_flags = [ '-fno-omit-frame-pointer', ], ) # A rule that uses different headers and sources per platform cxx_library( name = 'vector', # Because of platform_headers, this file can include &quot;config.h&quot; # and get the architecture specific header srcs = ['vector.cpp'], platform_srcs = [ ('.*armv7$', 'armv7.S'), ('.*x86_64$', 'x86_64.S'), ], exported_headers = [ 'vector.h', ], platform_headers = [ ( '.*armv7$', { 'config.h': 'config-armv7.h', } ), ( '.*x86_64$', { 'config.h': 'config-x86_64.h', } ), ], )   "},{"title":"cxx_lua_extension​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#cxx_lua_extension","content":"def cxx_lua_extension( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, base_module: None | str = _, buck2_compatibility: str = _, compiler_flags: list[str] = _, contacts: list[str] = _, cxx_runtime_type: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, defaults: dict[str, str] = _, deps: list[str] = _, executable_name: None | str = _, frameworks: list[str] = _, header_namespace: None | str = _, headers: list[str] | dict[str, str] = _, headers_as_raw_headers_mode: None | str = _, include_directories: list[str] = _, labels: list[str] = _, lang_compiler_flags: dict[str, list[str]] = _, lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = _, lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, lang_preprocessor_flags: dict[str, list[str]] = _, libraries: list[str] = _, licenses: list[str] = _, linker_extra_outputs: list[str] = _, linker_flags: list[str] = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, platform_linker_flags: list[(str, list[str])] = _, platform_preprocessor_flags: list[(str, list[str])] = _, platform_srcs: list[(str, list[str | (str, list[str])])] = _, post_linker_flags: list[str] = _, post_platform_linker_flags: list[(str, list[str])] = _, precompiled_header: None | str = _, prefix_header: None | str = _, preprocessor_flags: list[str] = _, raw_headers: list[str] = _, srcs: list[str | (str, list[str])] = _, version_universe: None | str = _ ) -&gt; None  A cxx_lua_extension() rule is a variant of a C/C++ library which is built as a Lua module. As such, it has a module name formed by the base_module parameter and the rule name and implicitly depends on Lua C library (configured via the .buckconfig parameter. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onebase_module: The package for which the given specified sources and resources should reside in their final location in the top-level binary. If unset, the project relative directory that houses the BUCK file is used.compiler_flags: Flags to use when compiling any of the above sources (which require compilation).header_namespace: A path prefix when including headers of this target. Defaults to the path from the root of the repository to the directory where this target is defined. Can contain forward slashes (/), but cannot start with one. See headers for more information.headers: The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header name can contain forward slashes (/). The headers can be included with #include &quot;$HEADER_NAMESPACE/$HEADER_NAME&quot; or #include &lt;$HEADER_NAMESPACE/$HEADER_NAME&gt; , where $HEADER_NAMESPACE is the value of the target's header_namespace attribute, and $HEADER_NAME is the header name if specified, and the filename of the header file otherwise. See header_namespace for more information.linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library.platform_compiler_flags: Platform specific compiler flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when compiling the target's sources. See compiler_flags for more information.platform_headers: Platform specific header files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of header files or a dictionary of header names to header files that will be made available for inclusion to the source files in the target if the platform matches the regex. See headers for more information.platform_linker_flags: Platform-specific linker flags. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use java.util.regex.Pattern syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule is used in a link operation.platform_preprocessor_flags: Platform specific preprocessor flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when preprocessing the target's sources. See preprocessor_flags for more information.platform_srcs: Platform specific source files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of source files or a list of tuples of source files and a list of compilation flags to be preprocessed, compiled and assembled if the platform matches the regex. See srcs for more information.preprocessor_flags: Flags to use when preprocessing any of the above sources (which require preprocessing).srcs: The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the GCC documentation for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. '') or a tuple of a string specifying a source file and a list of compilation flags (e.g. ('', ['-Wall', '-Werror']) ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable). Details​ Examples:  # A rule that builds a Lua extension from a single .cpp file. cxx_lua_extension( name = 'mymodule', base_module = 'foo.bar', srcs = [ 'mymodule.cpp', ], compiler_flags = [ '-fno-omit-frame-pointer', ], ) # A library rule which has a single source importing the above extension. lua_library( name = 'utils', srcs = [ 'utils.lua', ], deps = [ ':mymodule', ], )   -- The `utils.lua` source, wrapped by the `utils` rule above. -- Import the C/C++ extension build above. require &quot;foo.bar.mymodule&quot; ...   "},{"title":"cxx_precompiled_header​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#cxx_precompiled_header","content":"def cxx_precompiled_header( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, src: str, version_universe: None | str = _ ) -&gt; None  A cxx_precompiled_header rule specifies a single header file that can be precompiled and made available for use in other build rules such as a cxx_library() or a cxx_binary(). Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onedeps: Dependency rules which export headers used by the header specified in src.src: The path to the header file that should be precompiled. Only one header file can be specified. But of course this header could include any number of other headers. The included headers could belong to -- that is, be exported_headers from -- another rule, in which case, the rule would have to be added to deps as usual. Details​ This header file is precompiled by the preprocessor on behalf of the C, C++, Objective-C, or Objective-C++ rule using it, via its precompiled_header parameter. Afterwards the precompiled header is applied during the rule's own compilation (often with an appreciable reduction in build time, the main benefit of PCH). This PCH is built once per combination of build flags which might affect the PCH's compatibility. For example, a distinct pre-compilation of the header occurs per combination of flags related to optimization, debug, architecture, and so on, used by rules which employ PCH. The flags used during the build of the dependent rule (that is, the &quot;PCH-using rule&quot;) are in effect while building the PCH itself. Similarly, to the same end, the include paths used when building the PCH are applied to the dependent rule. For example, deps in the PCH rule are propagated back to the dependent rule, and the PCH's header search paths (e.g. -I or -isystem options) are prefixed onto the list of include paths for the dependent rule. Examples: The best way to see how the cxx_precompiled_header() rule works is with an example. Let there be a header called common.h which has the following:  #pragma once /* Include common C++ files. */ #include &lt;string&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;type_traits&gt; #include &lt;vector&gt; /* Some frequently-used headers from the Folly project. */ #include &lt;folly/Conv.h&gt; #include &lt;folly/Executor.h&gt; #include &lt;folly/io/async/EventBase.h&gt;   cxx_precompiled_header( name = 'common_pch', src = 'common.h', deps = [ # Needed for standard C++ headers: '//external/libcxx:headers', # Needed for the Folly includes: '//folly:folly', '//folly/io/async:async', ], ) cxx_binary( name = 'main', srcs = ['main.cpp'], precompiled_header = ':common_pch', deps = [ ... ], compiler_flags = ['-g', '-O2', '-fPIC'], )  The cxx_precompiled_header rule declares a precompiled header &quot;template&quot; containing the header file path, and dependencies. In this example we indicate that common.h is to be precompiled when used by another build rule. Note that, by itself, this cxx_precompiled_header rule will not result in anything being built. The usage of this rule from another rule -- an &quot;instantiation&quot; of this precompiled header template -- is what will trigger the PCH build. In the example above, the build for the binary named &quot;main&quot; will depend on the header being precompiled in a separate step, prior to compiling main.cpp, and the resulting PCH will be used in main's compilation. The dependencies specified in this precompiled header rule's deps are transitive; they will propagate to rules using this PCH, so that during link time, any libraries which are required by the code made available in the header will be included in the final binary build. The precompiled header dynamically created from the &quot;template&quot; will be built with flags which would be used in the dependent rule. In this case, main's use of specific compiler flags -g -O2 -fPIC will result in the production of a precompiled header with the same flags. This is so the precompiled code fully jives with rules using the PCH, i.e. they will have the same debug, optimization, CPU, etc. options. (The compiler is usually smart enough to reject a bad PCH, fortunately. But we want to ensure we take the appropriate steps to ensure we always have a PCH which works with any build that uses it.) Another effect of a rule using a precompiled header is that the rule's list of build flags will change; not just to employ PCH with e.g. -include-pch (if using Clang), but also, to alter the sequence of header search paths. The rule using the precompiled header will &quot;inherit&quot; the lists of paths used during the PCH build, applying them first in its own search paths. This is to ensure that an #include directive will resolve in exactly the same way in this build as it would have in the PCH, to ensure full compatibility between the PCH and other rule's builds. For example, if the PCH were to use one version of stdcxx and another rule use a different version, the version differences won't clash, thereby avoiding different versions of the &lt;cstring&gt; header used between the precompiled header and the dependent rule, and preventing confused structure definitions, ABI incompatibility, and so on (catastrophe, in other words).  "},{"title":"cxx_python_extension​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#cxx_python_extension","content":"def cxx_python_extension( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_hacks: str = _, _cxx_toolchain: str = _, _python_toolchain: str = _, _target_os_type: str = _, allow_cache_upload: None | bool = _, allow_embedding: bool = _, allow_suffixing: bool = _, auto_link_groups: bool = _, base_module: None | str = _, bridging_header: None | str = _, buck2_compatibility: str = _, can_be_asset: None | bool = _, compiler_flags: list[str] = _, contacts: list[str] = _, coverage_instrumentation_compiler_flags: list[str] = _, cxx_runtime_type: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, defaults: dict[str, str] = _, deffile: None | str = _, deps: list[str] = _, devirt_enabled: bool = _, diagnostics: dict[str, str] = _, executable_name: None | str = _, exported_deps: list[str] = _, exported_header_style: str = _, exported_headers: list[str] | dict[str, str] = _, exported_lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, exported_lang_preprocessor_flags: dict[str, list[str]] = _, exported_linker_flags: list[str] = _, exported_needs_coverage_instrumentation: bool = _, exported_platform_deps: list[(str, list[str])] = _, exported_platform_headers: list[(str, list[str] | dict[str, str])] = _, exported_platform_linker_flags: list[(str, list[str])] = _, exported_platform_preprocessor_flags: list[(str, list[str])] = _, exported_post_linker_flags: list[str] = _, exported_post_platform_linker_flags: list[(str, list[str])] = _, exported_preprocessor_flags: list[str] = _, extra_xcode_files: list[str] = _, extra_xcode_sources: list[str] = _, fat_lto: bool = _, focused_list_target: None | str = _, force_static: None | bool = _, frameworks: list[str] = _, header_namespace: None | str = _, headers: list[str] | dict[str, str] = _, headers_as_raw_headers_mode: None | str = _, include_directories: list[str] = _, include_in_android_merge_map_output: bool = _, labels: list[str] = _, lang_compiler_flags: dict[str, list[str]] = _, lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = _, lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, lang_preprocessor_flags: dict[str, list[str]] = _, libraries: list[str] = _, licenses: list[str] = _, link_group: None | str = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_ordering: None | str = _, link_style: None | str = _, link_whole: bool = _, linker_extra_outputs: list[str] = _, linker_flags: list[str] = _, local_linker_flags: list[str] = _, module_name: None | str = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, platform_linker_flags: list[(str, list[str])] = _, platform_preprocessor_flags: list[(str, list[str])] = _, platform_srcs: list[(str, list[str | (str, list[str])])] = _, post_linker_flags: list[str] = _, post_platform_linker_flags: list[(str, list[str])] = _, precompiled_header: None | str = _, preferred_linkage: str = _, prefix_header: None | str = _, preprocessor_flags: list[str] = _, public_include_directories: list[str] = _, public_system_include_directories: list[str] = _, raw_headers: list[str] = _, reexport_all_header_dependencies: None | bool = _, resources: list[str] | dict[str, str] = _, sdk_modules: list[str] = _, soname: None | str = _, srcs: list[str | (str, list[str])] = _, static_library_basename: None | str = _, suffix_all: bool = _, support_shlib_interfaces: bool = _, supported_platforms_regex: None | str = _, supports_merged_linking: None | bool = _, thin_lto: bool = _, type_stub: None | str = _, use_archive: None | bool = _, used_by_wrap_script: bool = _, uses_cxx_explicit_modules: bool = _, uses_explicit_modules: bool = _, version_universe: None | str = _, weak_framework_names: list[str] = _ ) -&gt; None  A cxx_python_extension() rule is a variant of a C/C++ library which is built as a Python module. As such, it has a module name formed by the base_module parameter and the rule name. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onebase_module: The package in which the specified source files and resources should reside in their final location in the top-level binary. If unset, Buck uses the project-relative directory that contains the BUCK file.compiler_flags: Flags to use when compiling any of the above sources (which require compilation).deps: Other rules that list srcs from which this rule imports.header_namespace: A path prefix when including headers of this target. Defaults to the path from the root of the repository to the directory where this target is defined. Can contain forward slashes (/), but cannot start with one. See headers for more information.headers: The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header name can contain forward slashes (/). The headers can be included with #include &quot;$HEADER_NAMESPACE/$HEADER_NAME&quot; or #include &lt;$HEADER_NAMESPACE/$HEADER_NAME&gt; , where $HEADER_NAMESPACE is the value of the target's header_namespace attribute, and $HEADER_NAME is the header name if specified, and the filename of the header file otherwise. See header_namespace for more information.labels: Set of arbitrary strings which allow you to annotate a build rule with tags that can be searched for over an entire dependency tree using buck query() .link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared. Note: since shared libraries re-export its dependencies, depending on multiple shared libraries which themselves have overlapping static dependencies may cause problems if they init using global state.linker_extra_outputs: Declares extra outputs that the linker emits. These identifiers can be used in $(output ...) macros in linker_flags to interpolate the output path into the linker command line. Useful for custom linkers that emit extra output files.linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library.local_linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation driven by this rule (e.g. when this rule links a shared library, but not when the output is linked into a shared library by another rule's link group links).platform_compiler_flags: Platform specific compiler flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when compiling the target's sources. See compiler_flags for more information.platform_headers: Platform specific header files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of header files or a dictionary of header names to header files that will be made available for inclusion to the source files in the target if the platform matches the regex. See headers for more information.platform_linker_flags: Platform-specific linker flags. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use java.util.regex.Pattern syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule is used in a link operation.platform_preprocessor_flags: Platform specific preprocessor flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when preprocessing the target's sources. See preprocessor_flags for more information.platform_srcs: Platform specific source files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of source files or a list of tuples of source files and a list of compilation flags to be preprocessed, compiled and assembled if the platform matches the regex. See srcs for more information.preprocessor_flags: Flags to use when preprocessing any of the above sources (which require preprocessing).srcs: The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the GCC documentation for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. '') or a tuple of a string specifying a source file and a list of compilation flags (e.g. ('', ['-Wall', '-Werror']) ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable). Details​ Examples:  # A rule that builds a Python extension from a single .cpp file. cxx_python_extension( name = 'mymodule', base_module = 'foo.bar', srcs = [ 'mymodule.cpp', ], ) # A library rule which has a single source importing the above extension. python_library( name = 'utils', srcs = [ 'utils.py', ], deps = [ ':mymodule', ], )   ## The `utils.py` source, wrapped by the `utils` rule above. ## Import the C/C++ extension build above. from foo.bar import mymodule ...   "},{"title":"cxx_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#cxx_test","content":"def cxx_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_hacks: str = _, _cxx_toolchain: str = _, _inject_test_env: str = _, _remote_test_execution_toolchain: str = _, additional_coverage_targets: list[str] = _, allow_cache_upload: None | bool = _, anonymous_link_groups: bool = _, args: list[str] = _, auto_link_groups: bool = _, binary_linker_flags: list[str] = _, bolt_flags: list[str] = _, bolt_profile: None | str = _, buck2_compatibility: str = _, compiler_flags: list[str] = _, constraint_overrides: list[str] = _, contacts: list[str] = _, coverage_instrumentation_compiler_flags: list[str] = _, cxx_runtime_type: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, defaults: dict[str, str] = _, deps: list[str] = _, deps_query: None | str = _, devirt_enabled: bool = _, distributed_thinlto_partial_split_dwarf: bool = _, enable_distributed_thinlto: bool = _, env: dict[str, str] = _, executable_name: None | str = _, exported_needs_coverage_instrumentation: bool = _, fat_lto: bool = _, focused_list_target: None | str = _, framework: None | str = _, frameworks: list[str] = _, header_namespace: None | str = _, headers: list[str] | dict[str, str] = _, headers_as_raw_headers_mode: None | str = _, include_directories: list[str] = _, labels: list[str] = _, lang_compiler_flags: dict[str, list[str]] = _, lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = _, lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, lang_preprocessor_flags: dict[str, list[str]] = _, libraries: list[str] = _, licenses: list[str] = _, link_deps_query_whole: bool = _, link_execution_preference: None | str = _, link_group: None | str = _, link_group_deps: list[str] = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_group_min_binary_node_count: None | int = _, link_group_public_deps_label: None | str = _, link_ordering: None | str = _, link_style: None | str = _, link_whole: bool = _, linker_extra_outputs: list[str] = _, linker_flags: list[str] = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, platform_linker_flags: list[(str, list[str])] = _, platform_preprocessor_flags: list[(str, list[str])] = _, platform_srcs: list[(str, list[str | (str, list[str])])] = _, post_linker_flags: list[str] = _, post_platform_linker_flags: list[(str, list[str])] = _, precompiled_header: None | str = _, prefer_stripped_objects: bool = _, prefix_header: None | str = _, preprocessor_flags: list[str] = _, raw_headers: list[str] = _, remote_execution: None | str | dict[str, None | bool | int | str | list[dict[str, str]] | dict[str, str]] = _, remote_execution_action_key_providers: None | str = _, resources: list[str] | dict[str, str] = _, run_test_separately: None | bool = _, srcs: list[str | (str, list[str])] = _, test_rule_timeout_ms: None | int = _, thin_lto: bool = _, use_default_test_main: None | bool = _, version_universe: None | str = _, weak_framework_names: list[str] = _ ) -&gt; None  A cxx_test() rule builds a C/C++ binary against a C/C++ testing framework and runs it as part of test. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one allow_cache_upload: Whether to allow uploading the output of this rule to be uploaded to cache when the action is executed locally if the configuration allows (i.e. there is a cache configured and the client has permission to write to it). args: A list of additional arguments to pass to the test when it's run. It is also possible to expand references to other rules within these arguments, using builtin string parameter macros: $(location //path/to:target)Expands to the location of the output of the build rule. This means that you can refer to these without needing to be aware of how Buck is storing data on the disk mid-build. compiler_flags: Flags to use when compiling any of the above sources (which require compilation). deps_query: Status: experimental/unstable. The deps query takes a query string that accepts the following query functions, and appends the output of the query to the declared deps: attrfilterdepsexceptintersectfilterkindsetunion The macro $declared_deps may be used anywhere a target literal pattern is expected in order to refer to the explicit deps of this rule as they appear in the rule's definition. For example, if your build rule declares android_library( name = 'lib', deps = ['//foo:foo'], deps_query = '$declared_deps', ) then the macro $declared_deps would be expanded to a literal set(//foo:foo). Some example queries: &quot;filter({name_regex}, $declared_deps)&quot;.format(name_regex='//.*') &quot;attrfilter(annotation_processors, com.foo.Processor, $declared_deps)&quot; &quot;deps('//foo:foo', 1)&quot; Note: any targets included in this query must also be present in deps. env: A map of environment names and values to set when running the test. It is also possible to expand references to other rules within the values of these environment variables, using builtin string parameter macros: $(location //path/to:target)Expands to the location of the output of the build rule. This means that you can refer to these without needing to be aware of how Buck is storing data on the disk mid-build. framework: Unused. headers: The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header name can contain forward slashes (/). The headers can be included with #include &quot;$HEADER_NAMESPACE/$HEADER_NAME&quot; or #include &lt;$HEADER_NAMESPACE/$HEADER_NAME&gt; , where $HEADER_NAMESPACE is the value of the target's header_namespace attribute, and $HEADER_NAME is the header name if specified, and the filename of the header file otherwise. See header_namespace for more information. include_directories: A list of include directories (with raw_headers) to be added to the compile command for compiling this target (via -I). An include directory is relative to the current package. link_execution_preference: The execution preference for linking. Options are: any : No preference is set, and the link action will be performed based on buck2's executor configuration.full_hybrid : The link action will execute both locally and remotely, regardless of buck2's executor configuration (if the executor is capable of hybrid execution). The use_limited_hybrid setting of the hybrid executor is ignored.local : The link action will execute locally if compatible on current host platform.local_only : The link action will execute locally, and error if the current platform is not compatible.remote : The link action will execute remotely if a compatible remote platform exists, otherwise locally. The default is None, expressing that no preference has been set on the target itself. link_group_deps: Additional targets to traverse when building link groups, but which should not be direct dependencies of the main executable. link_group_public_deps_label: Surface nodes with this label as &quot;public&quot; nodes in the main executable when linking with with link groups. link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared. linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library. preprocessor_flags: Flags to use when preprocessing any of the above sources (which require preprocessing). raw_headers: The set of header files that can be used for inclusion to the source files in the target and all targets that transitively depend on it. Buck doesn't add raw headers to the search path of a compiler/preprocessor automatically. include_directories and public_include_directories are the recommended way to add raw headers to the search path (they will be added via -I). compiler_flags, preprocessor_flags and exported_preprocessor_flags can also be used to add such raw headers to the search path if inclusion via -isystem or -iquote is needed. raw_headers cannot be used together with headers or exported_headers in the same target. srcs: The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the GCC documentation for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. '') or a tuple of a string specifying a source file and a list of compilation flags (e.g. ('', ['-Wall', '-Werror']) ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable). test_rule_timeout_ms: If set specifies the maximum amount of time (in milliseconds) in which all of the tests in this rule should complete. This overrides the default rule_timeout if any has been specified in .buckconfig . Details​ Examples:  # A rule that builds and runs C/C++ test using gtest. cxx_test( name = 'echo_test', srcs = [ 'echo_test.cpp', ], )   "},{"title":"cxx_toolchain​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#cxx_toolchain","content":"def cxx_toolchain( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _dep_files_processor: str = _, _dumpbin_toolchain_path: None | str = _, _mk_comp_db: str = _, _mk_hmap: str = _, _msvc_hermetic_exec: str = _, _remap_cwd_tool: str = _, archive_contents: str = _, archive_symbol_table: bool = _, archiver: str, archiver_flags: list[str] = _, archiver_reads_inputs: bool = _, archiver_supports_argfiles: bool = _, archiver_type: str, asm_compiler: None | str = _, asm_compiler_flags: list[str] = _, asm_compiler_type: None | str = _, asm_preprocessor: None | str = _, asm_preprocessor_flags: list[str] = _, asm_preprocessor_type: None | str = _, assembler: str, assembler_flags: list[str] = _, assembler_preprocessor: None | str = _, assembler_preprocessor_flags: list[str] = _, assembler_preprocessor_type: None | str = _, assembler_type: None | str = _, binary_extension: None | str = _, bolt_enabled: bool = _, buck2_compatibility: str = _, c_compiler: str, c_compiler_allow_cache_upload: None | bool = _, c_compiler_flags: list[str] = _, c_compiler_type: None | str = _, c_preprocessor_flags: list[str] = _, cache_links: bool = _, clang_remarks: None | str = _, clang_trace: None | bool = _, compiler_type: None | str = _, conflicting_header_basename_exemptions: list[str] = _, contacts: list[str] = _, cpp_dep_tracking_mode: str = _, cuda_compiler: None | str = _, cuda_compiler_flags: list[str] = _, cuda_compiler_type: None | str = _, cuda_dep_tracking_mode: str = _, cuda_preprocessor_flags: list[str] = _, cvtres_compiler: None | str = _, cvtres_compiler_flags: list[str] = _, cvtres_compiler_type: None | str = _, cvtres_preprocessor_flags: list[str] = _, cxx_compiler: str, cxx_compiler_allow_cache_upload: None | bool = _, cxx_compiler_flags: list[str] = _, cxx_compiler_type: None | str = _, cxx_preprocessor_flags: list[str] = _, debug_path_prefix_map_sanitizer_format: None | str = _, default_host_platform: None | str = _, detailed_untracked_header_messages: bool = _, dist_lto_tools: str = _, dist_thin_lto_codegen_flags: list[str] = _, filepath_length_limited: bool = _, gcno_files: bool = _, generate_linker_maps: bool = _, headers_as_raw_headers_mode: None | str = _, headers_whitelist: list[str] = _, hip_compiler: None | str = _, hip_compiler_flags: list[str] = _, hip_compiler_type: None | str = _, hip_preprocessor_flags: list[str] = _, labels: list[str] = _, licenses: list[str] = _, link_ordering: str = _, link_path_normalization_args_enabled: bool = _, link_style: str = _, link_weight: int = _, linker: str, linker_flags: list[str] = _, linker_type: str, llvm_link: None | str = _, lto_mode: str = _, min_sdk_version: None | str = _, nm: str, objcopy_for_shared_library_interface: str, objcopy_recalculates_layout: bool = _, objdump: None | str = _, object_file_extension: str = _, object_format: str = _, pic_behavior: str = _, pic_type_for_shared_linking: str = _, placeholder_tool: None | str = _, platform_name: None | str = _, post_linker_flags: list[str] = _, private_headers_symlinks_enabled: bool = _, public_headers_symlinks_enabled: bool = _, ranlib: None | str = _, ranlib_flags: list[str] = _, rc_compiler: None | str = _, rc_compiler_flags: list[str] = _, rc_compiler_type: None | str = _, rc_preprocessor_flags: list[str] = _, remap_cwd: bool = _, requires_archives: bool = _, requires_objects: bool = _, sanitizer_runtime_enabled: bool = _, sanitizer_runtime_files: list[str] = _, shared_dep_runtime_ld_flags: list[str] = _, shared_library_extension: str = _, shared_library_interface_flags: list[str] = _, shared_library_interface_mode: str = _, shared_library_interface_producer: None | str = _, shared_library_interface_type: str, shared_library_versioned_extension_format: str = _, split_debug_mode: str = _, static_dep_runtime_ld_flags: list[str] = _, static_library_extension: str = _, static_pic_dep_runtime_ld_flags: list[str] = _, strip: str, strip_all_flags: None | list[str] = _, strip_debug_flags: None | list[str] = _, strip_non_global_flags: None | list[str] = _, supports_distributed_thinlto: bool = _, target_sdk_version: None | str = _, use_archiver_flags: bool = _, use_arg_file: bool = _, use_dep_files: None | bool = _, use_header_map: bool = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onec_compiler_allow_cache_upload: Whether to allow uploading of object files to cache when the compile action is executed locally and the configuration allows uploads (i.e., there is a cache configured and the client has permission to write to it).cxx_compiler_allow_cache_upload: Whether to allow uploading of object files to cache when the compile action is executed locally and the configuration allows uploads (i.e., there is a cache configured and the client has permission to write to it).link_style: The default value of the link_style attribute for rules that use this toolchain.  "},{"title":"d_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#d_binary","content":"def d_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, linker_flags: list[str] = _, srcs: list[str] | dict[str, str] = _ ) -&gt; None  A d_binary() rule builds a native executable from the supplied set of D source files and dependencies. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onedeps: The set of dependencies of this rule. Each element should be a string specifying a d_library rule defined elsewhere (e.g. ':foo' or '//foo:bar').linker_flags: The list of flags to be passed to the linker. Each element should be a string specifying a linker flag (e.g. '--as-needed').srcs: The set of D source files to be compiled by this rule. Each element should be a string specifying a source file (e.g. 'foo/bar.d'). Details​ Examples:  # A rule that builds a D native executable from a single .d file # and a library dependency. d_binary( name='greet', srcs=[ 'greet.d', ], deps=[ ':greeting', ], ) d_library( name='greeting', srcs=[ 'greeting.d', ], deps=[ ':join', ], ) d_library( name='join', srcs=[ 'join.d', ], )   "},{"title":"d_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#d_library","content":"def d_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, linker_flags: list[str] = _, srcs: list[str] | dict[str, str] = _ ) -&gt; None  A d_library() rule represents a set of D source files. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onedeps: The set of dependencies of this rule. Each element should be a string specifying a d_library rule defined elsewhere (e.g. ':foo' or '//foo:bar').srcs: The set of D source files to be compiled by this rule. Each element should be a string specifying a source file (e.g. 'foo/bar.d'). Details​ Examples:  # A simple library with a single source file and a single dependency. d_library( name='greeting', srcs=[ 'greeting.d', ], deps=[ ':join', ], ) d_library( name='join', srcs=[ 'join.d', ], )   "},{"title":"d_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#d_test","content":"def d_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, linker_flags: list[str] = _, srcs: list[str] | dict[str, str] = _, test_rule_timeout_ms: None | int = _ ) -&gt; None  A d_test() rule is used to define a set of D source files that contain tests to run via D's unittest support. The source code of the test must provide a main() function. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onedeps: The set of dependencies of this rule. Each element should be a string specifying a d_library rule defined elsewhere (e.g. ':foo' or '//foo:bar').labels: A list of labels to be applied to these tests. These labels are arbitrary text strings and have no meaning within buck itself. They can, however, have meaning for you as a test author (e.g., smoke or fast). A label can be used to filter or include a specific d_test() rule when executing buck testsrcs: The set of D source files to be compiled by this rule. Each element should be a string specifying a source file (e.g. 'foo/bar.d').test_rule_timeout_ms: If set specifies the maximum amount of time (in milliseconds) in which all of the tests in this rule should complete. This overrides the default rule_timeout if any has been specified in .buckconfig . Details​ Examples:  # A rule that builds and runs D test with a single source file. d_test( name = 'test', srcs = [ 'test.d', ], )   "},{"title":"erlang_app​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#erlang_app","content":"def erlang_app( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _toolchain: str = _, app_src: None | str = _, applications: list[str] = _, buck2_compatibility: str = _, build_edoc_chunks: bool = _, contacts: list[str] = _, env: None | dict[str, str] = _, erl_opts: None | list[str] = _, extra_includes: list[str] = _, extra_properties: None | dict[str, str | list[str]] = _, include_src: bool = _, included_applications: list[str] = _, includes: list[str] = _, labels: list[str] = _, mod: None | (str, list[str]) = _, os_env: None | dict[str, str] = _, peek_private_includes: bool = _, resources: list[str] = _, shell_configs: list[str] = _, shell_libs: list[str] = _, srcs: list[str] = _, use_global_parse_transforms: bool = _, version: str = _, xrl_includefile: None | str = _, yrl_includefile: None | str = _ ) -&gt; None  This rule is the main rule for Erlang applications. It gets generated by using the erlang_application macro, that takes as attributes the same attributes as this rule. You should always use the erlang_application macro instead of using this rule directly. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one app_src: The app_src field allows to optionally reference a *.app.src template file. This template file will then be used by buck2 to generate the *.app output file in the applications ebin/ directory. This is useful during the migration from rebar3 to buck2 to avoid duplicated entries, of e.g. the version. Buck2 will use or check all fields present in the template, and fill out the fields with the information provided in the target, e.g. if the version is specified in both, buck2 will check that they are identical. Otherwise, it uses the information from the template if the target doesn't specify it, and vice versa. NOTE: If you use the app_src field and the references application resource file template specifies applicationsor included_applications buck2 checks that the target definitions and information in the template are equivalent to prevent these definitions from drifting apart during migration. applications: Equivalent to the corresponding applications and included_applications fields you will find in *.app.src or *.app files and specify the application dependencies. Contrary to the fields in the *.app.src or *.app files, it is necessary to use target paths to the application where a dependency is desired. These fields will be used to construct equally named fields in the generated *.app file for the application. OTP applications are specified with the target path prelude//erlang/applications:&lt;application&gt;. NOTE: If you use the app_src field and the references application resource file template specifiesapplications or included_applications buck2 checks that the target definitions and information in the template are equivalent to prevent these definitions from drifting apart during migration. build_edoc_chunks: This attribute controls if the output of the builds also create edoc chunks. env: The env field allows to set the application env variables. The key value pairs will materialise in the application's .app file and can then be accessed by application:get_env/2. erl_opts: Typically compile options are managed by global config files, however, sometimes it is desirable to overwrite the pre-defined compile options. The erl_opts field allows developers to do so for individual applications. The main use-case are the applications listed in third-party/. This option should not be used by other applications without consultation. Please ask in the WhatsApp Dev Infra Q&amp;Aworkplace group for support. extra_includes: In some cases we might have the situation, where an application app_a depends through the applications and included_applications fields on application app_b and a source file in app_b includes a header file from app_a (e.g. -include_lib(&quot;app_a/include/header.hrl). This technically creates circular dependency from app_a to app_b (e.g. via applications field) and back from app_b to app_a (via -include_lib). To break the dependency developers can specify targets in the extra_includes field, whose public include files are accessible to the application target during build time. Only the includes of the specified application are available and eventual transitive dependencies need to be managed manually. NOTE: It is not possible (or even desired) to add OTP applications with this field. NOTE: This mechanism is added to circumvent unclean dependency relationships and the goal for developers should be to reduce usages of this field. DO NOT ADD ANY MORE USAGES!! extra_properties: The extra_properties field can be used to specify extra key-value pairs which is are not defined in application_opt(). The key-value pair will be stored in the applications .app file and can be accessed by file:consult/1. include_src: This field controls if the generated application directory contains a src/ directory with the Erlang code or not. included_applications: Check the documentation for applications. includes: The public header files accessible via -include_lib(&quot;appname/include/header.hrl&quot;) from other erlang files. mod: The mod field specifies the equivalent field in the generated *.app files. The format is similar, with the difference, that the module name, and the individual start arguments need to be given as the string representation of the corresponding Erlang terms. os_env: This attribute allows to set additional values for the operating system environment for invocations to the Erlang toolchain. peek_private_includes: This attribute allows you to use the private includes of the application's dependencies. This can be useful for test applications, to create shared abstractions for tests. It's not advisable to use this attribute for prodution code. All private includes transitively must be non-ambiguous. resources: The resources field specifies targets whose default output are placed in the applications priv/ directory. For regular files this field is typically combined with export_file, filegroup, or similar targets. However, it is general, and any target can be used, e.g. if you want to place a built escript in the priv/ directory, you can use an erlang_escript target. shell_configs: This attribute allows to set config files for the shell. The dependencies that are typically used here are export_file targets. shell_libs: This attribute allows to define additional dependencies for the shell. By default this is set to [&quot;prelude//erlang/shell:buck2_shell_utils&quot;] which includes a user_default module that loads and compiles modules with buck2 mechanisms. srcs: A list of *.erl, *.hrl, *.xrl, or *.yrl source inputs that are typically located in an application's src/ folder. Header files (i.e. *.hrl files) specified in this field are considered application private headers, and can only be accessed by the *.erl files of the application itself. *.xrl and *.yrl files are processed into *.erl files before all *.erl files are compiled into *.beam files. use_global_parse_transforms: This field indicates if global parse_tranforms should be applied to this application as well. It often makes sense for third-party dependencies to not be subjected to global parse_transforms, similar to OTP applications. version: The version field specifies the applications version that is materialized as vsn field in the generated *.app file. If you use the the app_src field and specify a version in the referenced template in addition to the version field, the versions need to be identical. If no version is specified in either the app_src template or the version field, a fallback version string of&quot;1.0.0&quot; is used. xrl_includefile: Customised prologue file to replace the default. See includefile option for details. yrl_includefile: Customised prologue file to replace the default. See includefile option for details. Details​ Erlang Applications are the basic building block of our buck2 integration and used by many other Erlang targets, e.g. erlang_escript, erlang_test, or erlang_release. The erlang_application targets build OTP applications and as such many attributes that are used have equivalent meaning to the fields in the currently (by rebar3) used *.app.src files and OTP *.appfiles. Please familiarize yourself with the semantics of these fields by consulting theOTP documentation. The target enforces uniqueness during builds, and fails to build if duplicated artifacts in the global namespaces are detected: duplicated application names in the dependenciesduplicated module names across any of the applications or dependencies modulesambiguity when resolving header files The default output of this rule is the application folder of the target application and all transitive dependencies. Examples: Minimal Erlang Application​ erlang_application( name = &quot;minimal&quot;, )  With priv/ directory​ erlang_application( name = &quot;app_a&quot;, srcs = [ &quot;src/app_a.erl&quot;, ], includes = [], applications = [ &quot;:app_b&quot;, ], app_src = &quot;src/app_a.app.src&quot;, resources = [ &quot;:readme&quot;, ], ) export_file( name = &quot;readme&quot;, src = &quot;README.md&quot;, )  Using OTP applications and mod field​ erlang_application( name = &quot;app_b&quot;, srcs = [ &quot;src/app_b.erl&quot;, &quot;src/app_b.hrl&quot;, ], includes = [], applications = [ &quot;kernel&quot;, &quot;stdlib&quot;, &quot;:app_c&quot;, ], mod = (&quot;app_b&quot;, [ &quot;some_atom&quot;, &quot;&quot;some string&quot;&quot;, &quot;{tagged_tuple, 42}&quot;, ]), )  Using Yecc and Leex​ erlang_application( name = &quot;yecc_leex&quot;, srcs = [ &quot;src/leex_stub.xrl&quot;, &quot;src/yecc_stub.yrl&quot;, ], )   "},{"title":"erlang_app_includes​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#erlang_app_includes","content":"def erlang_app_includes( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _toolchain: str = _, application_name: str, buck2_compatibility: str = _, contacts: list[str] = _, includes: list[str] = _, labels: list[str] = _, os_env: None | dict[str, str] = _ ) -&gt; None  This rule is a supplementary rule for Erlang applications. It gets generated by using the erlang_application macro, that takes as attributes the same attributes as this rule. You should always use the erlang_application macro instead of using this rule directly. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneos_env: This attribute allows to set additional values for the operating system environment for invocations to the Erlang toolchain.  "},{"title":"erlang_escript​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#erlang_escript","content":"def erlang_escript( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _toolchain: str = _, buck2_compatibility: str = _, bundled: bool = _, configs: list[str] = _, contacts: list[str] = _, deps: list[str], emu_args: list[str] = _, include_priv: bool = _, labels: list[str] = _, main_module: None | str = _, os_env: None | dict[str, str] = _, resources: list[str] = _, script_name: None | str = _ ) -&gt; None  The erlang_escript target builds and runs bundled escripts. Please refer to the OTP documentation for more details about escripts. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one bundled: Setting bundled to True does generate a folder structure and escript trampoline instead of an archive. configs: This attribute allows to set config files for the escript. The dependencies that are typically used here are export_file targets. deps: List of Erlang applications that are bundled in the escript. This includes all transitive dependencies as well. emu_args: This field specifies the emulator flags that the escript uses on execution. It is often desirable to specify the number of threads and schedulers the escript uses. Please refer to the OTP documentation for details. include_priv: Setting this flag, will package the applications priv directory in the escript. Similar to files added through the resources field, the priv folders files can then be accessed by escript&quot;extract/2. main_module: Overrides the default main module. Instead of deferring the main module from the scripts filename, the specified module is used. That module needs to export a main/1 function that is called as entry point. os_env: This attribute allows to set additional values for the operating system environment for invocations to the Erlang toolchain. resources: This adds the targets default output to the escript archive. To access these files, you need to use escript:extract/2, which will extract the entire escript in memory. The relevant files can then be accessed through the archive section. Please refer to the escript:extract/2 for more details. script_name: Overrides the filename of the produced escript. Details​ Escripts by default always try to use the module that has the same name as the escripts basename as entry point, e.g. if the escript is called script.escript then running the escript will try to call script:main/1. Both name and main module can be overwritten though. The target name doubles as the default escript name. If the main_module attribute is not used, the escript filename will be &lt;name&gt;.escript. Examples: erlang_escript( name = &quot;script&quot;, main_module = &quot;main_module&quot;, script_name = &quot;the_script&quot;, deps = [ &quot;:escript_app&quot;, ], emu_args = [&quot;+sbtu&quot;, &quot;+A1&quot;], ) erlang_application( name = &quot;escript_app&quot;, srcs = [&quot;src/main_module.erl&quot;], applications = [ &quot;kernel&quot;, &quot;stdlib&quot;, ], )   "},{"title":"erlang_otp_binaries​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#erlang_otp_binaries","content":"def erlang_otp_binaries( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, erl: str, erlc: str, escript: str, labels: list[str] = _, os_env: None | dict[str, str] = _ ) -&gt; None  This target defines the executables for the Erlang toolchains, and is required to defined a toolchain. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneerl: Reference to erl binaryerlc: Reference to erlc binaryescript: Reference to escript binaryos_env: This attribute allows to set additional values for the operating system environment for invocations to the Erlang toolchain. Details​ Examples: erlang_otp_binaries( name = &quot;local&quot;, erl = &quot;local/erl&quot;, erlc = &quot;local/erlc&quot;, escript = &quot;local/escript&quot;, )  "},{"title":"erlang_release​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#erlang_release","content":"def erlang_release( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _toolchain: str = _, applications: list[str | (str, str)], buck2_compatibility: str = _, contacts: list[str] = _, include_erts: bool = _, labels: list[str] = _, multi_toolchain: None | list[str] = _, os_env: None | dict[str, str] = _, overlays: dict[str, list[str]] = _, release_name: None | str = _, version: str = _ ) -&gt; None  The erlang_release target builds OTP releases. Please refer to the OTP documentation for more details about releases. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneapplications: This field specifies the list of applications that the release should start in the given order, and optionally the start type. Top-level applications without given start type are started with type permanent.include_erts: This field controls whether OTP applications and the Erlang runtime system should be included as part of the release. Please note, that at the moment the erts folder is just erts/.multi_toolchain: This field controls whether the release should be built with a single toolchain, or multiple toolchains. In the latter case, all output paths are prefixed with the toolchain name.os_env: This attribute allows to set additional values for the operating system environment for invocations to the Erlang toolchain.overlays: Overlays can be used to add files to the release. They are specified as mapping from path (from the release root) to list of targets. The targets files are places flat at the target location with their basename.release_name: The release name can explicitly be set by this field. This overwrites the default from the target name.version: The version field specifies the release version. The release version is used in the release resource file, and is part of the path for the folder containing the boot scripts. Details​ The erlang_release target does by default (without overlays) package: applications that are required to start the releaserelease resource file &lt;relname&gt;.rel (see rel(4))boot script start.script (see rel(4))binary boot script start.bootbin/release_variables The release_variables file contains release name, version, and erts version in shell syntax, e.g. ERTS_VSN=&quot;12.1.2&quot; REL_NAME=&quot;rel1&quot; REL_VSN=&quot;1.0.0&quot;  The target name doubles as the default release name. If the release_name attribute is used, the release name will be sources from there instead. Examples: erlang_release( name = &quot;world&quot;, version = &quot;1.0.0&quot;, applications = [ &quot;//apps//app_a:app_a&quot;, &quot;//apps//app_b:app_b&quot;, ], overlays = { &quot;releases/1.0.0&quot;: [ &quot;:sys.config.src&quot;, ], &quot;bin&quot;: [ &quot;:start.sh&quot;, ], }, ) export_file( name = &quot;sys.config.src&quot;, src = &quot;sys.config&quot;, ) export_file( name = &quot;start.sh&quot;, src = &quot;start.sh&quot;, )   "},{"title":"erlang_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#erlang_test","content":"def erlang_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _artifact_annotation_mfa: str = _, _cli_lib: str = _, _ct_opts: str = _, _providers: str = _, _test_binary: str = _, _test_binary_lib: str = _, _toolchain: str = _, _trampoline: None | str = _, _trampolines: None | list[str] = _, buck2_compatibility: str = _, common_app_env: dict[str, str] = _, config_files: list[str] = _, contacts: list[str] = _, deps: list[str] = _, env: dict[str, str] = _, extra_ct_hooks: list[str] = _, extra_erl_flags: list[str] = _, labels: list[str] = _, os_env: None | dict[str, str] = _, preamble: str = _, property_tests: list[str] = _, remote_execution: None | str | dict[str, None | bool | int | str | list[dict[str, str]] | dict[str, str]] = _, resources: list[str] = _, shell_configs: list[str] = _, shell_libs: list[str] = _, suite: str ) -&gt; None  The erlang_test ruls defines a test target for a single test suite. In most cases you want to define multiple suites in one go. The erlang_tests macro allows users to generate erlang_test targets for multiple test suites. Each suite &lt;name&gt;_SUITE.erl will have a generated hidden erlang_test target whose name is &lt;name&gt;_SUITE. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one _trampoline: DEPRECATED. Use _trampolines instead. common_app_env: Application environment variables for the common application. config_files: Will specify what config files the erlang beam machine running test with should load, for reference look at OTP documentation. These ones should consist of default_output of some targets. In general, this field is filled with target coming from then export_file rule, as in the example below. deps: The set of dependencies needed for all suites included in the target to compile and run. They could be either erlang_app(lication) or erlang_test targets, although the latter is discouraged. If some suites need to access common methods, a common helper file should be created and included in the srcs field of the erlang_tests target. If some applications are included as dependencies of this target, their private include will automatically be pulled and made available for the test. That allows tests to access the private header files from the applications under test. env: Add the given values to the environment variables with which the test is executed. extra_ct_hooks: List of additional Common Test hooks. The strings are interpreted as Erlang terms. extra_erl_flags: List of additional command line arguments given to the erl command invocation. These arguments are added to the front of the argument list. os_env: This attribute allows to set additional values for the operating system environment for invocations to the Erlang toolchain. resources: The resources field specifies targets whose default output are placed in the test data_dir directory for all the suites present in the macro target. Additionally, if data directory are present in the directory along the suite, this one will be pulled automatically for the relevant suite. Any target can be used, e.g. if you want to place a built escript in the data_dir directory, you can use an erlang_escript target. shell_configs: This attribute allows to set config files for the shell. The dependencies that are typically used here are export_file targets. shell_libs: This attribute allows to define additional dependencies for the shell. By default this is set to [&quot;prelude//erlang/shell:buck2_shell_utils&quot;] which includes a user_default module that loads and compiles modules with buck2 mechanisms. suite: The source file for the test suite. If you are using the macro, you should use the suites attribute instead. The suites attribute specifies which erlang_test targets should be generated. For each suite &quot;path_to_suite/suite_SUITE.erl&quot; an implicit 'erlang_test' target suite_SUITE will be generated. Details​ Each erlang_test target implements tests using the Common Test libraryOTP documentation. They can, although it is not recommended, also act as dependencies of other tests. The default output of this rule is a &quot;test_folder&quot;, consisting of the compiled test suite and the data directory. For each suite &lt;name&gt;_SUITE.erl, if a data_dir &lt;name&gt;_SUITE_data is present along the suite, (as per the data_dir naming scheme for ct), it will automatically adds the corresponding resource target to the generated test target of the suite. Resources will be placed in the Data directory (data_dir)of each of the suite. It allows the writer of the rule to add global configuration files and global default dependencies (e.g meck). These ones should be specified using global variables erlang.erlang_tests_default_apps and erlang.erlang_tests_default_configrespectively. The erlang_tests macro forwards all attributes to the erlang_test. It defines some attributes that control how the targets get generated: srcs ([source]): Set of files that the suites might depend on and that are not part of any specific application. A &quot;meta&quot; application having those files as sources will automatically be created, and included in the dependencies of the tests. One can call buck2 build //my_app:test_SUITE to compile the test files together with its dependencies.buck2 test //my_app:other_test_SUITE to run the test.buck2 run //my_app:other_test_SUITE to open an interactive test shell, where tests can be run iteratively. buck2 test will rely on tpx to run the suite. To get access to tpx commands, add -- after the target. For example: buck2 test //my_app:other_test_SUITE -- --help will print the list of tpx available command line parameters.buck2 test //my_app:other_test_SUITE -- group.mycase will only run those test cases that match the pattern group.mycase Examples: erlang_test( name = &quot;unit_test_SUITE&quot;, suite = &quot;unit_test_SUTIE.erl&quot;, deps = [&quot;:my_other_app&quot;], contacts = [&quot;author@email.com&quot;], ) erlang_tests( suites = [&quot;test_SUITE.erl&quot;, &quot;other_test_SUITE&quot;.erl], deps = [&quot;:my_app&quot;], contacts = [&quot;author@email.com&quot;], )  "},{"title":"export_file​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#export_file","content":"def export_file( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, mode: None | str = _, out: None | str = _, src: None | str = _ ) -&gt; None  An export_file() takes a single file or folder and exposes it so other rules can use it. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onemode: How files are referenced internally in buck. If set to 'copy', then a full copy will be made into the new location in buck-out. If set to 'reference', the original file will be used by internal build rules in-place. However, this mode does not work across repositories or if the 'out' property is set. For read-only operations, 'reference' can be more performant.out: The name which the file will be called if another rule depends on it instead of the name it already has.src: The path to the file that should be exported. Details​ Examples: The best way to see how the export_file() rule works is with some examples. The common case is:  export_file( name = 'example.html', ) # This is equivalent to export_file( name = 'example.html', src = 'example.html', out = 'example.html', )  It is sometimes useful to refer to the file not by its path, but by a more logical name:  export_file( name = 'example', src = 'example.html', ) # This is equivalent to export_file( name = 'example', src = 'example.html', out = 'example.html', )  Finally, there are occasions where you want to export a file more than once but want to copy it to a different name for each output:  export_file( name = 'runner', src = 'RemoteRunner.html', ) export_file( name = 'runner_hta', src = 'RemoteRunner.html', out = 'RemoteRunner.hta', )  Using the export_file() rule is also simple:  export_file( name = 'example', src = 'example.html', ) genrule( name = 'demo', out = 'result.html', cmd = 'cp $(location :example) $OUT', )   "},{"title":"external_test_runner​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#external_test_runner","content":"def external_test_runner( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, binary: str, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"filegroup​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#filegroup","content":"def filegroup( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, copy: bool = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, srcs: list[str] | dict[str, str] = _ ) -&gt; None  This rule provides access to a set of files. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onesrcs: The set of files to include in this rule. Details​ Files are accessible to genrule()s by using their relative path after a $(location) string parameter macro. Other rules may handle filegroup() rules natively for attributes such as resources. Examples: In this example a target exports .xml files from all subdirectories in resources.  filegroup( name = 'example', srcs = glob(['resources/**/*.xml']), ) genrule( name = 'process_xml', out = 'processed.xml', cmd = '$(exe //example:tool) -in $(location :example)/resources/file.xml &gt; $OUT', )   "},{"title":"gen_aidl​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#gen_aidl","content":"def gen_aidl( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _exec_os_type: str = _, _java_toolchain: str = _, aidl: str, aidl_srcs: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, import_path: str = _, import_paths: list[str] = _, labels: list[str] = _, licenses: list[str] = _ ) -&gt; None  A gen_aidl() rule is used to generate .java files from .aidl files. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneaidl: The path to an .aidl file to convert to a .java file.aidl_srcs: Path to .aidl files the target aidl file imports.deps: A list of rules that must be built before this rule.import_path: The search path for import statements for the aidl command. (This is the -I argument when invoking aidl from the command line. For many apps it will be the base dir where all aidl files are, with project root as its parent, e.g. app/src/main/aidl.). This is the same as the path to the aidl file relative to what would be returned from root. Details​ Examples:  android_library( name = 'lib', srcs = glob(['**/*.java']) + [':aidl'], manifest = '//res/org/opencv:manifest', deps = [ '//res/org/opencv:res', ], visibility = [ 'PUBLIC' ], ) gen_aidl( name = 'aidl', aidl = 'engine/OpenCVEngineInterface.aidl', import_path = 'java/', )   "},{"title":"genrule​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#genrule","content":"def genrule( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _exec_os_type: str = _, _genrule_toolchain: str = _, always_print_stderr: bool = _, bash: None | str = _, buck2_compatibility: str = _, cacheable: None | bool = _, cmd: None | str = _, cmd_exe: None | str = _, contacts: list[str] = _, default_host_platform: None | str = _, default_outs: None | list[str] = _, enable_sandbox: None | bool = _, env: dict[str, str] = _, environment_expansion_separator: None | str = _, executable: None | bool = _, labels: list[str] = _, licenses: list[str] = _, metadata_env_var: None | str = _, metadata_path: None | str = _, need_android_tools: bool = _, no_outputs_cleanup: bool = _, out: None | str = _, outs: None | dict[str, list[str]] = _, remote: None | bool = _, remote_execution_dependencies: list[dict[str, str]] = _, srcs: list[str] | dict[str, str] = _, type: None | str = _, weight: None | int = _ ) -&gt; None  A genrule() is used to generate files from a shell command. It must produce a single output file or folder. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one bash: A platform-specific version of the shell command parameter cmd. It runs on Linux and UNIX systems—including OSX—on which bash is installed. It has a higher priority than cmd. The bash argument is run with /usr/bin/env bash -c. It has access to the same set of macros and variables as the cmd argument. cmd: The shell command to run to generate the output file. It is the fallback for bash and cmd_exe arguments. The following environment variables are populated by Buck and available to the shell command. They are accessed using the syntax: ${&lt;variable&gt;} Example: ${SRCS} ${SRCS} A string expansion of the srcs argument delimited by the environment_expansion_separator argument where each element of srcs will be translated into a relative path. ${SRCDIR} The relative path to a directory to which sources are copied prior to running the command. ${OUT} The output file or directory for the genrule(). This variable will have whatever value is specified by the out argument if not using named outputs. If using named outputs, this variable will be the output directory. The value should be a valid filepath. The semantics of the shell command determine whether this filepath is treated as a file or a directory. If the filepath is a directory, then the shell command needs to create it if not using named outputs. Otherwise, it will be automatically created. All outputs (directories and files) must be readable, writable, and (in the case of directories) executable by the current user. The file or directory specified by this variable must always be written by this command. If not, the execution of this rule will be considered a failure, halting the build process. ${TMP} A temporary directory which can be used for intermediate results and will not be bundled into the output. cmd_exe: A platform-specific version of the shell command parameter cmd. It runs on Windows and has a higher priority than cmd. The cmd_exe argument is run with cmd.exe /v:off /c. It has access to the same set of macros and variables as the cmd argument. default_outs: Default output which must be present if the outs arg is present. Otherwise does not apply. If a rule with outs is consumed without an output label, the default output is returned. The default output does not need to be present in any of the named outputs defined in outs. Note that a maximum of one value may be present in this list. For example: default_outs = [ &quot;output_one&quot;, ] is valid, whereas default_outs = [ &quot;output_one&quot;, &quot;output_two&quot;, ] is not. enable_sandbox: Whether this target should be executed in a sandbox or not. env: A map of variables to be set in the environment where the shell command is run. environment_expansion_separator: The delimiter between paths in environment variables, such as SRCS, that can contain multiple paths. It can be useful to specify this parameter if the paths could contain spaces. executable: Whether the output of the genrule is itself executable. Marking an output as executable makes buck run and $(exe ...) macro expansion work with this target. out: The name of the output file or directory. The complete path to this argument is provided to the shell command through the OUT environment variable. Only one of out or outs may be present. outs: Mapping defining named outputs to output paths relative to the rule's output directory. Only one of out or outs may be present. Example: genrule( name = &quot;named_outputs&quot;, outs = { &quot;output1&quot;: [ &quot;out1.txt&quot;, ], &quot;output2&quot;: [ &quot;out2.txt&quot;, ], }, default_outs = [ &quot;out1.txt&quot; ], cmd = &quot;echo something&gt; $OUT/out1.txt &amp;&amp; echo another&gt; $OUT/out2.txt&quot;, ) Note that a maximum of one value may be present in the list in this map. For example: outs = { &quot;output1&quot;: [ &quot;out1.txt&quot;, ], }, is valid, whereas outs = { &quot;output1&quot;: [ &quot;out1.txt&quot;, &quot;out2.txt&quot;, ], }, is not. remote: Opts this genrule in to remote execution. Note that it is only safe to execute a genrule remotely if it is completely hermetic and completely and correctly describes its dependencies. Defaults to false. This parameter is unstable. It is subject to removal, default reversal, and other arbitrary changes in the future. srcs: Either a list or a map of the source files which Buck makes available to the shell command at the path in the SRCDIR environment variable. If you specify a list, the source files are the names in the list. If you specify a map, the source files are made available as the names in the keys of the map, where the values of the map are the original source file names. type: Specifies the type of this genrule. This is used for logging and is particularly useful for grouping genrules that share an underlying logical &quot;type&quot;. For example, if you have the following cxx_genrule defined in the root directory of your Buck project cxx_genrule( name = 'cxx_gen', type = 'epilog', cmd = 'touch finish.txt; cp finish.txt $OUT', out = 'finish.txt' ) then the following buck query command buck query &quot;attrfilter( type, 'epilog', '//...' )&quot; returns //:cxx_gen weight: How many local slots these genrule should take when executing locally. Details​ Examples: This genrule() uses a Python script to derive a newAndroidManifest.xml from anAndroidManifest.xml in the source tree. Note you don't need to prepend execution commands withpython: Buck knows how to execute different kinds of binaries using $(exe) command.  genrule( name = 'generate_manifest', srcs = [ 'AndroidManifest.xml', ], bash = '$(exe //python/android:basic_to_full) ' '$SRCDIR/AndroidManifest.xml &gt; $OUT', cmd_exe = '$(exe //python/android:basic_to_full) ' '%SRCDIR%\\AndroidManifest.xml &gt; %OUT%', out = 'AndroidManifest.xml', )   genrule( name = 'generate_manifest_with_named_outputs', srcs = [ 'AndroidManifest.xml', ], bash = '$(exe //python/android:basic_to_full) ' '$SRCDIR/AndroidManifest.xml &gt; $OUT/AndroidManifest.xml', cmd_exe = '$(exe //python/android:basic_to_full) ' '%SRCDIR%\\AndroidManifest.xml &gt; %OUT%\\AndroidManifest.xml', outs = { &quot;manifest&quot;: [ &quot;AndroidManifest.xml&quot; ], }, default_outs = [ &quot;AndroidManifest.xml&quot; ], )  For named outputs, build with any of the following:  buck build //:generate_manifest_with_named_outputs   buck build //:generate_manifest_with_named_outputs[manifest]  Consume in srcs with:  export_file( name = &quot;magic1&quot;, src = &quot;:generate_manifest_with_named_outputs&quot;, out = &quot;some_dir_to_copy_to/AndroidManifest.xml&quot;, )   export_file( name = &quot;magic2&quot;, src = &quot;:generate_manifest_with_named_outputs[manifest]&quot;, out = &quot;some_dir_to_copy_to/AndroidManifest.xml&quot;, )  Note that magic1 consumes generate_manifest_with_named_outputs's default output. magic2 consumes generate_manifest_with_named_outputs's named output &quot;manifest,&quot; which happen to be pointing to the same output as the default output in this case, but they do not have to point to the same output.  "},{"title":"git_fetch​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#git_fetch","content":"def git_fetch( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _git_fetch_tool: str = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, repo: str, rev: str ) -&gt; None  Checkout a commit from a git repository. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onerepo: Url suitable as a git remote.rev: 40-digit hex SHA-1 of the git commit. Details​ Examples: git_fetch( name = &quot;serde.git&quot;, repo = &quot;https://github.com/serde-rs/serde&quot;, rev = &quot;fccb9499bccbaca0b7eef91a3a82dfcb31e0b149&quot;, )   "},{"title":"go_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#go_binary","content":"def go_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _asan: bool = _, _cxx_toolchain: str = _, _exec_os_type: str = _, _go_stdlib: str = _, _go_toolchain: str = _, _race: bool = _, _tags: list[str] = _, asan: bool = _, assembler_flags: list[str] = _, buck2_compatibility: str = _, cgo_enabled: None | bool = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, embedcfg: None | str = _, external_linker_flags: list[str] = _, labels: list[str] = _, licenses: list[str] = _, link_mode: None | str = _, link_style: None | str = _, linker_flags: list[str] = _, package_root: None | str = _, platform: None | str = _, race: bool = _, resources: list[str] = _, srcs: list[str] = _, tags: list[str] = _ ) -&gt; None  A go_binary() rule builds a native executable from the supplied set of Go source files and dependencies. The files supplied are expected to be in the main package, implicitly. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneasan: If true, enable ASAN.assembler_flags: The set of additional assembler flags to pass to go tool asm.cgo_enabled: Experimental: Analog of CGO_ENABLED environment-variable. None will be converted to True if cxx_toolchain available for current configuration, otherwise False.compiler_flags: The set of additional compiler flags to pass to go tool compile.deps: The set of dependencies of this rule. Currently, this only supports go_library rules.external_linker_flags: Extra external linker flags passed to go link via -extld argument. If argument is non-empty or cgo_library is used, the link mode will switch to external.link_mode: Determines the link mode (equivalent of -mode). Can be one of the following values: internal, external. If no value is provided, the mode is set automatically depending on the other args.link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be one of the following values: static, static_pic or shared. This argument is relevant only if the cgo extension is enabled. Otherwise, Buck ignores this argument.linker_flags: Extra linker flags passed to go linkpackage_root: Sets Go package direactory (relative to BUCK file). By default (or if None passes) package_root is being detected automatically. Empty string of Go package is on the same level as BUCK file otherwise the subdirectory name. Example for srcs = [&quot;foo/bar.go&quot;], package_root = &quot;foo&quot;race: If true, enable data race detection.srcs: The set of source files to be compiled by this rule. .go files will be compiled with the Go compiler, .s files will be compiled with the assembler, and everything else is assumed to be files that may be #included by the assembler.tags: Build tags to apply to this target and its dependencies. Details​ Examples: For more examples, check out our integration tests.  go_binary( name='greet', srcs=[ 'main.go', ], deps=[ ':greeting', ], ) go_library( name='greeting', srcs=[ 'greeting.go', ], deps=[ ':join', ], ) go_library( name='join', srcs=[ 'join.go', ], )   "},{"title":"go_bootstrap_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#go_bootstrap_binary","content":"def go_bootstrap_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _exec_os_type: str = _, _go_bootstrap_toolchain: str = _, buck2_compatibility: str = _, entrypoints: list[str] = _, srcs: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneentrypoints: Package name or file namessrcs: The set of source files to be compiled by this rule. .go files will be compiled with the Go compiler, .s files will be compiled with the assembler, and everything else is assumed to be files that may be #included by the assembler.  "},{"title":"go_exported_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#go_exported_library","content":"def go_exported_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _asan: bool = _, _cxx_toolchain: str = _, _exec_os_type: str = _, _go_stdlib: str = _, _go_toolchain: str = _, _race: bool = _, _tags: list[str] = _, asan: bool = _, assembler_flags: list[str] = _, buck2_compatibility: str = _, build_mode: str, cgo_enabled: None | bool = _, compiler_flags: list[str] = _, contacts: list[str] = _, cxx_compiler_flags: list[str] = _, cxx_preprocessor_flags: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, embedcfg: None | str = _, external_linker_flags: list[str] = _, generate_exported_header: bool = _, header_namespace: None | str = _, headers: list[str] | dict[str, str] = _, labels: list[str] = _, licenses: list[str] = _, link_mode: None | str = _, link_style: None | str = _, linker_flags: list[str] = _, package_root: None | str = _, platform: None | str = _, race: bool = _, resources: list[str] = _, srcs: list[str] = _, tags: list[str] = _ ) -&gt; None  A go_exported_library() rule builds a C library from the supplied set of Go source files and dependencies. This is done via -buildmode flag and &quot;//export&quot; annotations in the code. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneasan: If true, enable ASAN.assembler_flags: The set of additional assembler flags to pass to go tool asm.build_mode: Determines the build mode (equivalent of -buildmode). Can be one of the following values: c_archive, c_shared. This argument is valid only if at there is at least one cgo_library declared in deps. In addition you should make sure that -sharedflag is added tocompiler_flagsand go version undergo.gorootis compiled with that flag present in:gcflags, ldflagsandasmflags``cgo_enabled: Experimental: Analog of CGO_ENABLED environment-variable. None will be converted to True if cxx_toolchain available for current configuration, otherwise False.compiler_flags: The set of additional compiler flags to pass to go tool compile.cxx_compiler_flags: GCC/Clang flags to use when compiling any of the above C/C++ sources (which require compilation).cxx_preprocessor_flags: GCC/Clang flags to use when preprocessing any of the above C/C++ sources (which require preprocessing).deps: The set of dependencies of this rule. Currently, this only supports go_library rules.external_linker_flags: Extra external linker flags passed to go link via -extld argument. If argument is non-empty or cgo_library is used, the link mode will switch to external.generate_exported_header: Generate header file with declaration for functions exported with //export The header name for target cell//foo/bar:lib will be foo/bar/lib.hheader_namespace: A path prefix when including headers of this target. Defaults to the path from the root of the repository to the directory where this target is defined. Can contain forward slashes (/), but cannot start with one. See headers for more information.headers: The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header name can contain forward slashes (/). The headers can be included with #include &quot;$HEADER_NAMESPACE/$HEADER_NAME&quot; or #include &lt;$HEADER_NAMESPACE/$HEADER_NAME&gt; , where $HEADER_NAMESPACE is the value of the target's header_namespace attribute, and $HEADER_NAME is the header name if specified, and the filename of the header file otherwise. See header_namespace for more information.link_mode: Determines the link mode (equivalent of -mode). Can be one of the following values: internal, external. If no value is provided, the mode is set automatically depending on the other args.link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be one of the following values: static, static_pic or shared. This argument is relevant only if the cgo extension is enabled. Otherwise, Buck ignores this argument.linker_flags: Extra linker flags passed to go linkpackage_root: Sets Go package direactory (relative to BUCK file). By default (or if None passes) package_root is being detected automatically. Empty string of Go package is on the same level as BUCK file otherwise the subdirectory name. Example for srcs = [&quot;foo/bar.go&quot;], package_root = &quot;foo&quot;race: If true, enable data race detection.resources: Static files to be symlinked into the working directory of the test. You can access these in your by opening the files as relative paths, e.g. ioutil.ReadFile(&quot;testdata/input&quot;).srcs: The set of source files to be compiled by this rule. .go files will be compiled with the Go compiler, .s files will be compiled with the assembler, and everything else is assumed to be files that may be #included by the assembler.tags: Build tags to apply to this target and its dependencies. Details​ Examples: For more examples, check out our integration tests.  go_exported_library( name = &quot;shared&quot;, srcs = [&quot;main.go&quot;], build_mode = &quot;c_shared&quot;, compiler_flags = [&quot;-shared&quot;], deps = [&quot;:example&quot;], ) cgo_library( name = &quot;example&quot;, package_name = &quot;cgo&quot;, srcs = [ &quot;export-to-c.go&quot;, # file with //export annotations ], compiler_flags = [], headers = [], ) cxx_genrule( name = &quot;cgo_exported_headers&quot;, out = &quot;includes&quot;, cmd = ( &quot;mkdir -p $OUT &amp;&amp; &quot; + &quot;cat `dirname $(location :shared)`/includes/*.h &gt; $OUT/_cgo_export.h&quot; ), ) prebuilt_cxx_library( name = &quot;cxx_so_with_header&quot;, header_dirs = [&quot;:cgo_exported_headers&quot;], shared_lib = &quot;:shared&quot;, )   "},{"title":"go_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#go_library","content":"def go_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _asan: bool = _, _cgo_enabled: None | bool = _, _coverage_mode: None | str = _, _cxx_toolchain: str = _, _go_stdlib: str = _, _go_toolchain: str = _, _race: bool = _, _tags: list[str] = _, assembler_flags: list[str] = _, buck2_compatibility: str = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, embedcfg: None | str = _, exported_deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, package_name: None | str = _, package_root: None | str = _, srcs: list[str] = _ ) -&gt; None  A go_library() rule builds a native library from the supplied set of Go source files and dependencies. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneassembler_flags: The set of additional assembler flags to pass to go tool asm.compiler_flags: The set of additional compiler flags to pass to go tool compile.deps: The set of dependencies of this rule. Currently, this only supports go_library rules.package_name: Sets the full name of the package being compiled. This defaults to the path from the buck root. (e.g. given a ./.buckconfig, a rule in ./a/b/BUCK defaults to package &quot;a/b&quot;)package_root: Sets Go package direactory (relative to BUCK file). By default (or if None passes) package_root is being detected automatically. Empty string of Go package is on the same level as BUCK file otherwise the subdirectory name. Example for srcs = [&quot;foo/bar.go&quot;], package_root = &quot;foo&quot;srcs: The set of source files to be compiled by this rule. .go files will be compiled with the Go compiler, .s files will be compiled with the assembler, and everything else is assumed to be files that may be #included by the assembler. Details​ Examples: For more examples, check out our integration tests.  go_library( name='greeting', srcs=[ 'greeting.go', ], deps=[ ':join', ], )   "},{"title":"go_stdlib​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#go_stdlib","content":"def go_stdlib( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _asan: bool = _, _cgo_enabled: None | bool = _, _cxx_toolchain: str = _, _exec_os_type: str = _, _go_toolchain: str = _, _race: bool = _, _tags: list[str] = _, buck2_compatibility: str = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"go_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#go_test","content":"def go_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _asan: bool = _, _coverage_mode: None | str = _, _cxx_toolchain: str = _, _exec_os_type: str = _, _go_stdlib: str = _, _go_toolchain: str = _, _inject_test_env: str = _, _race: bool = _, _remote_test_execution_toolchain: str = _, _tags: list[str] = _, _testmaingen: str = _, asan: bool = _, assembler_flags: list[str] = _, buck2_compatibility: str = _, cgo_enabled: None | bool = _, compiler_flags: list[str] = _, contacts: list[str] = _, coverage_mode: None | str = _, default_host_platform: None | str = _, deps: list[str] = _, embedcfg: None | str = _, env: dict[str, str] = _, external_linker_flags: list[str] = _, labels: list[str] = _, library: None | str = _, licenses: list[str] = _, link_mode: None | str = _, link_style: None | str = _, linker_flags: list[str] = _, package_name: None | str = _, package_root: None | str = _, platform: None | str = _, race: bool = _, remote_execution: None | str | dict[str, None | bool | int | str | list[dict[str, str]] | dict[str, str]] = _, remote_execution_action_key_providers: None | str = _, resources: list[str] = _, run_test_separately: bool = _, runner: None | str = _, specs: None | str = _, srcs: list[str] = _, tags: list[str] = _, test_rule_timeout_ms: None | int = _ ) -&gt; None  A go_test() rule builds a native binary from the specified Go source and resource files—and a generated main file. It's similar to the go test command. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one asan: If true, enable ASAN. assembler_flags: The set of additional assembler flags to pass to go tool asm. cgo_enabled: Experimental: Analog of CGO_ENABLED environment-variable. None will be converted to True if cxx_toolchain available for current configuration, otherwise False. compiler_flags: The set of additional compiler flags to pass to go tool compile. deps: The set of dependencies of this rule. Currently, this only supports go_library rules. env: A map of environment variables and values to set when running the test. external_linker_flags: Extra external linker flags passed to go link via -extld argument. If argument is non-empty or cgo_library is used, the link mode will switch to external. labels: A list of labels to be applied to these tests. These labels are arbitrary text strings and have no meaning within buck itself. They can, however, have meaning for you as a test author (e.g., smoke or fast). A label can be used to filter or include a specific test rule when executing buck test library: Specify the library that this internal test is testing. This will copy the srcs, package_name and deps from the target specified so you don't have to duplicate them. link_mode: Determines the link mode (equivalent of -mode). Can be one of the following values: internal, external. If no value is provided, the mode is set automatically depending on the other args. link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be one of the following values: static, static_pic or shared. This argument is relevant only if the cgo extension is enabled. Otherwise, Buck ignores this argument. linker_flags: Extra linker flags passed to go link package_name: Sets the full name of the test package being compiled. This defaults to the path from the buck root with &quot;_test&quot; appended. (e.g. given a ./.buckconfig, a rule in ./a/b/BUCK defaults to package &quot;a/b_test&quot;) Note: if you want to test packages internally (i.e. same package name), use the libraryparameter instead of setting package_name to include the tested source files. package_root: Sets Go package direactory (relative to BUCK file). By default (or if None passes) package_root is being detected automatically. Empty string of Go package is on the same level as BUCK file otherwise the subdirectory name. Example for srcs = [&quot;foo/bar.go&quot;], package_root = &quot;foo&quot; race: If true, enable data race detection. srcs: The set of source files to be compiled by this rule. .go files will be compiled with the Go compiler, .s files will be compiled with the assembler, and everything else is assumed to be files that may be #included by the assembler. tags: Build tags to apply to this target and its dependencies. test_rule_timeout_ms: If set specifies the maximum amount of time (in milliseconds) in which all of the tests in this rule should complete. This overrides the default rule_timeout if any has been specified in .buckconfig . Details​ If your test requires static files you should specify these in the resources argument. If you do not specify these files, they won't be available when your test runs. Examples: For more examples, check out our integration tests.  go_library( name='greeting', srcs=[ 'greeting.go', ], deps=[ ':join', ], ) go_test( name='greeting-test', srcs=[ 'greeting_ext_test.go', ], deps=[ ':greeting' ], ) go_test( name='greeting-internal-test', package_name='greeting', srcs=[ 'greeting.go', 'greeting_test.go', ], deps=[ ':join', ], ) # Or go_test( name='greeting-better-internal-test', srcs=['greeting_test.go'], library=':greeting', )   "},{"title":"groovy_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#groovy_library","content":"def groovy_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, exported_deps: list[str] = _, exported_provided_deps: list[str] = _, extra_arguments: list[str] = _, extra_groovyc_arguments: list[str] = _, java_version: None | str = _, javac: None | str = _, labels: list[str] = _, licenses: list[str] = _, manifest_file: None | str = _, maven_coords: None | str = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, plugins: list[str] = _, proguard_config: None | str = _, provided_deps: list[str] = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resources: list[str] = _, resources_root: None | str = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, srcs: list[str] = _, target: None | str = _ ) -&gt; None  A groovy_library() rule is used to define a set of Groovy files that can be compiled together. It can also be used to cross compile a set of Groovy and Java files. The main output of a groovy_library() rule is a single JAR file containing all of the compiled class files and resources. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one deps: Rules (usually other groovy_library or java_library() rules) that are used to generate the classpath required to compile this groovy_library. This is the same as in java_library(). exported_deps: Other groovy_library and java_library() rules that depend on this rule will also include its exported_deps in their classpaths. This is the same as in java_library(). extra_arguments: Only used during cross compilation. This is the same as in java_library(). extra_groovyc_arguments: List of additional arguments to pass into the Groovy compiler. java_version: Only used during cross compilation. This is the same as in java_library(). provided_deps: This is the same as in java_library(). resources: This is the same as in java_library(). source: Only used during cross compilation. This is the same as in java_library(). srcs: The set of files to compile for this rule. Usually these will all end in .groovy, but if any of the files end in .java, cross compilation using the jdk found in JAVA_HOME will occur. target: Only used during cross compilation. This is the same as in java_library(). Details​ Examples:  # A rule that compiles a single .groovy file. groovy_library( name = 'example', srcs = ['MySourceFile.groovy'], )   # A rule that compiles all of the .groovy files under the directory in # which the rule is defined using glob() groovy_library( name = 'groovy-only', srcs = glob(['**/*.groovy']), )   # A rule that cross compiles all of the .groovy and .java files under # the directory in which the rule is defined, failing if compiling the # java files generates any compiler warnings groovy_library( name = 'cross-compilation', srcs = glob(['**/*.groovy', '**/*.java']), java_version = 8, extra_arguments = [ '-Werror', ], )   "},{"title":"groovy_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#groovy_test","content":"def groovy_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, cxx_library_whitelist: list[str] = _, default_cxx_platform: None | str = _, default_host_platform: None | str = _, deps: list[str] = _, deps_query: None | str = _, env: dict[str, str] = _, exported_deps: list[str] = _, exported_provided_deps: list[str] = _, extra_arguments: list[str] = _, extra_groovyc_arguments: list[str] = _, fork_mode: str = _, java_version: None | str = _, javac: None | str = _, labels: list[str] = _, licenses: list[str] = _, manifest_file: None | str = _, maven_coords: None | str = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, plugins: list[str] = _, proguard_config: None | str = _, provided_deps: list[str] = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resources: list[str] = _, resources_root: None | str = _, run_test_separately: bool = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, srcs: list[str] = _, std_err_log_level: None | int | str = _, std_out_log_level: None | int | str = _, target: None | str = _, test_case_timeout_ms: None | int = _, test_rule_timeout_ms: None | int = _, test_type: None | str = _, use_cxx_libraries: None | bool = _, use_dependency_order_classpath: None | bool = _, vm_args: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"gwt_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#gwt_binary","content":"def gwt_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _exec_os_type: str = _, _java_toolchain: str = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, draft_compile: bool = _, experimental_args: list[str] = _, labels: list[str] = _, licenses: list[str] = _, local_workers: int = _, module_deps: list[str] = _, modules: list[str] = _, optimize: int = _, strict: bool = _, style: str = _, vm_args: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"halide_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#halide_library","content":"def halide_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, compiler_deps: list[str] = _, compiler_flags: list[str] = _, compiler_invocation_flags: list[str] = _, configs: dict[str, dict[str, str]] = _, contacts: list[str] = _, cxx_runtime_type: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, defaults: dict[str, str] = _, deps: list[str] = _, deps_query: None | str = _, devirt_enabled: bool = _, executable_name: None | str = _, fat_lto: bool = _, focused_list_target: None | str = _, frameworks: list[str] = _, function_name: None | str = _, header_namespace: None | str = _, headers: list[str] | dict[str, str] = _, headers_as_raw_headers_mode: None | str = _, include_directories: list[str] = _, labels: list[str] = _, lang_compiler_flags: dict[str, list[str]] = _, lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = _, lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, lang_preprocessor_flags: dict[str, list[str]] = _, libraries: list[str] = _, licenses: list[str] = _, link_deps_query_whole: bool = _, link_group: None | str = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_style: None | str = _, linker_extra_outputs: list[str] = _, linker_flags: list[str] = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, platform_linker_flags: list[(str, list[str])] = _, platform_preprocessor_flags: list[(str, list[str])] = _, platform_srcs: list[(str, list[str | (str, list[str])])] = _, post_linker_flags: list[str] = _, post_platform_linker_flags: list[(str, list[str])] = _, precompiled_header: None | str = _, prefer_stripped_objects: bool = _, prefix_header: None | str = _, preprocessor_flags: list[str] = _, raw_headers: list[str] = _, srcs: list[str | (str, list[str])] = _, supported_platforms_regex: None | str = _, thin_lto: bool = _, version_universe: None | str = _, weak_framework_names: list[str] = _ ) -&gt; None  A halide_library() rule represents a set of Halide sources, along with the &quot;compiler&quot; code needed to compile them into object format (see the Halide site for information about Halide and about static compilation of Halide pipelines). The object code will be generated for the target architecture. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onecompiler_deps: The dependencies of the halide compiler itself. Targets that depend on the halide_library rule will not include or link the outputs of these targets.compiler_flags: Flags to use when compiling any of the above sources (which require compilation).deps: The dependencies of the generated halide pipeline code. This is useful if, for example, your pipeline calls an external function using Halide::Func::define_extern.linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library.platform_compiler_flags: Platform specific compiler flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when compiling the target's sources. See compiler_flags for more information.platform_linker_flags: Platform-specific linker flags. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use java.util.regex.Pattern syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule is used in a link operation.srcs: The set of halide sources to compile for this rule. The sources will be compiled and linked for the host architecture, and the resulting binary will be run to produce the object code for the Halide pipeline.supported_platforms_regex: If present, an un-anchored regex (in java.util.regex.Pattern syntax) that matches all platforms that this library supports. It will not be built for other platforms. Details​ Examples:  halide_library( # Your library name. name = 'brighter', # Your pipeline + compiler sources. srcs = ['halide/main.cpp'], # Any dependencies for your compiler. Note that targets that depend on # this rule WILL NOT include or link the output(s) of these targets. compiler_deps = [ # You'll need libHalide to use this rule; in our example, we assume it's # located in the 'third-party/halide' directory. '//third-party/halide:halide' ], # Any dependencies for your generated shader. Targets that depend on this # rule will include and/or link the output(s) of these targets. deps = [ # ... ], )   "},{"title":"haskell_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#haskell_binary","content":"def haskell_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _haskell_toolchain: str = _, auto_link_groups: bool = _, buck2_compatibility: str = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, deps_query: None | str = _, enable_profiling: bool = _, ghci_platform_preload_deps: list[(str, list[str])] = _, ghci_preload_deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, link_deps_query_whole: bool = _, link_group_deps: list[str] = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_group_public_deps_label: None | str = _, link_style: None | str = _, linker_flags: list[str] = _, main: None | str = _, platform: None | str = _, platform_deps: list[(str, list[str])] = _, platform_linker_flags: list[(str, list[str])] = _, srcs: list[str] | dict[str, str] = _, template_deps: list[str] = _ ) -&gt; None  A haskell_binary() rule represents a groups of Haskell sources and deps which build an executable. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onecompiler_flags: Flags to pass to the Haskell compiler when compiling this rule's sources.deps: Either haskell_library() or prebuilt_haskell_library() rules from which this rules sources import modules or native linkable rules exporting symbols this rules sources call into.link_group_deps: Additional targets to traverse when building link groups, but which should not be direct dependencies of the main executable.link_group_public_deps_label: Surface nodes with this label as &quot;public&quot; nodes in the main executable when linking with with link groups.link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared.main: The main module serving as the entry point into the binary. If not specified, the compiler default is used.platform_deps: Platform specific dependencies. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of dependencies (same format as deps) that are exported if the platform matches the regex. See deps for more information.srcs: A list of Haskell sources to be built by this rule. The dictionary option is deprecated. Details​ Examples:  haskell_binary( name = 'foo', srcs = [ 'Foo.hs', ], )   "},{"title":"haskell_ghci​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#haskell_ghci","content":"def haskell_ghci( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _haskell_toolchain: str = _, buck2_compatibility: str = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, deps_query: None | str = _, enable_profiling: bool = _, extra_script_templates: list[str] = _, ghci_bin_dep: None | str = _, ghci_init: None | str = _, labels: list[str] = _, licenses: list[str] = _, linker_flags: list[str] = _, platform: None | str = _, platform_deps: list[(str, list[str])] = _, platform_preload_deps: list[(str, list[str])] = _, preload_deps: list[str] = _, srcs: list[str] | dict[str, str] = _, template_deps: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"haskell_haddock​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#haskell_haddock","content":"def haskell_haddock( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _haskell_toolchain: str = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, deps_query: None | str = _, haddock_flags: list[str] = _, labels: list[str] = _, licenses: list[str] = _, platform: None | str = _, platform_deps: list[(str, list[str])] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"haskell_ide​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#haskell_ide","content":"def haskell_ide( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _haskell_toolchain: str = _, buck2_compatibility: str = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, deps_query: None | str = _, extra_script_templates: list[str] = _, include_projects: list[str] = _, labels: list[str] = _, licenses: list[str] = _, link_style: str, linker_flags: list[str] = _, platform: None | str = _, platform_deps: list[(str, list[str])] = _, srcs: list[str] | dict[str, str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"haskell_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#haskell_library","content":"def haskell_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _haskell_toolchain: str = _, buck2_compatibility: str = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, enable_profiling: bool = _, ghci_platform_preload_deps: list[(str, list[str])] = _, ghci_preload_deps: list[str] = _, haddock_flags: list[str] = _, labels: list[str] = _, licenses: list[str] = _, link_whole: bool = _, linker_flags: list[str] = _, platform: None | str = _, platform_deps: list[(str, list[str])] = _, platform_linker_flags: list[(str, list[str])] = _, preferred_linkage: str = _, srcs: list[str] | dict[str, str] = _, template_deps: list[str] = _ ) -&gt; None  A haskell_library() rule is used to identity a group of Haskell sources. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onecompiler_flags: Flags to pass to the Haskell compiler when compiling this rule's sources.deps: Either haskell_library() or prebuilt_haskell_library() rules from which this rules sources import modules or native linkable rules exporting symbols this rules sources call into.platform_deps: Platform specific dependencies. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of dependencies (same format as deps) that are exported if the platform matches the regex. See deps for more information.srcs: A list of Haskell sources to be built by this rule. The dictionary option is deprecated. Details​ Examples:  haskell_library( name = 'fileutil', srcs = [ 'FileUtil.hs', ], )   "},{"title":"haskell_prebuilt_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#haskell_prebuilt_library","content":"def haskell_prebuilt_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, cxx_header_dirs: list[str] = _, db: str, default_host_platform: None | str = _, deps: list[str] = _, enable_profiling: bool = _, exported_compiler_flags: list[str] = _, exported_linker_flags: list[str] = _, exported_post_linker_flags: list[str] = _, id: str = _, import_dirs: list[str] = _, labels: list[str] = _, licenses: list[str] = _, pic_profiled_static_libs: list[str] = _, pic_static_libs: list[str] = _, profiled_static_libs: list[str] = _, shared_libs: dict[str, str] = _, static_libs: list[str] = _, version: str = _ ) -&gt; None  A prebuilt_haskell_library() rule is used to identify Haskell prebuilt libraries and their associated interface files. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onedeps: Other prebuilt_haskell_library() rules from which this library imports modules.exported_compiler_flags: Compiler flags used by dependent rules when compiling with this library.exported_linker_flags: Linker flags used by dependent rules when linking with this library.shared_libs: A map of shared library names to shared library paths to use when building a dynamically linked top-level target.static_libs: The libraries to use when building a statically linked top-level target. Details​ Examples:  prebuilt_haskell_library( name = 'file', static_interfaces = [ 'interfaces', ], shared_interfaces = [ 'interfaces_dyn', ], static_libs = [ 'libFileUtil.a', ], shared_libs = { 'libFileUtil.so': 'libFileUtil.so', }, )   "},{"title":"http_archive​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#http_archive","content":"def http_archive( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, excludes: list[str] = _, exec_deps: str = _, labels: list[str] = _, licenses: list[str] = _, out: None | str = _, sha1: None | str = _, sha256: None | str = _, strip_prefix: None | str = _, sub_targets: list[str] = _, type: None | str = _, urls: list[str] = _, vpnless_urls: list[str] = _ ) -&gt; None  An http_archive() rule is used to download and extract archives from the Internet to be used as dependencies for other rules. These rules are downloaded by running fetch, or can be downloaded as part of build by setting .buckconfig Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one excludes: An optional list of regex patterns. All file paths in the extracted archive which match any of the given patterns will be omitted. exec_deps: When using http_archive as an anon target, the rule invoking the anon target needs to mirror this attribute into its own attributes, and forward the provider into the anon target invocation. When using http_archive normally not as an anon target, the default value is always fine. out: An optional name to call the directory that the downloaded artifact is extracted into. Buck will generate a default name if one is not provided that uses the name of the rule. sha256: The SHA-256 hash of the downloaded artifact. Buck verifies this is correct and fails the fetch command if it doesn't match in order to guarantee repeatable builds. strip_prefix: If set, files under this path will be extracted to the root of the output directory. Siblings or cousins to this prefix will not be extracted at all. For example, if a tarball has the layout: foo/bar/bar-0.1.2/data.dat foo/baz/baz-0.2.3 foo_prime/bar-0.1.2 Only data.dat will be extracted, and it will be extracted into the output directory specified in out. sub_targets: A list of filepaths within the archive to be made accessible as sub-targets. For example if we have an http_archive with name = &quot;archive&quot; and sub_targets = [&quot;src/lib.rs&quot;], then other targets would be able to refer to that file as &quot;:archive[src/lib.rs]&quot;. type: Normally, archive type is determined by the file's extension. If type is set, then autodetection is overridden, and the specified type is used instead. Supported values are: zip, tar, tar.gz,tar.bz2, tar.xz, and tar.zst. urls: A list of urls to attempt to download from. They are tried in order, and subsequent ones are only tried if the download fails. If validation fails, a new URL is not used. Supported protocols are &quot;http&quot;, &quot;https&quot;, and &quot;mvn&quot;. vpnless_urls: Additional URLs from which this resource can be downloaded when off VPN. Meta-internal only. Details​ Examples: Using http_archive(), third party packages can be downloaded from an https URL and used in other library types.  http_archive( name = 'thrift-archive', urls = [ 'https://internal-mirror.example.com/bin/thrift-compiler-0.1.tar.gz.badextension', ], sha256 = '7baa80df284117e5b945b19b98d367a85ea7b7801bd358ff657946c3bd1b6596', type='tar.gz', strip_prefix='thrift-compiler-0.1' ) genrule( name = 'thrift-compiler-bin', out = 'thrift', cmd = 'cp $(location :thrift-archive)/bin/thrift $OUT', executable = True, ) genrule( name=&quot;my-thrift-lib-cpp2&quot;, cmd=&quot;$(exe :thrift-compiler-bin) --gen cpp2 -o $OUT $(location //:thrift-file)&quot;, out=&quot;gen-cpp2&quot;, )   "},{"title":"http_file​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#http_file","content":"def http_file( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, executable: None | bool = _, labels: list[str] = _, licenses: list[str] = _, out: None | str = _, sha1: None | str = _, sha256: None | str = _, urls: list[str] = _, vpnless_urls: list[str] = _ ) -&gt; None  An http_file() rule is used to download files from the Internet to be used as dependencies for other rules. This rule only downloads single files, and can optionally make them executable (see http_file()executable) These rules are downloaded by running fetch, or can be downloaded as part of build by setting .buckconfig Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneexecutable: Whether or not the file should be made executable after downloading. If true, this can also be used via run and the $(exe ) string parameter macrosout: An optional name to call the downloaded artifact. Buck will generate a default name if one is not provided that uses the name of the rule.sha256: The SHA-256 hash of the downloaded artifact. Buck verifies this is correct and fails the fetch command if it doesn't match in order to guarantee repeatable builds.urls: A list of urls to attempt to download from. They are tried in order, and subsequent ones are only tried if the download fails. If validation fails, a new URL is not used. Supported protocols are &quot;http&quot;, &quot;https&quot;, and &quot;mvn&quot;.vpnless_urls: Additional URLs from which this resource can be downloaded when off VPN. Meta-internal only. Details​ Examples: Using http_file(), third party packages can be downloaded from an https URL and used in java libraries.  http_file( name = 'guava-23-bin', urls = [ 'http://search.maven.org/remotecontent?filepath=com/google/guava/guava/23.0/guava-23.0.jar', ], sha256 = '7baa80df284117e5b945b19b98d367a85ea7b7801bd358ff657946c3bd1b6596', ) http_file( name = 'guava-23-sources', urls = [ 'http://search.maven.org/remotecontent?filepath=com/google/guava/guava/23.0/guava-23.0-sources.jar', ], sha256 = '37fe8ba804fb3898c3c8f0cbac319cc9daa58400e5f0226a380ac94fb2c3ca14', ) prebuilt_java_library( name = 'guava-23', binary_jar = ':guava-23-bin', source_jar = ':guava-23-source', )  Tooling can also be fetched with http_file() and used by a genrule().  genrule( name=&quot;my-thrift-lib-cpp2&quot;, cmd=&quot;$(exe :thrift-compiler-bin) --gen cpp2 -o $OUT $(location //:thrift-file)&quot;, out=&quot;gen-cpp2&quot;, ) http_file( name = 'thrift-compiler-bin', url = 'https://internal-mirror.example.com/bin/thrift-compiler', sha256 = 'c24932ccabb66fffb2d7122298f7f1f91e0b1f14e05168e3036333f84bdf58dc', executable = True, )  Here's an example of a http_file() using a mvn URI which uses a Maven classifier.  http_file( name = 'guava-23-bin', urls = [ 'mvn:com.google.guava:guava:jar:23.0', ], sha256 = '7baa80df284117e5b945b19b98d367a85ea7b7801bd358ff657946c3bd1b6596', )   "},{"title":"jar_genrule​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#jar_genrule","content":"def jar_genrule( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _genrule_toolchain: str = _, _java_toolchain: str = _, always_print_stderr: bool = _, bash: None | str = _, buck2_compatibility: str = _, cacheable: None | bool = _, cmd: None | str = _, cmd_exe: None | str = _, contacts: list[str] = _, default_host_platform: None | str = _, enable_sandbox: None | bool = _, environment_expansion_separator: None | str = _, labels: list[str] = _, licenses: list[str] = _, metadata_env_var: None | str = _, metadata_path: None | str = _, need_android_tools: bool = _, no_outputs_cleanup: bool = _, remote: None | bool = _, remote_execution_dependencies: list[dict[str, str]] = _, srcs: list[str] | dict[str, str] = _, type: None | str = _, weight: None | int = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"java_annotation_processor​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#java_annotation_processor","content":"def java_annotation_processor( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, does_not_affect_abi: bool = _, isolate_class_loader: bool = _, labels: list[str] = _, licenses: list[str] = _, processor_class: str = _, supports_abi_generation_from_source: bool = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"java_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#java_binary","content":"def java_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _exec_os_type: str = _, _is_building_android_binary: bool = _, _java_toolchain: str = _, blacklist: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_cxx_platform: None | str = _, default_host_platform: None | str = _, deps: list[str] = _, do_not_create_inner_jar: bool = _, generate_wrapper: bool = _, java_args_for_run_info: list[str] = _, labels: list[str] = _, licenses: list[str] = _, main_class: None | str = _, manifest_file: None | str = _, meta_inf_directory: None | str = _ ) -&gt; None  A java_binary() rule is used to create a JAR file of the compiled .class files and resources of the java_library() rules on which it depends. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one blacklist: A list of patterns that identify files to exclude from the final generated JAR file. Example: java_binary( name = 'example', blacklist = [ # Excludes com.example.A and com.example.Alligator, # as well as their inner classes and any non-class files that happen to match # the pattern 'com.example.A', # Excludes all files from org/slf4j/**/*. 'org.slf4j', ], deps = [ ':example1', ':third-party-stuff', ], ) deps: Rules (normally of type java_library) that should be compiled and whose .class files and resources should be included in the generated JAR file. main_class: If provided, this will be the value specified as the Main-Class attribute of the META-INF/MANIFEST.MF file in the generated JAR file. Also, when this rule is used as an executable in a genrule(), main_class will indicate the class whose main() method will be invoked to process the command-line arguments. This is consistent with the expected usage of java -jar *&lt;name.jar&gt;* *&lt;args&gt;*. manifest_file: If provided, this manifest will be used when generating the JAR file. If combined with main_class, the specified manifest file will be used but the main_class will override the main class in the manifest.  "},{"title":"java_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#java_library","content":"def java_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _dex_min_sdk_version: None | int = _, _dex_toolchain: str = _, _exec_os_type: str = _, _is_building_android_binary: bool = _, _java_toolchain: str = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, abi_generation_mode: None | str = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, exported_deps: list[str] = _, exported_provided_deps: list[str] = _, extra_arguments: list[str] = _, jar_postprocessor: None | str = _, java_version: None | str = _, javac: None | str = _, labels: list[str] = _, licenses: list[str] = _, manifest_file: None | str = _, maven_coords: None | str = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, plugins: list[str] = _, proguard_config: None | str = _, provided_deps: list[str] = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resources: list[str] = _, resources_root: None | str = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, srcs: list[str] = _, target: None | str = _, validation_deps: list[str] = _ ) -&gt; None  A java_library() rule defines a set of Java files that can be compiled together. The main output of a java_library() rule is a single JAR file containing all of the compiled class files, as well as the static files specified in the resources argument. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one deps: Rules (usually other java_library rules) that are used to generate the classpath required to compile this java_library. exported_deps: Other rules that depend on this rule will also include its exported_deps in their classpaths. This is useful when the public API of a rule has return types or checked exceptions that are defined in another rule, which would otherwise require callers to add an extra dependency. It's also useful for exposing e.g. a collection of prebuilt_jar rules as a single target for callers to depend on. Targets in exported_deps are implicitly included in the deps of this rule, so they don't need to be repeated there. exported_provided_deps: This is a combination of provided_deps and exported_deps. Rules listed in this parameter will be added to classpath of rules that depend on this rule, but they will not be included in a binary if binary depends on a such target. extra_arguments: List of additional arguments to pass into the Java compiler. These arguments follow the ones specified in .buckconfig. java_version: Equivalent to setting both source and target to the given value. Setting this and source or target (or both!) is an error. on_unused_dependencies: Action performed when Buck detects that some dependencies are not used during Java compilation. Note that this feature is experimental and does not handle runtime dependencies. The valid values are: ignore (default): ignore unused dependencies,warn: emit a warning to the console,fail: fail the compilation. This option overrides the default value from . provided_deps: These represent dependencies that are known to be provided at run time, but are required in order for the code to compile. Examples of provided_deps include the JEE servlet APIs. When this rule is included in a , the provided_deps will not be packaged into the output. remove_classes: Specifies a list of Patterns that are used to exclude classes from the JAR. The pattern matching is based on the name of the class. This can be used to exclude a member class or delete a local view of a class that will be replaced during a later stage of the build. required_for_source_only_abi: Indicates that this rule must be present on the classpath during source-only ABI generation of any rule that depends on it. Typically this is done when a rule contains annotations, enums, constants, or interfaces. Having rules present on the classpath during source-only ABI generation prevents Buck from completely flattening the build graph, thus reducing the performance win from source-only ABI generation. These rules should be kept small (ideally just containing annotations, constants, enums, and interfaces) and with minimal dependencies of their own. resources: Static files to include with the compiled .class files. These files can be loaded via Class.getResource(). Note: If resources_root isn't set, Buck uses the .buckconfigproperty in .buckconfig to determine where resources should be placed within the generated JAR file. source: Specifies the version of Java (as a string) to interpret source files as. Overrides the value in &quot;source_level&quot; in the &quot;java&quot; section of .buckconfig. source_only_abi_deps: These are dependencies that must be present during source-only ABI generation. Typically such dependencies are added when some property of the code in this rule prevents source-only ABI generation from being correct without these dependencies being present. Having source_only_abi_deps prevents Buck from completely flattening the build graph, thus reducing the performance win from source-only ABI generation. They should be avoided when possible. Often only a small code change is needed to avoid them. For more information on such code changes, read aboutsource-only ABI generation. srcs: The set of .java files to compile for this rule. If any of the files in this list end in .src.zip, then the entries in the ZIP file that end in .java will be included as ordinary inputs to compilation. This is common when using a genrule() to auto-generate some Java source code that needs to be compiled with some hand-written Java code. target: Specifies the version of Java (as a string) for which to generate code. Overrides the value in &quot;target_level&quot; in the &quot;java&quot; section of .buckconfig. Details​ Examples:  # A rule that compiles a single .java file. java_library( name = 'JsonUtil', srcs = ['JsonUtil.java'], deps = [ '//third_party/guava:guava', '//third_party/jackson:jackson', ], ) # A rule that compiles all of the .java files under the directory in # which the rule is defined using glob(). It also excludes an # individual file that may have additional dependencies, so it is # compiled by a separate rule. java_library( name = 'messenger', srcs = glob(['**/*.java'], excludes = ['MessengerModule.java']), deps = [ '//src/com/facebook/base:base', '//third_party/guava:guava', ], ) java_library( name = 'MessengerModule', srcs = ['MessengerModule.java'], deps = [ '//src/com/facebook/base:base', '//src/com/google/inject:inject', '//third_party/guava:guava', '//third_party/jsr-330:jsr-330', ], ) # A rule that builds a library with both relative and # fully-qualified deps. java_library( name = 'testutil', srcs = glob(['tests/**/*.java'], excludes = 'tests/**/*Test.java'), deps = [ ':lib-fb4a', '//java/com/facebook/base:base', ], )   "},{"title":"java_plugin​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#java_plugin","content":"def java_plugin( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, does_not_affect_abi: bool = _, isolate_class_loader: bool = _, labels: list[str] = _, licenses: list[str] = _, plugin_name: str = _, supports_abi_generation_from_source: bool = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"java_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#java_test","content":"def java_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _exec_os_type: str = _, _inject_test_env: str = _, _is_building_android_binary: bool = _, _java_test_toolchain: str = _, _java_toolchain: str = _, _remote_test_execution_toolchain: str = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, abi_generation_mode: None | str = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, cxx_library_whitelist: list[str] = _, default_cxx_platform: None | str = _, default_host_platform: None | str = _, deps: list[str] = _, deps_query: None | str = _, env: dict[str, str] = _, exported_deps: list[str] = _, exported_provided_deps: list[str] = _, extra_arguments: list[str] = _, fork_mode: str = _, jar_postprocessor: None | str = _, java: None | str = _, java_agents: list[str] = _, java_version: None | str = _, javac: None | str = _, labels: list[str] = _, licenses: list[str] = _, manifest_file: None | str = _, maven_coords: None | str = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, plugins: list[str] = _, proguard_config: None | str = _, provided_deps: list[str] = _, remote_execution: None | str | dict[str, None | bool | int | str | list[dict[str, str]] | dict[str, str]] = _, remote_execution_action_key_providers: None | str = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resources: list[str] = _, resources_root: None | str = _, run_test_separately: bool = _, runner: None | str = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, specs: None | str = _, srcs: list[str] = _, std_err_log_level: None | int | str = _, std_out_log_level: None | int | str = _, target: None | str = _, test_case_timeout_ms: None | int = _, test_class_names_file: None | str = _, test_rule_timeout_ms: None | int = _, test_type: None | str = _, unbundled_resources_root: None | str = _, use_cxx_libraries: None | bool = _, use_dependency_order_classpath: None | bool = _, vm_args: list[str] = _ ) -&gt; None  A java_test() rule is used to define a set of .java files that contain tests to run via JUnit. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one cxx_library_whitelist: EXPERIMENTAL. List of cxx_libraries to build, if use_cxx_libraries is true. This can be useful if some dependencies are Android-only and won't build on the default platform. deps: Same as java_library(). // org.junit.rules.Timeout was not introduced until 4.7. Must include JUnit (version 4.7 or later) as a dependency for JUnit tests. Must include TestNG (version 6.2 or later) and hamcrest as a dependencies for TestNG tests. env: A map of environment names and values to set when running the test. fork_mode: Controls whether tests will all be run in the same process or a process will be started for each set of tests in a class. (This is mainly useful when porting Java tests to Buck from Apache Ant which allows JUnit tasks to set a fork=&quot;yes&quot; property. It should not be used for new tests since it encourages tests to not cleanup after themselves and increases the tests' computational resources and running time.) noneAll tests will run in the same process.per_testA process will be started for each test class in which all tests of that test class will run. labels: A list of labels to be applied to these tests. These labels are arbitrary text strings and have no meaning within buck itself. They can, however, have meaning for you as a test author (e.g., smoke or fast). A label can be used to filter or include a specific test rule when executing buck test resources: Same as java_library(). source: Java language level for compiling. Corresponds to the -source argument for javac. srcs: Like java_library(), all of the .java files specified by the srcs argument will be compiled when this rule is built. In addition, all of the corresponding .class files that are built by this rule will be passed as arguments to JUnit when this rule is run as a test. .class files that are passed to JUnit that do not have any methods annotated with @Test are considered failed tests, so make sure that only test case classes are specified as srcs. This is frequently done by specifying srcs as glob(['**/*Test.java']). std_err_log_level: Same as std_out_log_level, but for std err. std_out_log_level: Log level for messages from the source under test that buck will output to std out. Value must be a valid java.util.logging.Level value. target: Bytecode target level for compiling. Corresponds to the -target argument for javac. test_rule_timeout_ms: If set specifies the maximum amount of time (in milliseconds) in which all of the tests in this rule should complete. This overrides the default rule_timeout if any has been specified in .buckconfig . test_type: Specifies which test framework to use. The currently supported options are 'junit' and 'testng'. use_cxx_libraries: Whether or not to build and link against cxx_library() dependencies when testing. vm_args: Runtime arguments to the JVM running the tests.  "},{"title":"java_test_runner​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#java_test_runner","content":"def java_test_runner( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, abi_generation_mode: None | str = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, exported_deps: list[str] = _, exported_provided_deps: list[str] = _, extra_arguments: list[str] = _, java_version: None | str = _, javac: None | str = _, labels: list[str] = _, licenses: list[str] = _, main_class: str = _, manifest_file: None | str = _, maven_coords: None | str = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, plugins: list[str] = _, proguard_config: None | str = _, provided_deps: list[str] = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resources: list[str] = _, resources_root: None | str = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, srcs: list[str] = _, target: None | str = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"js_bundle​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#js_bundle","content":"def js_bundle( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _is_release: bool = _, _platform: str = _, android_package: None | str = _, buck2_compatibility: str = _, bundle_name: None | str = _, bundle_name_for_flavor: list[(str, str)] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, entry: str | list[str], extra_json: None | str = _, fallback_transform_profile: None | str = _, labels: list[str] = _, licenses: list[str] = _, worker: str ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"js_bundle_genrule​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#js_bundle_genrule","content":"def js_bundle_genrule( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _exec_os_type: str = _, _genrule_toolchain: str = _, _is_release: bool = _, _platform: str = _, always_print_stderr: bool = _, bash: None | str = _, buck2_compatibility: str = _, bundle_name: None | str = _, bundle_name_for_flavor: list[(str, str)] = _, cacheable: None | bool = _, cmd: None | str = _, cmd_exe: None | str = _, contacts: list[str] = _, default_host_platform: None | str = _, enable_sandbox: None | bool = _, environment_expansion_separator: None | str = _, js_bundle: str, labels: list[str] = _, licenses: list[str] = _, metadata_env_var: None | str = _, metadata_path: None | str = _, need_android_tools: bool = _, no_outputs_cleanup: bool = _, remote: None | bool = _, remote_execution_dependencies: list[dict[str, str]] = _, rewrite_deps_file: bool = _, rewrite_misc: bool = _, rewrite_sourcemap: bool = _, skip_resources: bool = _, srcs: list[str] | dict[str, str] = _, type: str = _, weight: None | int = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"js_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#js_library","content":"def js_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _asset_dest_path_resolver: None | str = _, _build_only_native_code: bool = _, _is_release: bool = _, _platform: str = _, asset_extensions: None | list[str] = _, asset_platforms: None | list[str] = _, base_path: None | str = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, deps_query: None | str = _, extra_json: None | str = _, labels: list[str] = _, licenses: list[str] = _, srcs: list[str | (str, str)] = _, worker: str ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"julia_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#julia_binary","content":"def julia_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _julia_toolchain: str = _, buck2_compatibility: str = _, deps: list[str] = _, julia_args: list[str] = _, julia_flags: list[str] = _, main: str, srcs: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"julia_jll_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#julia_jll_library","content":"def julia_jll_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _julia_toolchain: str = _, buck2_compatibility: str = _, jll_name: str, lib_mapping: list[str] | dict[str, str], uuid: str ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"julia_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#julia_library","content":"def julia_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _julia_toolchain: str = _, buck2_compatibility: str = _, deps: list[str] = _, project_toml: str, resources: list[str] = _, srcs: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"julia_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#julia_test","content":"def julia_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _inject_test_env: str = _, _julia_toolchain: str = _, buck2_compatibility: str = _, contacts: list[str] = _, deps: list[str] = _, julia_args: list[str] = _, julia_flags: list[str] = _, main: str, srcs: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"keystore​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#keystore","content":"def keystore( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, properties: str, store: str ) -&gt; None  A keystore() contains the data for a key pair created by the keytool executable that comes with the JDK. This is a required input for an android_binary() rule. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one properties: The path to the .properties file that contains the following values: # The value that you passed as the argument to -alias # when you ran keytool. key.alias=my_alias # The value that you entered in response to # the &quot;Enter keystore password:&quot; prompt. key.store.password=store_password # The value that you entered in response to # the &quot;Enter key password for &lt;my_alias&gt;&quot; prompt. key.alias.password=alias_password store: The path to the file that contains the key. This is the path that was passed as the -keystore argument when you ran keytool.  "},{"title":"kotlin_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#kotlin_library","content":"def kotlin_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _dex_min_sdk_version: None | int = _, _dex_toolchain: str = _, _exec_os_type: str = _, _is_building_android_binary: bool = _, _java_toolchain: str = _, _kotlin_toolchain: str = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, abi_generation_mode: None | str = _, annotation_processing_tool: None | str = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, exported_deps: list[str] = _, exported_provided_deps: list[str] = _, extra_arguments: list[str] = _, extra_kotlinc_arguments: list[str] = _, friend_paths: list[str] = _, incremental: bool = _, jar_postprocessor: None | str = _, java_version: None | str = _, javac: None | str = _, k2: bool = _, kotlin_compiler_plugins: dict[str, dict[str, str]] = _, labels: list[str] = _, licenses: list[str] = _, manifest_file: None | str = _, maven_coords: None | str = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, plugins: list[str] = _, proguard_config: None | str = _, provided_deps: list[str] = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resources: list[str] = _, resources_root: None | str = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, srcs: list[str] = _, target: None | str = _, use_jvm_abi_gen: None | bool = _, validation_deps: list[str] = _ ) -&gt; None  A kotlin_library() rule is used to define a set of Kotlin files that can be compiled together. The main output of a kotlin_library() rule is a single JAR file containing all of the compiled class files, as well as the static files specified in the resources argument. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one annotation_processing_tool: Specifies the tool to use for annotation processing. Possible values: &quot;kapt&quot; or &quot;javac&quot;. &quot;kapt&quot; allows running Java annotation processors against Kotlin sources while backporting it for Java sources too. &quot;javac&quot; works only against Java sources, Kotlin sources won't have access to generated classes at compile time. deps: Rules (usually other kotlin_library rules) that are used to generate the classpath required to compile this kotlin_library. exported_deps: Other rules that depend on this rule will also include its exported_deps in their classpaths. This is useful when the public API of a rule has return types or checked exceptions that are defined in another rule, which would otherwise require callers to add an extra dependency. It's also useful for exposing e.g. a collection of prebuilt_jar rules as a single target for callers to depend on. Targets in exported_deps are implicitly included in the deps of this rule, so they don't need to be repeated there. exported_provided_deps: This is a combination of provided_deps and exported_deps. Rules listed in this parameter will be added to classpath of rules that depend on this rule, but they will not be included in a binary if binary depends on a such target. extra_kotlinc_arguments: List of additional arguments to pass into the Kotlin compiler. friend_paths: List of source paths to pass into the Kotlin compiler as friend-paths, that is, modules you can have access to internal methods. incremental: Enables Kotlin incremental compilation. k2: Enables the Kotlin K2 compiler. kotlin_compiler_plugins: Use this to specify Kotlin compiler plugins to use when compiling this library. This takes a map, with each entry specify one plugin. Entry's key is plugin source path, and value is a map of plugin option key value pair. Unlike extra_kotlinc_arguments, these can be source paths, not just strings. A special option value is__codegen_dir__, in which case Buck will provide a default codegen folder's path as option value instead. E.g. kotlin_compiler_plugins = { &quot;somePluginSourcePath&quot;: { &quot;plugin:somePluginId:somePluginOptionKey&quot;: &quot;somePluginOptionValue&quot;, &quot;plugin:somePluginId:someDirectoryRelatedOptionKey&quot;: &quot;__codegen_dir__&quot;, }, }, Each plugin source path will be prefixed with -Xplugin= and passed as extra arguments to the compiler. Plugin options will be appended after its plugin with -P. A specific example is, if you want to use kotlinx.serializationwith kotlin_library(), you need to specify kotlinx-serialization-compiler-plugin.jar under kotlin_compiler_plugins and kotlinx-serialization-runtime.jar (which you may have to fetch from Maven) in your deps: kotlin_library( name = &quot;example&quot;, srcs = glob([&quot;*.kt&quot;]), deps = [ &quot;:kotlinx-serialization-runtime&quot;, ], kotlin_compiler_plugins = { # Likely copied from your $KOTLIN_HOME directory. &quot;kotlinx-serialization-compiler-plugin.jar&quot;: {}, }, ) prebuilt_jar( name = &quot;kotlinx-serialization-runtime&quot;, binary_jar = &quot;:kotlinx-serialization-runtime-0.10.0&quot;, ) # Note you probably want to set # maven_repo=http://jcenter.bintray.com/ in your .buckconfig until # https://github.com/Kotlin/kotlinx.serialization/issues/64 # is closed. remote_file( name = &quot;kotlinx-serialization-runtime-0.10.0&quot;, out = &quot;kotlinx-serialization-runtime-0.10.0.jar&quot;, url = &quot;mvn:org.jetbrains.kotlinx:kotlinx-serialization-runtime:jar:0.10.0&quot;, sha1 = &quot;23d777a5282c1957c7ce35946374fff0adab114c&quot; ) labels: Set of arbitrary strings which allow you to annotate a build rule with tags that can be searched for over an entire dependency tree using buck query() . provided_deps: These represent dependencies that are known to be provided at run time, but are required in order for the code to compile. Examples of provided_deps include the JEE servlet APIs. When this rule is included in a , the provided_deps will not be packaged into the output. remove_classes: Specifies a list of Patterns that are used to exclude classes from the JAR. The pattern matching is based on the name of the class. This can be used to exclude a member class or delete a local view of a class that will be replaced during a later stage of the build. resources: Static files to include with the compiled .class files. These files can be loaded via Class.getResource(). Note: If resources_root isn't set, Buck uses the .buckconfigproperty in .buckconfig to determine where resources should be placed within the generated JAR file. srcs: The set of .kt, .java or .kts files to compile for this rule. If any of the files in this list end in .src.zip, then the entries in the ZIP file that end in .java or .kt will be included as ordinary inputs to compilation. Details​ Examples:  # A rule that compiles a single .kt file. kotlin_library( name = 'JsonUtil', srcs = ['JsonUtil.kt'], deps = [ '//third_party/guava:guava', '//third_party/jackson:jackson', ], ) # A rule that compiles all of the .kt files under the directory in # which the rule is defined using glob(). It also excludes an # individual file that may have additional dependencies, so it is # compiled by a separate rule. kotlin_library( name = 'messenger', srcs = glob(['**/*.kt'], excludes = ['MessengerModule.kt']), deps = [ '//src/com/facebook/base:base', '//third_party/guava:guava', ], ) kotlin_library( name = 'MessengerModule', srcs = ['MessengerModule.kt'], deps = [ '//src/com/facebook/base:base', '//src/com/google/inject:inject', '//third_party/guava:guava', '//third_party/jsr-330:jsr-330', ], ) # A rule that builds a library with both relative and # fully-qualified deps. kotlin_library( name = 'testutil', srcs = glob(['tests/**/*.kt'], excludes = 'tests/**/*Test.kt'), deps = [ ':lib-fb4a', '//java/com/facebook/base:base', ], )   "},{"title":"kotlin_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#kotlin_test","content":"def kotlin_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _exec_os_type: str = _, _inject_test_env: str = _, _is_building_android_binary: bool = _, _java_test_toolchain: str = _, _java_toolchain: str = _, _kotlin_toolchain: str = _, _remote_test_execution_toolchain: str = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, abi_generation_mode: None | str = _, annotation_processing_tool: None | str = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, cxx_library_whitelist: list[str] = _, default_cxx_platform: None | str = _, default_host_platform: None | str = _, deps: list[str] = _, deps_query: None | str = _, env: dict[str, str] = _, exported_deps: list[str] = _, exported_provided_deps: list[str] = _, extra_arguments: list[str] = _, extra_kotlinc_arguments: list[str] = _, fork_mode: str = _, friend_paths: list[str] = _, incremental: bool = _, java: None | str = _, java_agents: list[str] = _, java_version: None | str = _, javac: None | str = _, k2: bool = _, kotlin_compiler_plugins: dict[str, dict[str, str]] = _, labels: list[str] = _, licenses: list[str] = _, manifest_file: None | str = _, maven_coords: None | str = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, plugins: list[str] = _, proguard_config: None | str = _, provided_deps: list[str] = _, remote_execution: None | str | dict[str, None | bool | int | str | list[dict[str, str]] | dict[str, str]] = _, remote_execution_action_key_providers: None | str = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resources: list[str] = _, resources_root: None | str = _, run_test_separately: bool = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, srcs: list[str] = _, std_err_log_level: None | int | str = _, std_out_log_level: None | int | str = _, target: None | str = _, test_case_timeout_ms: None | int = _, test_class_names_file: None | str = _, test_rule_timeout_ms: None | int = _, test_type: None | str = _, unbundled_resources_root: None | str = _, use_cxx_libraries: None | bool = _, use_dependency_order_classpath: None | bool = _, use_jvm_abi_gen: None | bool = _, vm_args: list[str] = _ ) -&gt; None  A kotlin_test() rule is used to define a set of .kt files that contain tests to run via JUnit. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one deps: Same as kotlin_library(). // org.junit.rules.Timeout was not introduced until 4.7. Must include JUnit (version 4.7 or later) as a dependency for JUnit tests. Must include TestNG (version 6.2 or later) and hamcrest as a dependencies for TestNG tests. env: A map of environment names and values to set when running the test. fork_mode: Controls whether tests will all be run in the same process or a process will be started for each set of tests in a class. (This is mainly useful when porting Java tests to Buck from Apache Ant which allows JUnit tasks to set a fork=&quot;yes&quot; property. It should not be used for new tests since it encourages tests to not cleanup after themselves and increases the tests' computational resources and running time.) noneAll tests will run in the same process.per_testA process will be started for each test class in which all tests of that test class will run. incremental: Enables Kotlin incremental compilation. k2: Enables the Kotlin K2 compiler. labels: A list of labels to be applied to these tests. These labels are arbitrary text strings and have no meaning within buck itself. They can, however, have meaning for you as a test author (e.g., smoke or fast). A label can be used to filter or include a specific test rule when executing buck test resources: Same as kotlin_library(). srcs: Like kotlin_library(), all of the .kt files specified by the srcs argument will be compiled when this rule is built. In addition, all of the corresponding .class files that are built by this rule will be passed as arguments to JUnit when this rule is run as a test. .class files that are passed to JUnit that do not have any methods annotated with @Test are considered failed tests, so make sure that only test case classes are specified as srcs. This is frequently done by specifying srcs as glob(['**/*Test.kt']). std_err_log_level: Same as std_out_log_level, but for std err. std_out_log_level: Log level for messages from the source under test that buck will output to std out. Value must be a valid java.util.logging.Level value. test_rule_timeout_ms: If set specifies the maximum amount of time (in milliseconds) in which all of the tests in this rule should complete. This overrides the default rule_timeout if any has been specified in .buckconfig . test_type: Specifies which test framework to use. The currently supported options are 'junit' and 'testng'. vm_args: Runtime arguments to the JVM running the tests.  "},{"title":"legacy_toolchain​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#legacy_toolchain","content":"def legacy_toolchain( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, toolchain_name: str = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"llvm_link_bitcode​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#llvm_link_bitcode","content":"def llvm_link_bitcode( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, buck2_compatibility: str = _, deps: list[str] = _, deps_query: None | str = _, srcs: list[str | (str, list[str])] = _ ) -&gt; None  A llvm_link_bitcode() rule builds a LLVM bitcode object from a given set LLVM bitcode inputs. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one deps_query: Status: experimental/unstable. The deps query takes a query string that accepts the following query functions, and appends the output of the query to the declared deps: attrfilterdepsexceptintersectfilterkindsetunion The macro $declared_deps may be used anywhere a target literal pattern is expected in order to refer to the explicit deps of this rule as they appear in the rule's definition. For example, if your build rule declares android_library( name = 'lib', deps = ['//foo:foo'], deps_query = '$declared_deps', ) then the macro $declared_deps would be expanded to a literal set(//foo:foo). Some example queries: &quot;filter({name_regex}, $declared_deps)&quot;.format(name_regex='//.*') &quot;attrfilter(annotation_processors, com.foo.Processor, $declared_deps)&quot; &quot;deps('//foo:foo', 1)&quot; Note: any targets included in this query must also be present in deps. srcs: The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the GCC documentation for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. '') or a tuple of a string specifying a source file and a list of compilation flags (e.g. ('', ['-Wall', '-Werror']) ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable). Details​ Examples:  # A rule that builds and runs C/C++ test using gtest. llvm_link_bitcode( name = 'echo_test', srcs = [ 'echo_test.o', // Where this is a LLVM bitcode object. 'echo_other.o', // And this is another LLVM bitcode object. ], )   "},{"title":"lua_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#lua_binary","content":"def lua_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, main_module: str = _, native_starter_library: None | str = _, package_style: None | str = _, platform: None | str = _, platform_deps: list[(str, list[str])] = _, python_platform: None | str = _ ) -&gt; None  A lua_library() rule is used to group together Lua sources to be packaged into a top-level lua_binary() rule. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onedeps: lua_library() rules to this binary will access.main_module: The module which serves as the entry point for this rule. Details​ Examples:  lua_binary( name = 'tailer', main_module = 'tailer', deps = [ ':tailerutils', ], ) lua_library( name = 'tailerutils', srcs = glob(['*.lua']), )   "},{"title":"lua_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#lua_library","content":"def lua_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, base_module: None | str = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, platform_deps: list[(str, list[str])] = _, srcs: list[str] | dict[str, str] = _ ) -&gt; None  A lua_library() rule is used to group together Lua sources to be packaged into a top-level lua_binary() rule. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onebase_module: The package for which the given specified sources and resources should reside in their final location in the top-level binary. If unset, the project relative directory that houses the BUCK file is used.deps: Other lua_library() rules which list srcs from which this rule imports modules.srcs: The set of .lua files included in this library. Details​ Examples:  # A rule that includes a single .py file. lua_library( name = 'fileutil', srcs = ['fileutil.lua'], ) # A rule that uses glob() to include all sources in the directory which the # rule is defined. It also lists a resource file that gets packaged with # the sources in this rule. lua_library( name = 'testutil', srcs = glob(['testutil/**/*.lua'], )   "},{"title":"matlab_program​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#matlab_program","content":"def matlab_program( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _matlab_toolchain: str = _, buck2_compatibility: str = _, main: str ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"ndk_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#ndk_library","content":"def ndk_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, flags: list[str] = _, is_asset: bool = _, labels: list[str] = _, licenses: list[str] = _, srcs: list[str] = _ ) -&gt; None  An ndk_library() is used to define a set of C/C++ files, an Android.mk and an Application.mk file that are used by the NDK's ndk-build tool to generate one or more shared objects. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onedeps: List of build targets to build before this rule.flags: Array of strings passed verbatim to ndk-build. Normally this is not needed, but in some cases you may want to put something here. For example, this can be used to build the libraries in debug mode (NDK_DEBUG=1) or set the number of jobs spawned by ndk-build (by default, the same as the number of cores).is_asset: Normally native shared objects end up in a directory in the root of the APK named lib/. If this parameter is set to True, then these objects are placed in assets/lib/. Placing shared objects in a non-standard location prevents Android from extracting them to the device's internal storage.srcs: The set of files to compile for this rule. If not provided, buck assumes that all files with the following extensions are part of the build: c, cpp, cc, cxx, h, hpp, mk. Details​ Additional notes: An android_binary() that includes this library will aggregate all of the native shared objects into a directory in the root of the APK named lib/ or assets/lib/. Unlike the default invocation of ndk-build,buck will put all intermediate files and build output into a subdirectory under buck-out/gen.  "},{"title":"ndk_toolchain​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#ndk_toolchain","content":"def ndk_toolchain( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, cxx_runtime: None | str = _, cxx_toolchain: str, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, objdump: str, shared_runtime_path: None | str = _, strip_apk_libs_flags: None | list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"ocaml_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#ocaml_binary","content":"def ocaml_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _ocaml_toolchain: str = _, buck2_compatibility: str = _, bytecode_only: None | bool = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, linker_flags: list[str] = _, ocamldep_flags: list[str] = _, platform: None | str = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_linker_flags: list[(str, list[str])] = _, srcs: None | list[str] | dict[str, str] = _, warnings_flags: None | str = _ ) -&gt; None  A ocaml_binary() rule builds both native and bytecode executables from the supplied set of OCaml and C source files and dependencies. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onecompiler_flags: The set of additional compiler flags to pass to ocaml compiler. It supports specifying ppx (see for example).deps: The set of dependencies of this rule. It could include references to ocaml_library and cxx_library rules.platform_deps: Platform specific dependencies. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of dependencies (same format as deps) that are exported if the platform matches the regex. See deps for more information.srcs: The set of source files to be compiled by this rule. It supports *.ml, *.mli, *.mly, *.mll, and *.c files. (see this test as C interop example and this test as parser and lexer example). Details​ Note: Buck is currently tested with 4.X OCaml series. Examples: For more examples, check out our integration tests.  ocaml_binary( name='greet', srcs=[ 'main.ml', 'lex.mll', 'parser.mly', 'hashtable.c', ], deps=[ ':greeting', ':bridge', ], ) ocaml_library( name='greeting', srcs=[ 'greeting.ml', ], deps=[ ':join', ], ) ocaml_library( name='join', srcs=[ 'join.ml', ], ) cxx_library( name='bridge', srcs=[ 'bridge.c', ], )   "},{"title":"ocaml_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#ocaml_library","content":"def ocaml_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _ocaml_toolchain: str = _, buck2_compatibility: str = _, bytecode_only: bool = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, linker_flags: list[str] = _, native_plugin: bool = _, ocamldep_flags: list[str] = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, srcs: None | list[str] | dict[str, str] = _, warnings_flags: None | str = _ ) -&gt; None  A ocaml_library() rule builds a native and a bytecode libraries from the supplied set of OCaml source files and dependencies. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onecompiler_flags: The set of additional compiler flags to pass to ocaml compiler. It supports specifying ppx (see for example).deps: The set of dependencies of this rule. It could include references to ocaml_library and cxx_library rules.platform_deps: Platform specific dependencies. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of dependencies (same format as deps) that are exported if the platform matches the regex. See deps for more information.srcs: The set of source files to be compiled by this rule. It supports *.ml, *.mli, *.mly, *.mll, and *.c files. (see this test as C interop example and this test as parser and lexer example). Details​ Note: Buck is currently tested with 4.X OCaml series. Examples: For more examples, check out our integration tests.  ocaml_library( name='greeting', srcs=[ 'greeting.ml', ], deps=[ ':join', ], )   "},{"title":"ocaml_object​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#ocaml_object","content":"def ocaml_object( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _ocaml_toolchain: str = _, buck2_compatibility: str = _, bytecode_only: None | bool = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, linker_flags: list[str] = _, ocamldep_flags: list[str] = _, platform: None | str = _, platform_deps: list[(str, list[str])] = _, platform_linker_flags: list[(str, list[str])] = _, srcs: None | list[str] | dict[str, str] = _, warnings_flags: None | str = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"ocaml_shared​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#ocaml_shared","content":"def ocaml_shared( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _ocaml_toolchain: str = _, buck2_compatibility: str = _, bytecode_only: None | bool = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, linker_flags: list[str] = _, ocamldep_flags: list[str] = _, platform: None | str = _, platform_deps: list[(str, list[str])] = _, platform_linker_flags: list[(str, list[str])] = _, srcs: None | list[str] | dict[str, str] = _, warnings_flags: None | str = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"platform​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#platform","content":"def platform( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, constraint_values: list[str] = _, deps: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"prebuilt_apple_framework​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#prebuilt_apple_framework","content":"def prebuilt_apple_framework( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _apple_toolchain: str = _, _apple_tools: str = _, _stripped_default: bool = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, dsyms: list[str] = _, exported_linker_flags: list[str] = _, exported_platform_linker_flags: list[(str, list[str])] = _, framework: None | str = _, frameworks: list[str] = _, labels: list[str] = _, libraries: list[str] = _, licenses: list[str] = _, preferred_linkage: str = _, stripped: None | bool = _, supported_platforms_regex: None | str = _ ) -&gt; None  A prebuilt_apple_framework() rule represents a set of Objective-C/C++ source files and is very similar to a prebuilt_cxx_library() rule. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one Details​ Examples:  prebuilt_apple_framework( name = 'MyPrebuiltFramework', framework = 'myPrebuiltFramework.framework', preferred_linkage = 'static', visibility = [ 'PUBLIC' ] )   "},{"title":"prebuilt_cxx_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#prebuilt_cxx_library","content":"def prebuilt_cxx_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _target_os_type: str = _, allow_cache_upload: None | bool = _, buck2_compatibility: str = _, can_be_asset: bool = _, contacts: list[str] = _, default_host_platform: None | str = _, deffile: None | str = _, deps: list[str] = _, exported_deps: list[str] = _, exported_header_style: str = _, exported_headers: list[str] | dict[str, str] = _, exported_lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, exported_lang_preprocessor_flags: dict[str, list[str]] = _, exported_linker_flags: list[str] = _, exported_platform_deps: list[(str, list[str])] = _, exported_platform_headers: list[(str, list[str] | dict[str, str])] = _, exported_platform_linker_flags: list[(str, list[str])] = _, exported_platform_preprocessor_flags: list[(str, list[str])] = _, exported_post_linker_flags: list[str] = _, exported_post_platform_linker_flags: list[(str, list[str])] = _, exported_preprocessor_flags: list[str] = _, extract_soname: bool = _, force_static: bool = _, frameworks: list[str] = _, header_dirs: None | list[str] = _, header_namespace: None | str = _, header_only: bool = _, import_lib: None | str = _, include_in_android_merge_map_output: bool = _, labels: list[str] = _, libraries: list[str] = _, licenses: list[str] = _, link_whole: bool = _, link_without_soname: bool = _, linker_flags: list[str] = _, local_linker_flags: list[str] = _, platform_header_dirs: None | list[(str, list[str])] = _, platform_import_lib: None | list[(str, str)] = _, platform_shared_lib: None | list[(str, str)] = _, platform_static_lib: None | list[(str, str)] = _, platform_static_pic_lib: None | list[(str, str)] = _, post_linker_flags: list[str] = _, preferred_linkage: str = _, provided: bool = _, public_include_directories: list[str] = _, public_system_include_directories: list[str] = _, raw_headers: list[str] = _, shared_lib: None | str = _, soname: None | str = _, static_lib: None | str = _, static_pic_lib: None | str = _, supported_platforms_regex: None | str = _, supports_merged_linking: None | bool = _, supports_python_dlopen: bool = _, supports_shared_library_interface: bool = _, versioned_exported_lang_platform_preprocessor_flags: list[(dict[str, str], dict[str, list[(str, list[str])]])] = _, versioned_exported_lang_preprocessor_flags: list[(dict[str, str], dict[str, list[str]])] = _, versioned_exported_platform_preprocessor_flags: list[(dict[str, str], list[(str, list[str])])] = _, versioned_exported_preprocessor_flags: list[(dict[str, str], list[str])] = _, versioned_header_dirs: None | list[(dict[str, str], list[str])] = _, versioned_import_lib: None | list[(dict[str, str], str)] = _, versioned_shared_lib: None | list[(dict[str, str], str)] = _, versioned_soname: None | list[(dict[str, str], str)] = _, versioned_static_lib: None | list[(dict[str, str], str)] = _, versioned_static_pic_lib: None | list[(dict[str, str], str)] = _ ) -&gt; None  A prebuilt_cxx_library() rule represents a set of native libraries and C/C++ header files and provides various flags to control how they are linked and exported. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneallow_cache_upload: Whether to allow uploading the output of this rule to be uploaded to cache when the action is executed locally if the configuration allows (i.e. there is a cache configured and the client has permission to write to it).deffile: Specifies the *.def file used on windows to modify a dll's exports in place of explicit __declspec(dllexport) declarations. The default is to not use a defile.exported_deps: Dependencies that will also appear to belong to any rules that depend on this one. This has two effects: Exported dependencies will also be included in the link line of dependents of this rules, but normal dependencies will not. When reexport_all_header_dependencies = False, only exported headers of the rules specified here are re-exported.exported_headers: The set of header files that are made available for inclusion to the source files in the target and all targets that transitively depend on it. These should be specified as either a list of header files or a dictionary of header names to header files. The headers can be included with #include &quot;$HEADER_NAMESPACE/$HEADER_NAME&quot; or #include &lt;$HEADER_NAMESPACE/$HEADER_NAME&gt;, where $HEADER_NAMESPACE is the value of the target's header_namespace attribute, and $HEADER_NAME is the header name if specified, and the filename of the header file otherwise. Note that the header name can contain forward slashes (/). See header_namespace for more information.exported_linker_flags: Flags to add to the linker command line when the output from this rule, or the output from any rule that transitively depends on this rule, is used in a link operation.exported_platform_deps: Platform specific dependencies that will also appear to belong to any rules that depend on this one. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of external dependencies (same format as exported_deps) that are exported if the platform matches the regex. See exported_deps for more information.exported_platform_headers: Platform specific header files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of header files or a dictionary of header names to header files that will be made available for inclusion to the source files in the target and all targets that transitively depend on it if the platform matches the regex. See headers for more information.exported_platform_preprocessor_flags: Platform specific exported preprocessor flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when preprocessing the source files in the target and all targets that transitively depend on it if the platform matches the regex. See exported_preprocessor_flags for more information.header_namespace: A path prefix when including headers of this target. Defaults to the path from the root of the repository to the directory where this target is defined. Can contain forward slashes (/), but cannot start with one. See headers for more information.header_only: Indicates if this library only consists of headers or not. If this is set to True, Buck will not link this library into any library that depends on it.local_linker_flags: Flags to add to the linker command line whenever the output from this rule is used in a link operation driven by this rule (e.g. when this rule links a shared library, but not when the output is linked into a shared library by another rule's link group links).platform_shared_lib: Platform specific shared library. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element the path to the library. See shared_lib for more information.platform_static_lib: Platform specific static library. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element the path to the library. See static_lib for more information.platform_static_pic_lib: Platform specific static PIC library. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element the path to the library. See static_pic_lib for more information.preferred_linkage: Determines what linkage is used when the library is depended on by another target. To control how the dependencies of this library are linked, use link_style instead.shared_lib: The path to the library to use when performing shared linking.static_lib: The path to the library to use when performing static linking.static_pic_lib: The path to the library to use when performing static PIC linking.supported_platforms_regex: If present, an un-anchored regex (in java.util.regex.Pattern syntax) that matches all platforms that this library supports. It will not be built for other platforms.supports_merged_linking: Whether this rule supports building with the merged linking strategy when building for non-native binaries (e.g. when using .buckconfig s merged setting). Details​ Examples: A prebuilt library containing only headers that other libraries may need.  prebuilt_cxx_library( name = 'stdutil', header_only = True, header_dirs = [ 'include', ], )  A prebuilt library with static and shared libs.  prebuilt_cxx_library( name = 'mylib', soname = 'libmylib.so', static_lib = 'libmylib.a', static_pic_lib = 'libmylib_pic.a', shared_lib = 'libmylib.so', exported_headers = [ 'mylib.h', ], )  A prebuilt library with multiple builds for multiple platforms.  prebuilt_cxx_library( name = 'mylib', soname = 'libmylib.so', platform_shared_lib = [ ('android-arm', 'android-arm/libmylib.so'), ('android-x86', 'android-x86/libmylib.so'), ('iphonesimulator-x86_64', 'iphonesimulator-x86_64/libmylib.so'), ], platform_static_lib = [ ('android-arm', 'android-arm/libmylib.a'), ('android-x86', 'android-x86/libmylib.a'), ('iphonesimulator-x86_64', 'iphonesimulator-x86_64/libmylib.a'), ], exported_headers = [ 'mylib.h', ], )   "},{"title":"prebuilt_cxx_library_group​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#prebuilt_cxx_library_group","content":"def prebuilt_cxx_library_group( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, exported_deps: list[str] = _, exported_platform_deps: list[(str, list[str])] = _, exported_preprocessor_flags: list[str] = _, import_libs: dict[str, str] = _, include_dirs: list[str] = _, include_in_android_merge_map_output: bool = _, labels: list[str] = _, licenses: list[str] = _, provided_shared_libs: dict[str, str] = _, shared_libs: dict[str, str] = _, shared_link: list[str] = _, static_libs: list[str] = _, static_link: list[str] = _, static_pic_libs: list[str] = _, static_pic_link: list[str] = _, supported_platforms_regex: None | str = _, supports_shared_library_interface: bool = _ ) -&gt; None  A prebuilt_cxx_library_group() rule represents a group of native libraries which should be handled together in a single rule, perhaps using special link-line construction. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneexported_deps: Dependencies that will also appear to belong to any rules that depend on this one. This has two effects: Exported dependencies will also be included in the link line of dependents of this rules, but normal dependencies will not. When reexport_all_header_dependencies = False, only exported headers of the rules specified here are re-exported.exported_platform_deps: Platform specific dependencies that will also appear to belong to any rules that depend on this one. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of external dependencies (same format as exported_deps) that are exported if the platform matches the regex. See exported_deps for more information.provided_shared_libs: The map of system-provided shared library names to paths used when using the shared link style. The shared_link parameter should refer to these libs using their library name.shared_libs: The map of shared library names to paths used when using the shared link style. The shared_link parameter should refer to these libs using their library name.shared_link: The arguments to use when linking this library group using the shared link style. The actual paths to libraries should be listed in the shared_libs parameter, and referenced via the the $(lib [name]) macro (or the $(rel-lib [name]) macro, when the shared library should be linked using the -L[dir] -l[name] style) in these args.static_libs: The paths to the libraries used when using the static link style. The static_link parameter should refer to these libs using their index number.static_link: The arguments to use when linking this library group using the static link style. The actual paths to libraries should be listed in the static_libs parameter, and referenced via the the $(lib [index]) macro in these args.static_pic_libs: The paths to the libraries used when using the static link style. The static_pic_link parameter should refer to these libs using their index number.static_pic_link: The arguments to use when linking this library group using the static-pic link style. The actual paths to libraries should be listed in the static_pic_libs parameter, and referenced via the the $(lib [index]) macro in these args. Details​ Examples: A prebuilt library group wrapping two libraries that must be linked together.  prebuilt_cxx_library_group( name = 'util', static_link = [ '-Wl,--start-group', '$(lib 0)', '$(lib 1)', '-Wl,--end-group', ], static_libs = [ 'lib/liba.a', 'lib/libb.a', ], static_pic_link = [ '-Wl,--start-group', '$(lib 0)', '$(lib 1)', '-Wl,--end-group', ], static_libs = [ 'lib/liba_pic.a', 'lib/libb_pic.a', ], shared_link = [ '$(rel-lib liba.so)', '$(rel-lib libb.so)', ], shared_libs = { 'liba.so': 'lib/liba.so', }, provided_shared_libs = { 'libb.so': 'lib/libb.so', }, )   "},{"title":"prebuilt_dotnet_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#prebuilt_dotnet_library","content":"def prebuilt_dotnet_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, assembly: str, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _ ) -&gt; None  A prebuilt_dotnet_library() rule is used to include prebuilt .Net assembles into your .Net code. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneassembly: The path to the DLL that this rule provides. Details​ Examples:  prebuilt_dotnet_library( name = 'log4net', assembly = 'log4net.dll', ) csharp_library( name = 'example', srcs = [ 'Hello.cs', ], framework_ver = 'net46', deps = [ ':log4net', 'System.dll', ], )   "},{"title":"prebuilt_jar​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#prebuilt_jar","content":"def prebuilt_jar( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _dex_min_sdk_version: None | int = _, _dex_toolchain: str = _, _exec_os_type: str = _, _prebuilt_jar_toolchain: str = _, binary_jar: str, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, desugar_deps: list[str] = _, generate_abi: bool = _, javadoc_url: None | str = _, labels: list[str] = _, licenses: list[str] = _, maven_coords: None | str = _, never_mark_as_unused_dependency: bool = _, required_for_source_only_abi: bool = _, source_jar: None | str = _ ) -&gt; None  A prebuilt_jar() rule is used to identify a JAR file that is checked into our repository as a precompiled binary rather than one that is built from source by Buck. Frequently, these are used to reference third-party JAR files (such as junit.jar) and are used as dependencies of java_library() rules. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onebinary_jar: Path to the pre-built JAR file.deps: Rules that must be built before this rule. Because the binary_jar is already built, there should be nothing to build, so this should be empty.javadoc_url: URL to the Javadoc for the .class files in the binary_jar.source_jar: Path to a JAR file that contains the .java files to create the .class in the binary_jar. This is frequently provided for debugging purposes. Details​ Examples:  prebuilt_jar( name = 'junit', binary_jar = 'junit-4.8.2.jar', source_jar = 'junit-4.8.2-sources.jar', javadoc_url = 'http://kentbeck.github.com/junit/javadoc/4.8/', ) java_library( name = 'tests', srcs = glob(['tests/**/*Test.java']), deps = [ ':junit', ], )   "},{"title":"prebuilt_native_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#prebuilt_native_library","content":"def prebuilt_native_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, has_wrap_script: bool = _, is_asset: bool = _, labels: list[str] = _, licenses: list[str] = _, native_libs: str ) -&gt; None  A prebuilt_native_library() rule is used to bundle native libraries (i.e., .so files) for Android. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onehas_wrap_script: When using an exopackage, if this parameter is set to True, then the libraries for this rule are included in the primary APK even if native libraries would otherwise not be placed in it. This is intended for a native library directory that contains a wrap.sh script, which must be included in the primary APK to take effect. Only one of is_asset and has_wrap_script can be set for a rule.is_asset: Normally native shared objects end up in a directory in the root of the APK named lib/. If this parameter is set to True, then these objects are placed in assets/lib/. Placing shared objects in a non-standard location prevents Android from extracting them to the device's internal storage. Details​ Examples: Most of the time, a prebuilt_native_library is private to the android_library() that uses it:  prebuilt_native_library( name = 'native_libs', native_libs = 'libs', ) android_library( name = 'my_lib', srcs = glob(['*.java']), deps = [ ':native_libs', ], )   "},{"title":"prebuilt_ocaml_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#prebuilt_ocaml_library","content":"def prebuilt_ocaml_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, bytecode_c_libs: list[str] = _, bytecode_lib: None | str = _, bytecode_only: bool = _, c_libs: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, include_dir: None | str = _, labels: list[str] = _, lib_dir: str = _, lib_name: str = _, licenses: list[str] = _, native_c_libs: list[str] = _, native_lib: None | str = _, platform_deps: list[(str, list[str])] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"prebuilt_python_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#prebuilt_python_library","content":"def prebuilt_python_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _create_manifest_for_source_dir: str = _, _create_third_party_build_root: str = _, _extract: str = _, _python_toolchain: str = _, binary_src: str, buck2_compatibility: str = _, compile: bool = _, contacts: list[str] = _, cxx_header_dirs: None | list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, exclude_deps_from_merged_linking: bool = _, ignore_compile_errors: bool = _, infer_cxx_header_dirs: bool = _, labels: list[str] = _, licenses: list[str] = _, strip_soabi_tags: bool = _ ) -&gt; None  A prebuilt_python_library() rule is used to include prebuilt python packages into the output of a top-level python_binary() or python_test() rule. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one binary_src: The path to the .whl or .egg to use. Note: .egg files have a very particular naming convention that must be followed - otherwise it will not be found at runtime! deps: Other prebuilt_python_library() rules which this library depends on. These may also be python_library rules if you want to depend on a source-based copy of the library. exclude_deps_from_merged_linking: When linking the top-level binary with a merged .buckconfig, do not merge or re-link any native transitive deps of this library. This is useful if this library wraps prebuilt native extensions which cannot be re-linked as part of library merging. labels: Set of arbitrary strings which allow you to annotate a build rule with tags that can be searched for over an entire dependency tree using buck query() . strip_soabi_tags: Strip the SOABI tags from extensions in the prebuilt library. Note that this should be considered unsafe, as it removes builtin protections that fail fast when a potententially incompatible native extension is imported. Details​ These prebuilt libraries can either be whl files or eggs whls for most packages are available for download from PyPI. The whl used may be downloaded with remote_file(). However, Buck does not attempt to infer dependency information from pip, so that information will have to be imparted by the user. To create an egg for a package, run python setup.py bdist_egg in the package source distribution. Examples:  # A simple prebuilt_python_library with no external dependencies. remote_file( name = &quot;requests-download&quot;, url = &quot;https://files.pythonhosted.org/packages/51/bd/23c926cd341ea6b7dd0b2a00aba99ae0f828be89d72b2190f27c11d4b7fb/requests-2.22.0-py2.py3-none-any.whl&quot;, sha1 = &quot;e1fc28120002395fe1f2da9aacea4e15a449d9ee&quot;, out = &quot;requests-2.22.0-py2.py3-none-any.whl&quot;, ) prebuilt_python_library( name = &quot;requests&quot;, binary_src = &quot;:requests-download&quot;, ) # A slightly more complex example prebuilt_python_library( name = &quot;greenlet&quot;, binary_src = &quot;greenlet-0.4.7-py2.7-macosx-10.10-x86_64.egg&quot;, ) prebuilt_python_library( name = &quot;gevent&quot;, binary_src = &quot;gevent-1.0.2-py2.7-macosx-10.10-x86_64.egg&quot;, deps = [ &quot;:greenlet&quot;, ], )   "},{"title":"python_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#python_binary","content":"def python_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _create_manifest_for_source_dir: str = _, _cxx_hacks: str = _, _cxx_toolchain: str = _, _exec_os_type: str = _, _package_remotely: bool = _, _python_toolchain: str = _, _target_os_type: str = _, allow_cache_upload: None | bool = _, anonymous_link_groups: bool = _, auto_link_groups: bool = _, base_module: None | str = _, binary_linker_flags: list[str] = _, bolt_flags: list[str] = _, bolt_profile: None | str = _, buck2_compatibility: str = _, build_args: list[str] = _, compile: None | bool = _, compiler_flags: list[str] = _, constraint_overrides: list[str] = _, contacts: list[str] = _, coverage_instrumentation_compiler_flags: list[str] = _, cxx_main: str = _, cxx_platform: None | str = _, cxx_runtime_type: None | str = _, deduplicate_merged_link_roots: None | bool = _, default_host_platform: None | str = _, default_platform: None | str = _, defaults: dict[str, str] = _, deps: list[str] = _, deps_query: None | str = _, devirt_enabled: bool = _, distributed_thinlto_partial_split_dwarf: bool = _, dummy_omnibus: None | str = _, enable_distributed_thinlto: bool = _, executable_deps: list[str] = _, executable_name: None | str = _, exported_needs_coverage_instrumentation: bool = _, extension: None | str = _, fat_lto: bool = _, focused_list_target: None | str = _, frameworks: list[str] = _, header_namespace: None | str = _, headers: list[str] | dict[str, str] = _, headers_as_raw_headers_mode: None | str = _, include_directories: list[str] = _, inplace_build_args: list[str] = _, labels: list[str] = _, lang_compiler_flags: dict[str, list[str]] = _, lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = _, lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, lang_preprocessor_flags: dict[str, list[str]] = _, libraries: list[str] = _, licenses: list[str] = _, link_deps_query_whole: bool = _, link_execution_preference: None | str = _, link_group: None | str = _, link_group_deps: list[str] = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_group_min_binary_node_count: None | int = _, link_group_public_deps_label: None | str = _, link_ordering: None | str = _, link_style: str = _, link_whole: bool = _, linker_extra_outputs: list[str] = _, linker_flags: list[str] = _, main: None | str = _, main_function: None | str = _, main_module: None | str = _, make_py_package: None | str = _, manifest_module_entries: None | dict[str, list[str] | dict[str, typing.Any]] = _, native_link_strategy: None | str = _, package_split_dwarf_dwp: bool = _, package_style: None | str = _, par_style: None | str = _, platform: None | str = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, platform_linker_flags: list[(str, list[str])] = _, platform_preload_deps: list[(str, list[str])] = _, platform_preprocessor_flags: list[(str, list[str])] = _, platform_srcs: list[(str, list[str | (str, list[str])])] = _, post_linker_flags: list[str] = _, post_platform_linker_flags: list[(str, list[str])] = _, precompiled_header: None | str = _, prefer_stripped_native_objects: bool = _, prefer_stripped_objects: bool = _, prefix_header: None | str = _, preload_deps: list[str] = _, preprocessor_flags: list[str] = _, py_version_for_type_checking: None | str = _, raw_headers: list[str] = _, repl_main: None | str = _, repl_only_deps: list[str] = _, resources: list[str] | dict[str, str] = _, run_with_inplace: bool = _, runtime_env: None | dict[str, str] = _, standalone_build_args: list[str] = _, static_extension_finder: str = _, static_extension_utils: str = _, strip_libpar: str = _, strip_stapsdt: bool = _, thin_lto: bool = _, typing: bool = _, version_universe: None | str = _, weak_framework_names: list[str] = _, zip_safe: None | bool = _ ) -&gt; None  A python_binary() rule is used to build an executable Python package that includes Python sources and resources from all transitive dependencies. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneallow_cache_upload: Whether to allow uploading the output of this rule to be uploaded to cache when the action is executed locally if the configuration allows (i.e. there is a cache configured and the client has permission to write to it).base_module: The package in which the main module should reside in its final location in the binary. If unset, Buck uses the project-relative directory that contains the BUCK file.deduplicate_merged_link_roots: When linking multiple top-level binaries with the merged .buckconfig, coalesce root link rules which are identical across independent merged links.deps: A list of python_library() rules that specify Python modules to include in the binary — including all transitive dependencies of these rules.labels: Set of arbitrary strings which allow you to annotate a build rule with tags that can be searched for over an entire dependency tree using buck query() .link_group_deps: Additional targets to traverse when building link groups, but which should not be direct dependencies of the main executable.link_group_public_deps_label: Surface nodes with this label as &quot;public&quot; nodes in the main executable when linking with with link groups.linker_flags: Additional linker flags that should be applied to any linking which is specific to this rule. Note that whether these flags are used is dependent on the native link strategy selected in .buckconfig and currently applies only to the merged .buckconfig; the separate link strategy pulls in shared libraries that are linked in the context of the rules that own them, such as cxx_library().main: The Python file which serves as the entry point for the binary. The interpreter initiates execution of the binary with the code in this file.main_function: Name of a Python function that will serve as the main entry point of the binary. The name is either a fully qualified name like foo.bar.baz or it starts with a . like .bar.baz, in which case it is relative to the package containing the target. This should usually be a function defined within one of the dependencies of this target. This attribute should be preferred over main_module or main, and it is an error to specify more than one of these.main_module: The python module that should be the entry point of the binary. This should be a module name within a python_library that this binary depends on. Note that module names take base_module of the library into account. This property is mutually exclusive with main, and should be preferred to main, which is deprecated.manifest_module_entries: If present, it should be a string -&gt; entry mapping that gets generated into a __manifest__ module in the executable. Top level string keys will be the names of variables in this module (so they must be valid Python identifiers). An entry can be a list of strings, or a further string-keyed dictionary.package_style: Used to override the global packaging style that is set in [.buckconfig ].platform: The name of the Python platform flavor to build against by default as defined in the buckconfig#pythonsection of .buckconfig.preload_deps: A list of C/C++ library dependencies that need to be loaded before any other libraries when the PEX starts up. This requires dynamic loader support, such as LD_PRELOAD, found on most systems. This list is order- sensitive and the preload libraries listed here are passed down to the dynamic linker in the same order.py_version_for_type_checking: This option will force the type checker to perform checking under a specific version of Python interpreter.typing: Determines whether to perform type checking on the given target. Default is False. Details​ Examples: Build an executable from the Python files in the BUCK directory.  # BUCK python_binary( name = 'tailer', main_module = 'tailer', deps = [ ':tailerutils', ], ) python_library( name = 'tailerutils', # The main module, tailer.py, is specified here. # (Separated out from the glob pattern for clarity.) srcs = glob(['tailer.py', '*.py']), )   "},{"title":"python_bootstrap_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#python_bootstrap_binary","content":"def python_bootstrap_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _exec_os_type: str = _, _python_bootstrap_toolchain: str = _, _win_python_wrapper: None | str = _, buck2_compatibility: str = _, deps: list[str] = _, main: str ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"python_bootstrap_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#python_bootstrap_library","content":"def python_bootstrap_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, deps: list[str] = _, srcs: list[str] ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"python_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#python_library","content":"def python_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _create_manifest_for_source_dir: str = _, _create_third_party_build_root: str = _, _cxx_toolchain: str = _, _python_toolchain: str = _, base_module: None | str = _, buck2_compatibility: str = _, contacts: list[str] = _, cxx_platform: None | str = _, default_host_platform: None | str = _, deps: list[str] = _, exclude_deps_from_merged_linking: bool = _, ignore_compile_errors: bool = _, labels: list[str] = _, licenses: list[str] = _, platform: None | str = _, platform_deps: list[(str, list[str])] = _, platform_resources: list[(str, list[str] | dict[str, str])] = _, platform_srcs: list[(str, list[str] | dict[str, str])] = _, py_version_for_type_checking: None | str = _, resources: list[str] | dict[str, str] = _, srcs: list[str] | dict[str, str] = _, type_stubs: list[str] | dict[str, str] = _, typing: bool = _, version_universe: None | str = _, versioned_resources: None | list[(dict[str, str], list[str] | dict[str, str])] = _, versioned_srcs: None | list[(dict[str, str], list[str] | dict[str, str])] = _, zip_safe: None | bool = _ ) -&gt; None  A python_library() rule is used to group together Python source files and resources to be passed together in as a dep of other rules. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onebase_module: The package in which the specified source files and resources should reside in their final location in the top-level binary. If unset, Buck uses the project-relative directory that contains the BUCK file.deps: Other python_library() rules that list srcs from which this rule imports modules.exclude_deps_from_merged_linking: When linking the top-level binary with a merged .buckconfig, do not merge or re-link any native transitive deps of this library. This is useful if this library wraps prebuilt native extensions which cannot be re-linked as part of library merging.labels: Set of arbitrary strings which allow you to annotate a build rule with tags that can be searched for over an entire dependency tree using buck query() .platform_resources: Python-platform-specific resource files. These should be specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched, and the second element is a list of resource files. The regex should use java.util.regex.Pattern syntax. The platform name is a Python platform flavor defined in the buckconfig#python section of .buckconfig.platform_srcs: Python-platform-specific source files. These should be specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched, and the second element is a list of source files. The regex should use java.util.regex.Pattern syntax. The platform name is a Python platform flavor defined in the buckconfig#python section of .buckconfig.py_version_for_type_checking: This option will force the type checker to perform checking under a specific version of Python interpreter.srcs: The set of Python (.py) files to include in this library.typing: Determines whether to perform type checking on the given target. Default is False. Details​ Examples: Include Python source files and resource files.  # BUCK # A rule that includes a single Python file. python_library( name = 'fileutil', srcs = ['fileutil.py'], deps = [ '//third_party/python-magic:python-magic', ], ) # A rule that uses glob() to include all Python source files in the # directory in which the rule is defined. The rule also specifies a # resource file that gets packaged with the source file. python_library( name = 'testutil', srcs = glob(['testutil/**/*.py']), resources = [ 'testdata.dat', ], )   "},{"title":"python_needed_coverage_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#python_needed_coverage_test","content":"def python_needed_coverage_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _inject_test_env: str = _, _remote_test_execution_toolchain: str = _, buck2_compatibility: str = _, contacts: list[str] = _, env: dict[str, str] = _, labels: list[str] = _, needed_coverage: list[(int, str, None | str)] = _, remote_execution: None | str | dict[str, None | bool | int | str | list[dict[str, str]] | dict[str, str]] = _, remote_execution_action_key_providers: None | str = _, test: str ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"python_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#python_test","content":"def python_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _create_manifest_for_source_dir: str = _, _cxx_hacks: str = _, _cxx_toolchain: str = _, _exec_os_type: str = _, _inject_test_env: str = _, _python_toolchain: str = _, _remote_test_execution_toolchain: str = _, _target_os_type: str = _, _test_main: str = _, additional_coverage_targets: list[str] = _, anonymous_link_groups: bool = _, auto_link_groups: bool = _, base_module: None | str = _, binary_linker_flags: list[str] = _, bolt_flags: list[str] = _, bolt_profile: None | str = _, buck2_compatibility: str = _, build_args: list[str] = _, compile: None | bool = _, compiler_flags: list[str] = _, constraint_overrides: list[str] = _, contacts: list[str] = _, coverage_instrumentation_compiler_flags: list[str] = _, cxx_main: str = _, cxx_platform: None | str = _, cxx_runtime_type: None | str = _, deduplicate_merged_link_roots: None | bool = _, default_host_platform: None | str = _, default_platform: None | str = _, defaults: dict[str, str] = _, deps: list[str] = _, deps_query: None | str = _, devirt_enabled: bool = _, distributed_thinlto_partial_split_dwarf: bool = _, dummy_omnibus: None | str = _, enable_distributed_thinlto: bool = _, env: dict[str, str] = _, exclude_deps_from_merged_linking: bool = _, executable_deps: list[str] = _, executable_name: None | str = _, exported_needs_coverage_instrumentation: bool = _, extension: None | str = _, fat_lto: bool = _, focused_list_target: None | str = _, frameworks: list[str] = _, header_namespace: None | str = _, headers: list[str] | dict[str, str] = _, headers_as_raw_headers_mode: None | str = _, implicit_test_library: None | str = _, include_directories: list[str] = _, inplace_build_args: list[str] = _, labels: list[str] = _, lang_compiler_flags: dict[str, list[str]] = _, lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = _, lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = _, lang_preprocessor_flags: dict[str, list[str]] = _, libraries: list[str] = _, licenses: list[str] = _, link_deps_query_whole: bool = _, link_execution_preference: None | str = _, link_group: None | str = _, link_group_deps: list[str] = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_group_min_binary_node_count: None | int = _, link_group_public_deps_label: None | str = _, link_ordering: None | str = _, link_style: str = _, link_whole: bool = _, linker_extra_outputs: list[str] = _, linker_flags: list[str] = _, main_function: None | str = _, main_module: None | str = _, make_py_package: None | str = _, manifest_module_entries: None | dict[str, list[str] | dict[str, typing.Any]] = _, native_link_strategy: None | str = _, needed_coverage: list[(int, str, None | str)] = _, package_split_dwarf_dwp: bool = _, package_style: None | str = _, par_style: None | str = _, platform: None | str = _, platform_compiler_flags: list[(str, list[str])] = _, platform_deps: list[(str, list[str])] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, platform_linker_flags: list[(str, list[str])] = _, platform_preload_deps: list[(str, list[str])] = _, platform_preprocessor_flags: list[(str, list[str])] = _, platform_resources: list[(str, list[str] | dict[str, str])] = _, platform_srcs: list[(str, list[str | (str, list[str])])] = _, post_linker_flags: list[str] = _, post_platform_linker_flags: list[(str, list[str])] = _, precompiled_header: None | str = _, prefer_stripped_native_objects: bool = _, prefer_stripped_objects: bool = _, prefix_header: None | str = _, preload_deps: list[str] = _, preprocessor_flags: list[str] = _, py_version_for_type_checking: None | str = _, raw_headers: list[str] = _, remote_execution: None | str | dict[str, None | bool | int | str | list[dict[str, str]] | dict[str, str]] = _, remote_execution_action_key_providers: None | str = _, repl_main: None | str = _, repl_only_deps: list[str] = _, resources: list[str] | dict[str, str] = _, run_with_inplace: bool = _, runner: None | str = _, runtime_env: None | dict[str, str] = _, specs: None | str = _, srcs: list[str] | dict[str, str] = _, standalone_build_args: list[str] = _, static_extension_finder: str = _, static_extension_utils: str = _, strip_libpar: str = _, strip_stapsdt: bool = _, test_rule_timeout_ms: None | int = _, thin_lto: bool = _, typing: bool = _, version_universe: None | str = _, versioned_resources: None | list[(dict[str, str], list[str] | dict[str, str])] = _, versioned_srcs: None | list[(dict[str, str], list[str] | dict[str, str])] = _, weak_framework_names: list[str] = _, zip_safe: None | bool = _ ) -&gt; None  A python_test() rule defines a set of .py files that contain tests to run via the Python unit testing framework. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one base_module: The package in which the specified source files and resources should reside in their final location in the top-level binary. If unset, Buck uses the project-relative directory that contains the BUCK file. deduplicate_merged_link_roots: When linking multiple top-level binaries with the merged .buckconfig, coalesce root link rules which are identical across independent merged links. deps: other rules used by the tests in this rule's sources. env: A map of environment names and values to set when running the test. It is also possible to expand references to other rules within the values of these environment variables, using builtin string parameter macros: $(location //path/to:target)Expands to the location of the output of the build rule. This means that you can refer to these without needing to be aware of how Buck is storing data on the disk mid-build. exclude_deps_from_merged_linking: When linking the top-level binary with a merged .buckconfig, do not merge or re-link any native transitive deps of this library. This is useful if this library wraps prebuilt native extensions which cannot be re-linked as part of library merging. labels: Set of arbitrary strings which allow you to annotate a build rule with tags that can be searched for over an entire dependency tree using buck query() . link_group_deps: Additional targets to traverse when building link groups, but which should not be direct dependencies of the main executable. link_group_public_deps_label: Surface nodes with this label as &quot;public&quot; nodes in the main executable when linking with with link groups. linker_flags: Additional linker flags that should be applied to any linking which is specific to this rule. Note that whether these flags are used is dependent on the native link strategy selected in .buckconfig and currently applies only to the merged .buckconfig; the separate link strategy pulls in shared libraries that are linked in the context of the rules that own them, such as cxx_library(). main_function: Name of a Python function that will serve as the main entry point of the binary. The name is either a fully qualified name like foo.bar.baz or it starts with a . like .bar.baz, in which case it is relative to the package containing the target. This should usually be a function defined within one of the dependencies of this target. This attribute should be preferred over main_module or main, and it is an error to specify more than one of these. main_module: The main module used to run the tests. This parameter is normally not needed, as Buck will provide a default main module that runs all tests. However, you can override this with your own module to perform custom initialization or command line processing. Your custom module can import the standard Buck test main as __test_main__, and can invoke it's normal main function as __test_main__.main(sys.argv). manifest_module_entries: If present, it should be a string -&gt; entry mapping that gets generated into a __manifest__ module in the executable. Top level string keys will be the names of variables in this module (so they must be valid Python identifiers). An entry can be a list of strings, or a further string-keyed dictionary. package_style: Used to override the global packaging style that is set in [.buckconfig ]. platform: The name of the Python platform flavor to build against by default as defined in the buckconfig#pythonsection of .buckconfig. platform_resources: Python-platform-specific resource files. These should be specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched, and the second element is a list of resource files. The regex should use java.util.regex.Pattern syntax. The platform name is a Python platform flavor defined in the buckconfig#python section of .buckconfig. preload_deps: A list of C/C++ library dependencies that need to be loaded before any other libraries when the PEX starts up. This requires dynamic loader support, such as LD_PRELOAD, found on most systems. This list is order- sensitive and the preload libraries listed here are passed down to the dynamic linker in the same order. py_version_for_type_checking: This option will force the type checker to perform checking under a specific version of Python interpreter. srcs: The set of Python (.py) files to include in this library. test_rule_timeout_ms: If set specifies the maximum amount of time (in milliseconds) in which all of the tests in this rule should complete. This overrides the default rule_timeout if any has been specified in .buckconfig . typing: Determines whether to perform type checking on the given target. Default is False. Details​ If your test requires static files you should specify these in the resources or platform_resources arguments. If you do not specify these files, they won't be available when your test runs. Examples:  # A rule that includes a single .py file containing tests. python_test( name = 'fileutil_test', srcs = ['fileutil_tests.py'], deps = [ ':fileutil', ], ) # A rule that uses glob() to include all sources in the directory which the # rule is defined. It also lists a resource file that gets packaged with # the sources in this rule. python_library( name = 'fileutil', srcs = glob(['fileutil/**/*.py']), resources = [ 'testdata.dat', ], )   "},{"title":"python_test_runner​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#python_test_runner","content":"def python_test_runner( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, main_module: str = _, src: str ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this onelabels: Set of arbitrary strings which allow you to annotate a build rule with tags that can be searched for over an entire dependency tree using buck query() .  "},{"title":"remote_file​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#remote_file","content":"def remote_file( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _unzip_tool: str = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, out: None | str = _, sha1: None | str = _, sha256: None | str = _, type: None | str = _, url: str, vpnless_url: None | str = _ ) -&gt; None  A remote_file() rule is used to download files from the Internet to be used as dependencies for other rules. These rules are downloaded by running fetch, or can be downloaded as part of build. See the note there about the .buckconfig setting to configure that. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one out: An optional name to call the downloaded artifact. Buck will generate a default name if one is not provided that uses the name of the rule. type: An optional type of the downloaded file. dataRegular data file.executable Executable file. Buck will ensure that output has appropriate permissions if applicable. exploded_zip Zip archive which will be automatically unzipped into an output directory. url: You can specify an http, https, or a mvn URL. If you specify a mvn URL, it will be decoded as described in the javadocs for MavenUrlDecoder See the example section below. vpnless_url: An optional additional URL from which this resource can be downloaded when off VPN. Meta-internal only. Details​ Examples: Here's an example of a remote_file() using an https URL.  remote_file( name = 'android-ndk-r10e-darwin-x86_64', url = 'https://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin', sha1 = 'b57c2b9213251180dcab794352bfc9a241bf2557', )  Here's an example of a remote_file() using a mvn URL being referenced by a prebuilt_jar().  prebuilt_jar( name = 'jetty-all', binary_jar = 'jetty-all-9.2.10.v20150310.jar', source_jar = ':jetty-source', ) remote_file( name = 'jetty-source', out = 'jetty-all-9.2.10.v20150310-sources.jar', url = 'mvn:org.eclipse.jetty.aggregate:jetty-all:src:9.2.10.v20150310', sha1 = '311da310416d2feb3de227081d7c3f48742d7075', )  Here's an example of a remote_file() using a mvn URI which uses a non-default maven repository host.  remote_file( name = 'jetty-source', out = 'jetty-all-9.2.10.v20150310-sources.jar', url = 'mvn:https://maven-repo.com:org.eclipse.jetty.aggregate:jetty-all:src:9.2.10.v20150310', sha1 = '311da310416d2feb3de227081d7c3f48742d7075', )  Here's an example of a remote_file() using a mvn URI which uses a Maven classifier.  remote_file( name = 'groovy-groovysh-indy', out = 'jetty-all-9.2.10.v20150310-sources.jar', url = 'mvn:org.codehaus.groovy:groovy-groovysh:jar:indy:2.4.1', sha1 = '1600fde728c885cc9506cb102deb1b494bd7c130', )   "},{"title":"robolectric_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#robolectric_test","content":"def robolectric_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _android_toolchain: str = _, _apple_platforms: dict[str, str] = _, _build_only_native_code: bool = _, _exec_os_type: str = _, _inject_test_env: str = _, _is_building_android_binary: bool = _, _java_test_toolchain: str = _, _java_toolchain: str = _, _kotlin_toolchain: str = _, _remote_test_execution_toolchain: str = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, abi_generation_mode: None | str = _, android_optional_jars: None | list[str] = _, annotation_processing_tool: None | str = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, cxx_library_whitelist: list[str] = _, default_cxx_platform: None | str = _, default_host_platform: None | str = _, deps: list[str] = _, env: dict[str, str] = _, exported_deps: list[str] = _, exported_provided_deps: list[str] = _, extra_arguments: list[str] = _, extra_kotlinc_arguments: list[str] = _, fork_mode: str = _, friend_paths: list[str] = _, incremental: bool = _, jar_postprocessor: None | str = _, java: None | str = _, java_agents: list[str] = _, java_version: None | str = _, javac: None | str = _, k2: bool = _, kotlin_compiler_plugins: dict[str, dict[str, str]] = _, labels: list[str] = _, language: None | str = _, licenses: list[str] = _, locales_for_binary_resources: list[str] = _, manifest: None | str = _, manifest_entries: dict[str, typing.Any] = _, manifest_file: None | str = _, maven_coords: None | str = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, plugins: list[str] = _, preferred_density_for_binary_resources: None | str = _, proguard_config: None | str = _, provided_deps: list[str] = _, provided_deps_query: None | str = _, remote_execution: None | str | dict[str, None | bool | int | str | list[dict[str, str]] | dict[str, str]] = _, remote_execution_action_key_providers: None | str = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resource_stable_ids: None | str = _, resource_union_package: None | str = _, resources: list[str] = _, resources_root: None | str = _, robolectric_manifest: str, robolectric_runtime_dependencies: list[str] = _, robolectric_runtime_dependency: None | str = _, run_test_separately: bool = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, srcs: list[str] = _, std_err_log_level: None | int | str = _, std_out_log_level: None | int | str = _, target: None | str = _, test_case_timeout_ms: None | int = _, test_class_names_file: None | str = _, test_rule_timeout_ms: None | int = _, test_type: None | str = _, unbundled_resources_root: None | str = _, use_cxx_libraries: None | bool = _, use_dependency_order_classpath: None | bool = _, use_jvm_abi_gen: None | bool = _, used_as_dependency_deprecated_do_not_use: bool = _, vm_args: list[str] = _ ) -&gt; None  A robolectric_test() rule is used to define a set of .java files that contain tests to run via JUnit with Robolectric test runner. It extends from java_test() rule. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneextra_kotlinc_arguments: List of additional arguments to pass into the Kotlin compiler.incremental: Enables Kotlin incremental compilation.k2: Enables the Kotlin K2 compiler.robolectric_manifest: An Android Manifest for the rule to declare any permissions or intents it may need or want to handle. May either be a file or an android_manifest() target.robolectric_runtime_dependency: Robolectric only runs in offline mode with buck. Specify the relative directory containing all the jars Robolectric uses at runtime.  "},{"title":"rust_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#rust_binary","content":"def rust_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _exec_os_type: str = _, _rust_toolchain: str = _, _target_os_type: str = _, _workspaces: list[str] = _, allow_cache_upload: None | bool = _, anonymous_link_groups: bool = _, auto_link_groups: bool = _, buck2_compatibility: str = _, clippy_configuration: None | str = _, contacts: list[str] = _, coverage: bool = _, crate: None | str = _, crate_root: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, deps: list[str] = _, edition: None | str = _, enable_distributed_thinlto: bool = _, env: dict[str, str] = _, features: list[str] = _, flagged_deps: list[(str, list[str])] = _, incremental_build_mode: None | str = _, incremental_enabled: bool = _, labels: list[str] = _, licenses: list[str] = _, link_group: None | str = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_group_min_binary_node_count: None | int = _, link_style: None | str = _, linker_flags: list[str] = _, mapped_srcs: dict[str, str] = _, named_deps: list[(str, str)] | dict[str, str] = _, resources: list[str] | dict[str, str] = _, rpath: bool = _, rustc_flags: list[str] = _, rustdoc_flags: list[str] = _, srcs: list[str] = _, version_universe: None | str = _ ) -&gt; None  A rust_binary() rule builds a native executable from the supplied set of Rust source files and dependencies. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one _workspaces: Internal implementation detail of Rust workspaces. This should not be set manually and will be replaced in favor of metadata in a future version of buck2. allow_cache_upload: Whether to allow uploading the output of this rule to be uploaded to cache when the action is executed locally if the configuration allows (i.e. there is a cache configured and the client has permission to write to it). crate_root: Set the name of the top-level source file for the crate, which can be used to override the default (see srcs). deps: The set of dependencies of this rule. Currently, this supports rust_library and prebuilt_rust_library rules. edition: Set the language edition to be used for this rule. Can be set to any edition the compiler supports (2018 right now). If unset it uses the compiler's default (2015). env: Set environment variables for this rule's invocations of rustc. The environment variable values may include macros which are expanded. features: The set of features to be enabled for this rule. These are passed to rustc with --cfg feature=&quot;{feature}&quot;, and can be used in the code with #[cfg(feature = &quot;{feature}&quot;)]. link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared. linker_flags: The set of additional flags to pass to the linker. mapped_srcs: Add source files along with a local path mapping. Rust is sensitive to the layout of source files, as the directory structure follows the module structure. However this is awkward if the source file is, for example, generated by another rule. In this case, you can set up a mapping from the actual source path to something that makes sense locally. For example mapped_srcs = {&quot;:generate-module&quot;, &quot;src/generated.rs&quot; }. These are added to the regular srcs, so a file should not be listed in both. named_deps: Add crate dependencies and define a local name by which to use that dependency by. This allows a crate to have multiple dependencies with the same crate name. For example: named_deps = {&quot;local_name&quot;, &quot;:some_rust_crate&quot; }. The dependencies may also be non-Rust, but the alias is ignored. It has no effect on the symbols provided by a C/C++ library. rpath: Set the &quot;rpath&quot; in the executable when using a shared link style. rustc_flags: The set of additional compiler flags to pass to rustc. srcs: The set of Rust source files to be compiled by this rule. One of the source files is the root module of the crate. By default this is lib.rs for libraries, main.rs for executables, or the crate's name with .rs appended. This can be overridden with the crate_root rule parameter. Details​ If you invoke a build with the check flavor, then Buck will invoke rustc to check the code (typecheck, produce warnings, etc), but won't generate an executable code. When applied to binaries it produces no output; for libraries it produces metadata for consumers of the library. Note: Buck is currently tested with (and therefore supports) version 1.32.0 of Rust. Examples: For more examples, check out our integration tests.  rust_binary( name='greet', srcs=[ 'greet.rs', ], deps=[ ':greeting', ], ) rust_library( name='greeting', srcs=[ 'greeting.rs', ], deps=[ ':join', ], ) rust_library( name='join', srcs=[ 'join.rs', ], )   "},{"title":"rust_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#rust_library","content":"def rust_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _exec_os_type: str = _, _rust_toolchain: str = _, _target_os_type: str = _, _workspaces: list[str] = _, buck2_compatibility: str = _, clippy_configuration: None | str = _, contacts: list[str] = _, coverage: bool = _, crate: None | str = _, crate_dynamic: None | str = _, crate_root: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, deps: list[str] = _, doc_deps: list[str] = _, doc_env: dict[str, str] = _, doc_link_style: None | str = _, doc_linker_flags: list[str] = _, doc_named_deps: list[(str, str)] | dict[str, str] = _, doctests: None | bool = _, edition: None | str = _, env: dict[str, str] = _, exported_linker_flags: list[str] = _, exported_post_linker_flags: list[str] = _, features: list[str] = _, flagged_deps: list[(str, list[str])] = _, incremental_build_mode: None | str = _, incremental_enabled: bool = _, labels: list[str] = _, licenses: list[str] = _, link_style: None | str = _, linker_flags: list[str] = _, mapped_srcs: dict[str, str] = _, named_deps: list[(str, str)] | dict[str, str] = _, preferred_linkage: str = _, proc_macro: bool = _, resources: list[str] | dict[str, str] = _, rustc_flags: list[str] = _, rustdoc_flags: list[str] = _, soname: None | str = _, srcs: list[str] = _, supports_python_dlopen: None | bool = _, version_universe: None | str = _ ) -&gt; None  A rust_library() rule builds a native library from the supplied set of Rust source files and dependencies. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one _workspaces: Internal implementation detail of Rust workspaces. This should not be set manually and will be replaced in favor of metadata in a future version of buck2. crate_root: Set the name of the top-level source file for the crate, which can be used to override the default (see srcs). deps: The set of dependencies of this rule. Currently, this supports rust_library and prebuilt_rust_library rules. doc_deps: The set of dependencies of this rule. Currently, this supports rust_library and prebuilt_rust_library rules. doc_env: Set environment variables for this rule's invocations of rustc. The environment variable values may include macros which are expanded. doc_link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared. doc_linker_flags: The set of additional flags to pass to the linker. doc_named_deps: Add crate dependencies and define a local name by which to use that dependency by. This allows a crate to have multiple dependencies with the same crate name. For example: named_deps = {&quot;local_name&quot;, &quot;:some_rust_crate&quot; }. The dependencies may also be non-Rust, but the alias is ignored. It has no effect on the symbols provided by a C/C++ library. edition: Set the language edition to be used for this rule. Can be set to any edition the compiler supports (2018 right now). If unset it uses the compiler's default (2015). env: Set environment variables for this rule's invocations of rustc. The environment variable values may include macros which are expanded. exported_linker_flags: A set of additional flag to pass before this item on the link line, even if this items is compiled to a DSO. exported_post_linker_flags: A set of additional flag to pass after this item on the link line, even if this items is compiled to a DSO. features: The set of features to be enabled for this rule. These are passed to rustc with --cfg feature=&quot;{feature}&quot;, and can be used in the code with #[cfg(feature = &quot;{feature}&quot;)]. link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared. linker_flags: The set of additional flags to pass to the linker. mapped_srcs: Add source files along with a local path mapping. Rust is sensitive to the layout of source files, as the directory structure follows the module structure. However this is awkward if the source file is, for example, generated by another rule. In this case, you can set up a mapping from the actual source path to something that makes sense locally. For example mapped_srcs = {&quot;:generate-module&quot;, &quot;src/generated.rs&quot; }. These are added to the regular srcs, so a file should not be listed in both. named_deps: Add crate dependencies and define a local name by which to use that dependency by. This allows a crate to have multiple dependencies with the same crate name. For example: named_deps = {&quot;local_name&quot;, &quot;:some_rust_crate&quot; }. The dependencies may also be non-Rust, but the alias is ignored. It has no effect on the symbols provided by a C/C++ library. rustc_flags: The set of additional compiler flags to pass to rustc. soname: Sets the soname (&quot;shared object name&quot;) of any shared library produced from this rule. The default value is based on the full rule name. The macro $(ext) will be replaced with a platform-appropriate extension. An argument can be provided, which is a library version. For example soname = 'libfoo.$(ext 2.3)' will be libfoo.2.3.dylib on Mac and libfoo.so.2.3 on Linux. srcs: The set of Rust source files to be compiled by this rule. One of the source files is the root module of the crate. By default this is lib.rs for libraries, main.rs for executables, or the crate's name with .rs appended. This can be overridden with the crate_root rule parameter. Details​ If you invoke a build with the check flavor, then Buck will invoke rustc to check the code (typecheck, produce warnings, etc), but won't generate an executable code. When applied to binaries it produces no output; for libraries it produces metadata for consumers of the library. Note: Buck is currently tested with (and therefore supports) version 1.32.0 of Rust. Examples: For more examples, check out our integration tests.  rust_library( name='greeting', srcs=[ 'greeting.rs', ], deps=[ ':join', ], )   "},{"title":"rust_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#rust_test","content":"def rust_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, _exec_os_type: str = _, _inject_test_env: str = _, _remote_test_execution_toolchain: str = _, _rust_toolchain: str = _, _target_os_type: str = _, _workspaces: list[str] = _, anonymous_link_groups: bool = _, auto_link_groups: bool = _, buck2_compatibility: str = _, clippy_configuration: None | str = _, contacts: list[str] = _, coverage: bool = _, crate: None | str = _, crate_root: None | str = _, default_host_platform: None | str = _, default_platform: None | str = _, deps: list[str] = _, edition: None | str = _, enable_distributed_thinlto: bool = _, env: dict[str, str] = _, features: list[str] = _, flagged_deps: list[(str, list[str])] = _, framework: bool = _, incremental_build_mode: None | str = _, incremental_enabled: bool = _, labels: list[str] = _, licenses: list[str] = _, link_group: None | str = _, link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = _, link_group_min_binary_node_count: None | int = _, link_style: None | str = _, linker_flags: list[str] = _, mapped_srcs: dict[str, str] = _, named_deps: list[(str, str)] | dict[str, str] = _, remote_execution: None | str | dict[str, None | bool | int | str | list[dict[str, str]] | dict[str, str]] = _, remote_execution_action_key_providers: None | str = _, resources: list[str] | dict[str, str] = _, rpath: bool = _, run_env: dict[str, str] = _, rustc_flags: list[str] = _, rustdoc_flags: list[str] = _, srcs: list[str] = _, version_universe: None | str = _ ) -&gt; None  A rust_test() rule builds a Rust test native executable from the supplied set of Rust source files and dependencies and runs this test. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one _workspaces: Internal implementation detail of Rust workspaces. This should not be set manually and will be replaced in favor of metadata in a future version of buck2. crate_root: Set the name of the top-level source file for the crate, which can be used to override the default (see srcs). deps: The set of dependencies of this rule. Currently, this supports rust_library and prebuilt_rust_library rules. edition: Set the language edition to be used for this rule. Can be set to any edition the compiler supports (2018 right now). If unset it uses the compiler's default (2015). env: Set environment variables for this rule's invocations of rustc and during execution of the tests. The environment variable values may include macros which are expanded. features: The set of features to be enabled for this rule. These are passed to rustc with --cfg feature=&quot;{feature}&quot;, and can be used in the code with #[cfg(feature = &quot;{feature}&quot;)]. framework: Use the standard test framework. If this is set to false, then the result is a normal executable which requires a main(), etc. It is still expected to accept the same command-line parameters and produce the same output as the test framework. link_style: Determines whether to build and link this rule's dependencies statically or dynamically. Can be either static, static_pic or shared. linker_flags: The set of additional flags to pass to the linker. mapped_srcs: Add source files along with a local path mapping. Rust is sensitive to the layout of source files, as the directory structure follows the module structure. However this is awkward if the source file is, for example, generated by another rule. In this case, you can set up a mapping from the actual source path to something that makes sense locally. For example mapped_srcs = {&quot;:generate-module&quot;, &quot;src/generated.rs&quot; }. These are added to the regular srcs, so a file should not be listed in both. named_deps: Add crate dependencies and define a local name by which to use that dependency by. This allows a crate to have multiple dependencies with the same crate name. For example: named_deps = {&quot;local_name&quot;, &quot;:some_rust_crate&quot; }. The dependencies may also be non-Rust, but the alias is ignored. It has no effect on the symbols provided by a C/C++ library. rpath: Set the &quot;rpath&quot; in the executable when using a shared link style. run_env: Set environment variables during test execution. The environment variable values may include macros which are expanded. rustc_flags: The set of additional compiler flags to pass to rustc. srcs: The set of Rust source files to be compiled by this rule. One of the source files is the root module of the crate. By default this is lib.rs for libraries, main.rs for executables, or the crate's name with .rs appended. This can be overridden with the crate_root rule parameter. Details​ Note: Buck is currently tested with (and therefore supports) version 1.32.0 of Rust. Examples: For more examples, check out our integration tests.  rust_test( name='greet', srcs=[ 'greet.rs', ], deps=[ ':greeting', ], ) rust_library( name='greeting', srcs=[ 'greeting.rs', ], deps=[ ':join', ], ) rust_library( name='join', srcs=[ 'join.rs', ], )   "},{"title":"scala_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#scala_library","content":"def scala_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, abi_generation_mode: None | str = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, exported_deps: list[str] = _, exported_provided_deps: list[str] = _, extra_arguments: list[str] = _, java_version: None | str = _, javac: None | str = _, labels: list[str] = _, licenses: list[str] = _, manifest_file: None | str = _, maven_coords: None | str = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, plugins: list[str] = _, proguard_config: None | str = _, provided_deps: list[str] = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resources: list[str] = _, resources_root: None | str = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, srcs: list[str] = _, target: None | str = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"scala_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#scala_test","content":"def scala_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _wip_java_plugin_arguments: dict[str, list[str]] = _, abi_generation_mode: None | str = _, annotation_processor_deps: list[str] = _, annotation_processor_params: list[str] = _, annotation_processors: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, cxx_library_whitelist: list[str] = _, default_cxx_platform: None | str = _, default_host_platform: None | str = _, deps: list[str] = _, deps_query: None | str = _, env: dict[str, str] = _, exported_deps: list[str] = _, exported_provided_deps: list[str] = _, extra_arguments: list[str] = _, fork_mode: str = _, java_version: None | str = _, javac: None | str = _, labels: list[str] = _, licenses: list[str] = _, manifest_file: None | str = _, maven_coords: None | str = _, never_mark_as_unused_dependency: None | bool = _, on_unused_dependencies: None | str = _, plugins: list[str] = _, proguard_config: None | str = _, provided_deps: list[str] = _, remove_classes: list[str] = _, required_for_source_only_abi: bool = _, resources: list[str] = _, resources_root: None | str = _, run_test_separately: bool = _, runtime_deps: list[str] = _, source: None | str = _, source_abi_verification_mode: None | str = _, source_only_abi_deps: list[str] = _, srcs: list[str] = _, std_err_log_level: None | int | str = _, std_out_log_level: None | int | str = _, target: None | str = _, test_case_timeout_ms: None | int = _, test_rule_timeout_ms: None | int = _, test_type: None | str = _, use_cxx_libraries: None | bool = _, use_dependency_order_classpath: None | bool = _, vm_args: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"scene_kit_assets​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#scene_kit_assets","content":"def scene_kit_assets( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, path: str ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"sh_binary​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#sh_binary","content":"def sh_binary( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _target_os_type: str = _, append_script_extension: bool = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, labels: list[str] = _, licenses: list[str] = _, main: str, resources: list[str] = _ ) -&gt; None  An sh_binary() is used to execute a shell script. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one append_script_extension: By default, sh_binary ensures that the script has an appropriate extension (e.g. .sh or .bat), appending one itself if necessary. Setting this to False prevents that behavior and makes the caller responsible for ensuring an existing appropriate extension. main: Either the path to the script (relative to the build file), or a build target. This file must be executable in order to be run. resources: A list of files or build rules that this rule requires in order to run. These could be things such as random data files. When the script runs, the $BUCK_DEFAULT_RUNTIME_RESOURCESenvironment variable specifies the directory that contains these resources. This directory's location is determined entirely by Buck; the script should not assume the directory's location. The resources are also made available in a tree structure that mirrors their locations in the source and buck-out trees. The environment variable $BUCK_PROJECT_ROOT specifies a directory that contains all the resources, laid out in their locations relative to the original buck project root. Details​ Examples: This sh_binary() just cats a sample data file back at the user.  # $REPO/BUCK sh_binary( name = &quot;script&quot;, main = &quot;script.sh&quot;, resources = [ &quot;data.dat&quot;, ], )   # Sample data file with data we need at runtime $ echo &quot;I'm a datafile&quot; &gt; data.dat # Create a simple script that prints out the resource $ cat &gt; script.sh #!/bin/sh cat $BUCK_DEFAULT_RUNTIME_RESOURCES/data.dat # Make sure the script is executable $ chmod u+x script.sh # Run the script, and see that it prints out the resource we provided $ buck run //:script Jobs completed: 4. Time elapsed: 0.2s. BUILD SUCCEEDED I'm a datafile   "},{"title":"sh_test​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#sh_test","content":"def sh_test( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _inject_test_env: str = _, _remote_test_execution_toolchain: str = _, args: list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, env: dict[str, str] = _, labels: list[str] = _, licenses: list[str] = _, list_args: None | list[str] = _, list_env: None | dict[str, str] = _, remote_execution: None | str | dict[str, None | bool | int | str | list[dict[str, str]] | dict[str, str]] = _, remote_execution_action_key_providers: None | str = _, resources: list[str] = _, run_args: list[str] = _, run_env: dict[str, str] = _, run_test_separately: bool = _, test: None | str = _, test_rule_timeout_ms: None | int = _, type: None | str = _ ) -&gt; None  A sh_test() is a test rule that can pass results to the test runner by invoking a shell script. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one args: The list of arguments to invoke this script with. These are literal values, and no shell interpolation is done. These can contain string parameter macros, for example, to give the location of a generated binary to the test script. env: Environment variable overrides that should be used when running the script. The key is the variable name, and the value is its value. The values can contain string parameter macrossuch as the location of a generated binary to be used by the test script. test: Either the path to the script (relative to the build file), or a build target. This file must be executable in order to be run. type: If provided, this will be sent to any configured .buckconfig Details​ NOTE: This rule is not currently supported on Windows. Examples: This sh_test() fails if a string does not match a value.  # $REPO/BUCK sh_test( name = &quot;script_pass&quot;, test = &quot;script.sh&quot;, args = [&quot;--pass&quot;], ) sh_test( name = &quot;script_fail&quot;, test = &quot;script.sh&quot;, args = [&quot;--fail&quot;], )   # Create a simple script that prints out the resource $ cat &gt; script.sh #!/bin/sh for arg in $@; do if [ &quot;$arg&quot; == &quot;--pass&quot; ]; then echo &quot;Passed&quot; exit 0; fi done echo &quot;Failed&quot; exit 1 # Make sure the script is executable $ chmod u+x script.sh # Run the script, and see that one test passes, one fails $ buck test //:script_pass //:script_fail FAILURE script.sh sh_test Building: finished in 0.0 sec (100%) 2/2 jobs, 0 updated Total time: 0.0 sec Testing: finished in 0.0 sec (1 PASS/1 FAIL) RESULTS FOR //:script_fail //:script_pass FAIL &lt;100ms 0 Passed 0 Skipped 1 Failed //:script_fail FAILURE script.sh sh_test ====STANDARD OUT==== Failed PASS &lt;100ms 1 Passed 0 Skipped 0 Failed //:script_pass TESTS FAILED: 1 FAILURE Failed target: //:script_fail FAIL //:script_fail   "},{"title":"supermodule_target_graph​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#supermodule_target_graph","content":"def supermodule_target_graph( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, label_pattern: None | str = _, labels: list[str] = _, licenses: list[str] = _, on_duplicate_entry: str = _, out: str = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"swift_library​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#swift_library","content":"def swift_library( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, bridging_header: None | str = _, buck2_compatibility: str = _, compiler_flags: list[str] = _, contacts: list[str] = _, default_host_platform: None | str = _, deps: list[str] = _, enable_cxx_interop: bool = _, frameworks: list[str] = _, import_obj_c_forward_declarations: bool = _, labels: list[str] = _, libraries: list[str] = _, licenses: list[str] = _, module_name: None | str = _, preferred_linkage: str = _, sdk_modules: list[str] = _, serialize_debugging_options: bool = _, soname: None | str = _, srcs: list[str] = _, supported_platforms_regex: None | str = _, target_sdk_version: None | str = _, uses_explicit_modules: bool = _, version: None | str = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"swift_toolchain​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#swift_toolchain","content":"def swift_toolchain( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _internal_platform_path: None | str = _, _internal_sdk_path: None | str = _, _swiftc_wrapper: str = _, architecture: None | str = _, buck2_compatibility: str = _, can_toolchain_emit_obj_c_header_textually: bool = _, contacts: list[str] = _, default_host_platform: None | str = _, explicit_modules_uses_gmodules: bool = _, labels: list[str] = _, licenses: list[str] = _, make_swift_comp_db: str = _, make_swift_interface: str = _, object_format: str = _, placeholder_tool: None | str = _, platform_path: None | str = _, prefix_serialized_debug_info: bool = _, resource_dir: None | str = _, runtime_paths_for_bundling: list[str] = _, runtime_paths_for_linking: list[str] = _, runtime_run_paths: list[str] = _, sdk_dependencies_path: None | str = _, sdk_modules: list[str] = _, sdk_path: None | str = _, static_runtime_paths: list[str] = _, supports_cxx_interop_requirement_at_import: bool = _, supports_relative_resource_dir: bool = _, supports_swift_cxx_interoperability_mode: bool = _, supports_swift_importing_obj_c_forward_declarations: bool = _, swift_ide_test_tool: None | str = _, swift_stdlib_tool: str, swift_stdlib_tool_flags: list[str] = _, swiftc: str, swiftc_flags: list[str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"test_suite​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#test_suite","content":"def test_suite( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, test_deps: list[str] = _ ) -&gt; None  A test_suite() is used to create a grouping of tests that should all be run by just testing this rule. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one Details​ This rule can then be given to buck test, and all tests that it depends on will be invoked. Note that the test_suite() target is not tested itself, it just tells buck to run other tests. It will not show up in calls to the external runner nor in the normal test output. Examples: This test_suite() sets up two different sets of tests to run, 'all' tests and 'slow' tests. Note that all_tests can depend on slow_tests, and all three tests are run.  # instrumentation_tests/BUCK: sh_test( name = &quot;instrumentation_tests&quot;, test = &quot;instrumentation_tests.sh&quot;, visibility = [&quot;PUBLIC&quot;], ) # integration_tests/BUCK: sh_test( name = &quot;integration_tests&quot;, test = &quot;integration_tests.sh&quot;, visibility = [&quot;PUBLIC&quot;], ) # unit_tests/BUCK: sh_test( name = &quot;unit_tests&quot;, test = &quot;unit_tests.sh&quot;, visibility = [&quot;PUBLIC&quot;], ) # BUCK: test_suite( name = &quot;slow_tests&quot;, tests = [ &quot;//instrumentation_tests:instrumentation_tests&quot;, &quot;//integration_tests:integration_tests&quot;, ], ) test_suite( name = &quot;all_tests&quot;, tests = [ &quot;:slow_tests&quot;, &quot;//unit_tests:unit_tests&quot;, ], )  Yields output like this when run:  $ buck test //:slow_tests ... RESULTS FOR //instrumentation_tests:instrumentation_tests //integration_tests:integration_tests PASS &lt;100ms 1 Passed 0 Skipped 0 Failed //instrumentation_tests:instrumentation_tests PASS &lt;100ms 1 Passed 0 Skipped 0 Failed //integration_tests:integration_tests TESTS PASSED ... $ buck test //:all_tests RESULTS FOR //instrumentation_tests:instrumentation_tests //integration_tests:integration_tests //unit_tests:unit_tests PASS &lt;100ms 1 Passed 0 Skipped 0 Failed //instrumentation_tests:instrumentation_tests PASS &lt;100ms 1 Passed 0 Skipped 0 Failed //integration_tests:integration_tests PASS &lt;100ms 1 Passed 0 Skipped 0 Failed //unit_tests:unit_tests TESTS PASSED   "},{"title":"toolchain_alias​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#toolchain_alias","content":"def toolchain_alias( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, actual: str, buck2_compatibility: str = _ ) -&gt; None  toolchain_alias acts like alias but for toolchain rules. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneactual: The actual toolchain that is being aliased. This should be a toolchain rule. Details​ The toolchain_alias itself is a toolchain rule and the actual argument is expected to be a toolchain_rule as well.  "},{"title":"versioned_alias​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#versioned_alias","content":"def versioned_alias( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, labels: list[str] = _, licenses: list[str] = _, versions: dict[str, str] = _ ) -&gt; None  Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this one  "},{"title":"windows_resource​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#windows_resource","content":"def windows_resource( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _cxx_toolchain: str = _, buck2_compatibility: str = _, header_namespace: None | str = _, headers: list[str] | dict[str, str] = _, include_directories: list[str] = _, labels: list[str] = _, platform_headers: list[(str, list[str] | dict[str, str])] = _, raw_headers: list[str] = _, srcs: list[str | (str, list[str])] = _ ) -&gt; None  A windows_resource() rule specifies a set of Window's Resource File (.rc) that are compiled into object files. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneheader_namespace: A path prefix when including headers of this target. Defaults to the path from the root of the repository to the directory where this target is defined. Can contain forward slashes (/), but cannot start with one. See headers for more information.headers: The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header name can contain forward slashes (/). The headers can be included with #include &quot;$HEADER_NAMESPACE/$HEADER_NAME&quot; or #include &lt;$HEADER_NAMESPACE/$HEADER_NAME&gt; , where $HEADER_NAMESPACE is the value of the target's header_namespace attribute, and $HEADER_NAME is the header name if specified, and the filename of the header file otherwise. See header_namespace for more information.include_directories: A list of include directories (with raw_headers) to be added to the compile command for compiling this target (via -I). An include directory is relative to the current package.platform_headers: Platform specific header files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of header files or a dictionary of header names to header files that will be made available for inclusion to the source files in the target if the platform matches the regex. See headers for more information.raw_headers: The set of header files that can be used for inclusion to the source files in the target and all targets that transitively depend on it. Buck doesn't add raw headers to the search path of a compiler/preprocessor automatically. include_directories and public_include_directories are the recommended way to add raw headers to the search path (they will be added via -I). compiler_flags, preprocessor_flags and exported_preprocessor_flags can also be used to add such raw headers to the search path if inclusion via -isystem or -iquote is needed. raw_headers cannot be used together with headers or exported_headers in the same target.srcs: The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the GCC documentation for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. '') or a tuple of a string specifying a source file and a list of compilation flags (e.g. ('', ['-Wall', '-Werror']) ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable). Details​ The files are compiled into .res files using rc.exe and then compiled into object files using cvtres.exe. They are not part of cxx_library because Microsoft's linker ignores the resources unless they are specified as an object file, meaning including them in a possibly static library is unintuitive. Examples:  # A rule that includes a single .rc file and compiles it into an object file. windows_resource( name = &quot;resources&quot;, srcs = [ &quot;resources.rc&quot;, ], ) # A rule that links against the above windows_resource rule. cxx_binary( name = &quot;app&quot;, srcs = [ &quot;main.cpp&quot;, ], deps = [ &quot;:resources&quot; ], )   "},{"title":"worker_tool​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#worker_tool","content":"def worker_tool( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _worker_tool_runner: str = _, args: str | list[str] = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, env: dict[str, str] = _, exe: None | str = _, labels: list[str] = _, licenses: list[str] = _, max_workers: None | int = _, max_workers_per_thread_percent: None | int = _, persistent: None | bool = _ ) -&gt; None  Some external tools have high startup costs. To amortize those costs over the whole build rather than paying them for each rule invocation, use the worker_tool() rule in conjunction with genrule(). Buck then starts the external tool once and reuses it by communicating with it over stdin and stdout using a simple JSON protocol. Parameters​ name: name of the targetdefault_target_platform: specifies the default target platform, used when no platforms are specified on the command linetarget_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationcompatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configurationexec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platformvisibility: a list of visibility patterns restricting what targets can depend on this onewithin_view: a list of visibility patterns restricting what this target can depend onmetadata: a key-value map of metadata associated with this targettests: a list of targets that provide tests for this oneargs: A string of args that is passed to the executable represented by exe on initial startup.env: A map of environment variables that is passed to the executable represented by exe on initial startup.exe: A build target for a rule that outputs an executable, such as an sh_binary(). Buck runs this executable only once per build.max_workers: The maximum number of workers of this type that Buck starts. Use -1 to allow the creation of as many workers as necessary.max_workers_per_thread_percent: The maximum ratio of workers of this type that Buck starts per thread, specified as a positive integer percentage (1-100). Must be greater than or equal to 1 and less than or equal to 100. Only one of max_workers and max_workers_per_thread_percent may be specified.persistent: If set to true, Buck does not restart the tool unless the tool itself changes. This means the tool persists across multiple Buck commands without being shut down and may see the same rule being built more than once. Be careful not to use this setting with tools that don't expect to process the same input—with different contents—twice! Details​ A worker_tool rule can be referenced in the cmd parameter of a genrule by using the macro:  $(exe //path/to:target)  Examples: Consider the following build rules:  # # Buck # worker_tool( name = 'ExternalToolWorker', exe = ':ExternalTool', args = '--arg1 --arg2' ) sh_binary( name = 'ExternalTool', main = 'external_tool.sh', ) genrule( name = 'TransformA', out = 'OutputA.txt', cmd = '$(exe :ExternalToolWorker) argA', ) genrule( name = 'TransformB', out = 'OutputB.txt', cmd = '$(exe :ExternalToolWorker) argB', ) genrule( name = 'TransformC', out = 'OutputC.txt', cmd = '$(exe :ExternalToolWorker) argC', )  When doing a buck build on all three of the above genrules, Buck first creates the worker process by invoking:  ./external_tool.sh --arg1 --arg2  Buck then communicates with this process using JSON over stdin, starting with a handshake:  [ { &quot;id&quot;: 0, &quot;type&quot;: &quot;handshake&quot;, &quot;protocol_version&quot;: &quot;0&quot;, &quot;capabilities&quot;: [] }  Buck then waits for the tool to reply on stdout:  [ { &quot;id&quot;: 0, &quot;type&quot;: &quot;handshake&quot;, &quot;protocol_version&quot;: &quot;0&quot;, &quot;capabilities&quot;: [] }  Then, when building the first genrule, Buck writes to stdin:  ,{ &quot;id&quot;: 1, &quot;type&quot;: &quot;command&quot;, &quot;args_path&quot;: &quot;/tmp/1.args&quot;, &quot;stdout_path&quot;: &quot;/tmp/1.out&quot;, &quot;stderr_path&quot;: &quot;/tmp/1.err&quot; }  The file /tmp/1.args contains argA. The tool should perform the necessary work for this job and then write the job's output to the files supplied by Buck—in this case, /tmp/1.out and /tmp/1.err. Once the job is done, the tool should reply to Buck on stdout with:  ,{ &quot;id&quot;: 1, &quot;type&quot;: &quot;result&quot;, &quot;exit_code&quot;: 0 }  Once Buck hears back from the first genrule's job, it submits the second genrule's job in the same fashion and awaits the response. When the build is all finished, Buck closes the JSON by writing to stdin:  ]  which signals the tool that it should exit after replying on stdout with:  ]  In this example, Buck is guaranteed to invoke  ./external_tool.sh --arg1 --arg2  only once during the build. The three jobs corresponding to the three genrules are submitted synchronously to the single worker process. Note that the id values in the messages are not necessarily increasing or sequential, but they do have to match between the request message and the response message of a given job as well as in the initial handshake. If the tool receives a message type it cannot interpret it should answer with:  { &quot;id&quot;: &amp;ltn&gt;, &quot;type&quot;: &quot;error&quot;, &quot;exit_code&quot;: 1 }  If the tool receives a message type it can interpret, but the other attributes of the message are in an inconsistent state, it should answer with:  { &quot;id&quot;: &amp;ltn&gt;, &quot;type&quot;: &quot;error&quot;, &quot;exit_code&quot;: 2 }   "},{"title":"zip_file​","type":1,"pageTitle":"Rules","url":"/docs/prelude/globals/#zip_file","content":"def zip_file( *, name: str, default_target_platform: None | str = _, target_compatible_with: list[str] = _, compatible_with: list[str] = _, exec_compatible_with: list[str] = _, visibility: list[str] = _, within_view: list[str] = _, metadata: opaque_metadata = _, tests: list[str] = _, _apple_platforms: dict[str, str] = _, _zip_file_toolchain: str = _, buck2_compatibility: str = _, contacts: list[str] = _, default_host_platform: None | str = _, entries_to_exclude: list[str] = _, labels: list[str] = _, licenses: list[str] = _, on_duplicate_entry: str = _, out: str = _, srcs: list[str] = _, zip_srcs: list[str] = _ ) -&gt; None  A zip_file() allows builds to create basic zip files in a platform-agnostic way. Parameters​ name: name of the target default_target_platform: specifies the default target platform, used when no platforms are specified on the command line target_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with a configuration exec_compatible_with: a list of constraints that are required to be satisfied for this target to be compatible with an execution platform visibility: a list of visibility patterns restricting what targets can depend on this one within_view: a list of visibility patterns restricting what this target can depend on metadata: a key-value map of metadata associated with this target tests: a list of targets that provide tests for this one entries_to_exclude: List of regex expressions that describe entries that should not be included in the output zip file. The regexes must be defined using java.util.regex.Pattern syntax. on_duplicate_entry: Action performed when Buck detects that zip_file input contains multiple entries with the same name. The valid values are: overwrite (default): the last entry overwrites all previous entries with the same name.append: all entries are added to the output file.fail: fail the build when duplicate entries are present. out: The name of the zip file that should be generated. This allows builds to use a meaningful target name coupled with a meaningful zip file name. The default value takes the rule's name and appends .zip. srcs: The set of files to include in the zip. Each src will be added to the zip as follows: If the src is the output of another rule, the output will be included using just the output's file name.If the src is a file relative to the rule's declaration, it will be included in the zip with its relative file name. zip_srcs: The set of zip files whose content to include in the output zip file. Note that the order of files in zip_srcs matters because the same zip entry can be included from multiple files. See the on_duplicate_entry argument to learn how to control the behavior when there are multiple entries with the same name. The entries from zip_srcs are added before files from srcs. Details​ Examples: This example will create a simple zip file.  zip_file( # The output will be &quot;example.zip&quot; name = 'example', srcs = # These files will be found in the zip under &quot;dir/&quot; glob(['dir/**/*']) + [ # Imagine this generates the output # &quot;buck-out/gen/foo/hello.txt&quot;. This output will # be found in the zip at &quot;hello.txt&quot; '//some/other:target', ], zip_srcs = [ # The contents of this zip will be added to the generated zip. 'amazing-library-1.0-sources.zip', ], entries_to_exclude = [ &quot;com/example/amazinglibrary/Source1.java&quot;, ], )  If you were to examine the generated zip, the contents would look something like (assuming the output of &quot;//some/other:target&quot; was a file who's path ended withhello.txt, the &quot;dir&quot; glob found two files, and &quot;amazing-library-1.0-sources.zip&quot; contained two Java source files):  dir/file1.txt dir/subdir/file2.txt hello.txt com/example/amazinglibrary/Source2.java  "}]